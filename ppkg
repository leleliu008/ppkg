#!/bin/sh

# Copyright (c) 2021-2023 åˆ˜å¯Œé¢‘
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# https://github.com/leleliu008/ppkg


######################################################################################
####################################  convention  ####################################
# 1. The variable/function name starts with underscore "_" means that it is a private variable/function.
# 2. 0 represents the boolean value false
# 3. 1 represents the boolean value true
# 4. all utilities are GNU-style
######################################################################################

# If IFS is not set, the default value will be <space><tab><newline>
# https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_05_03
unset IFS

_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


# }}}
##############################################################################
# {{{ utils

COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;94m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf '%b' "$*"
}

echo() {
    printf '%b\n' "$*"
}

note() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ””  $*${COLOR_OFF}" >&2
}

warn() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ”¥  $*${COLOR_OFF}" >&2
}

success() {
    printf '%b\n' "${COLOR_GREEN}[âœ”] $*${COLOR_OFF}" >&2
}

error() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
}

abort() {
    EXIT_STATUS_CODE="$1"
    shift
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
    exit "$EXIT_STATUS_CODE"
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$*"
    printf '\n%b\n' "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

run() {
    if [ "$RUN_SILENT" != 1 ] ; then
        echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}$@${COLOR_OFF}"
    fi

    eval "$@"
}

list_size() {
    printf '%s\n' "$#"
}

is_integer() {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

bppend_to_PATH() {
    case ":${PATH}:" in
        *:"$1":*) ;;
        *) export PATH="$1:$PATH" ;;
    esac
}

bppend_to_ACLOCAL_PATH() {
    case ":${ACLOCAL_PATH}:" in
        *:"$1":*) ;;
        *) export ACLOCAL_PATH="$1:$ACLOCAL_PATH" ;;
    esac
}

sed_in_place() {
    if [ "$RUN_SILENT" = 1 ] ; then
        sed -i "$@"
    else
        if [ -z "$SED" ] ; then
            SED="$(command -v gsed || command -v sed)" || abort 1 "command not found: gsed"
        fi

        export SED

        "$PPKG_CORE_DIR/sed-in-place" "$@"
    fi
}

git() {
    if [ -n "$SSL_CERT_FILE" ] ; then
        command git -c http.sslCAInfo="$SSL_CERT_FILE" "$@"
    else
        command git "$@"
    fi
}

# check if the given two versions match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(printf '%s\n' "$1" "$3" | sort -V | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(printf '%s\n' "$1" "$3" | sort -V | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(printf '%s\n' "$1" "$3" | sort -V | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(printf '%s\n' "$1" "$3" | sort -V | tail -n 1)" ]
            ;;
        *)  abort 1 "version_compare: $2: not supported operator."
    esac
}

# }}}
##############################################################################
# {{{ wfetch

# wfetch <URL> [--uri=<URL-MIRROR>] [--sha256=<SHA256>] [-o <OUTPUT-PATH>] [-q] [--no-buffer]
#
# If -o <OUTPUT-PATH> option is specified, the result will be written to file, otherwise, the result will be written to stdout.
#
# If <OUTPUT-PATH> is . .. ./ ../ or ends with slash(/), then it will be treated as a directory, otherwise, it will be treated as a filepath.
#
# If <OUTPUT-PATH> is treated as a directory, then it will be expanded to <OUTPUT-PATH>/$(basename <URL>)
#
# influential environment variable:
# PPKG_URL_TRANSFORM
wfetch() {
    unset FETCH_UTS
    unset FETCH_SHA

    unset FETCH_URL
    unset FETCH_URI

    unset FETCH_PATH

    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_FILEPATH
    unset FETCH_OUTPUT_FILENAME

    unset FETCH_BUFFER_FILEPATH

    unset FETCH_SHA256_EXPECTED

    unset FETCH_SILENT

    unset NOT_BUFFER

    [ -z "$1" ] && abort 1 "wfetch <URL> [OPTION]... , <URL> must be non-empty."

    if [ -z "$PPKG_URL_TRANSFORM" ] ; then
        FETCH_URL="$1"
    else
        FETCH_URL="$("$PPKG_URL_TRANSFORM" "$1")" || return 1
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --uri=*)
                FETCH_URI="${1#*=}"
                ;;
            --sha256=*)
                FETCH_SHA256_EXPECTED="${1#*=}"
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "wfetch <URL> -o <PATH> , <PATH> must be non-empty."
                else
                    FETCH_PATH="$1"
                fi
                ;;
            -q)
                FETCH_SILENT=1
                RUN_SILENT=1
                ;;
            --no-buffer)
                NOT_BUFFER=1
                ;;
            *)  abort 1 "wfetch <URL> [--uri=<URL-MIRROR>] [--sha256=<SHA256>] [-o <PATH>] [-q] , unrecognized option: $1"
        esac
        shift
    done

    if [ -z "$FETCH_URI" ] ; then
        # remove query params
        FETCH_URI="${FETCH_URL%%'?'*}"
        FETCH_URI="https://fossies.org/linux/misc/${FETCH_URI##*/}"
    else
        if [ -n "$PPKG_URL_TRANSFORM" ] ; then
            FETCH_URI="$("$PPKG_URL_TRANSFORM" "$FETCH_URI")" || return 1
        fi
    fi

    case $FETCH_PATH in
        '')
            FETCH_BUFFER_FILEPATH='-'
            ;;
        .)
            FETCH_OUTPUT_DIR='.'
            FETCH_OUTPUT_FILEPATH="$FETCH_OUTPUT_DIR/${FETCH_URL##*/}"
            ;;
        ..)
            FETCH_OUTPUT_DIR='..'
            FETCH_OUTPUT_FILEPATH="$FETCH_OUTPUT_DIR/${FETCH_URL##*/}"
            ;;
        */)
            FETCH_OUTPUT_DIR="${FETCH_PATH%/}"
            FETCH_OUTPUT_FILEPATH="$FETCH_OUTPUT_DIR/${FETCH_URL##*/}"
            ;;
        *)
            FETCH_OUTPUT_DIR="$(dirname "$FETCH_PATH")"
            FETCH_OUTPUT_FILEPATH="$FETCH_PATH"
    esac

    if [ -n "$FETCH_OUTPUT_FILEPATH" ] ; then
        if [ -f "$FETCH_OUTPUT_FILEPATH" ] ; then
            if [ -n "$FETCH_SHA256_EXPECTED" ] ; then
                if [ "$(sha256sum "$FETCH_OUTPUT_FILEPATH" | cut -d ' ' -f1)" = "$FETCH_SHA256_EXPECTED" ] ; then
                    success "$FETCH_OUTPUT_FILEPATH already have been fetched."
                    return 0
                fi
            fi
        fi

        if [ "$NOT_BUFFER" = 1 ] ; then
            FETCH_BUFFER_FILEPATH="$FETCH_OUTPUT_FILEPATH"
        else
            FETCH_UTS="$(date +%s)"

            FETCH_SHA="$(printf '%s\n' "$FETCH_URL:$$:$FETCH_UTS" | sha256sum | cut -d ' ' -f1)"

            FETCH_BUFFER_FILEPATH="$FETCH_OUTPUT_DIR/$FETCH_SHA.tmp"
        fi
    fi

    for FETCH_TOOL in curl wget http lynx aria2c axel
    do
        if command -v "$FETCH_TOOL" > /dev/null ; then
            break
        else
            unset FETCH_TOOL
        fi
    done

    if [ -z "$FETCH_TOOL" ] ; then
        abort 1 "no fetch tool found, please install one of curl wget http lynx aria2c axel, then try again."
    fi

    if [                -n "$FETCH_OUTPUT_DIR" ] ; then
        if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR" || return 1
        fi
    fi

    case $FETCH_TOOL in
        curl)
            unset CURL_OPTIONS

            if [ "$FETCH_SILENT" = 1 ] ; then
                CURL_OPTIONS='--no-progress-meter'
            fi

            if [ -n "$SSL_CERT_FILE" ] ; then
                CURL_OPTIONS="--cacert $SSL_CERT_FILE"
            fi

            run "curl $CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_BUFFER_FILEPATH' '$FETCH_URL'" ||
            run "curl $CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_BUFFER_FILEPATH' '$FETCH_URI'"
            ;;
        wget)
            run "wget --timeout=60 -O '$FETCH_BUFFER_FILEPATH' '$FETCH_URL'" ||
            run "wget --timeout=60 -O '$FETCH_BUFFER_FILEPATH' '$FETCH_URI'"
            ;;
        http)
            run "http --timeout=60 -o '$FETCH_BUFFER_FILEPATH' '$FETCH_URL'" ||
            run "http --timeout=60 -o '$FETCH_BUFFER_FILEPATH' '$FETCH_URI'"
            ;;
        lynx)
            run "lynx -source '$FETCH_URL' > '$FETCH_BUFFER_FILEPATH'" ||
            run "lynx -source '$FETCH_URI' > '$FETCH_BUFFER_FILEPATH'"
            ;;
        aria2c)
            run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_FILENAME' '$FETCH_URL'" ||
            run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_FILENAME' '$FETCH_URI'"
            ;;
        axel)
            run "axel -o '$FETCH_BUFFER_FILEPATH' '$FETCH_URL'" ||
            run "axel -o '$FETCH_BUFFER_FILEPATH' '$FETCH_URI'"
            ;;
        *)  abort 1 "wfetch() unimplementation: $FETCH_TOOL"
            ;;
    esac

    [ $? -eq 0 ] || return 1

    if [ -n "$FETCH_OUTPUT_FILEPATH" ] ; then
        if [ -n "$FETCH_SHA256_EXPECTED" ] ; then
            FETCH_SHA256_ACTUAL="$(sha256sum "$FETCH_BUFFER_FILEPATH" | cut -d ' ' -f1)"

            if [ "$FETCH_SHA256_ACTUAL" != "$FETCH_SHA256_EXPECTED" ] ; then
                abort 1 "sha256sum mismatch.\n    expect : $FETCH_SHA256_EXPECTED\n    actual : $FETCH_SHA256_ACTUAL\n"
            fi
        fi

        if [ "$NOT_BUFFER" != 1 ] ; then
            run mv "$FETCH_BUFFER_FILEPATH" "$FETCH_OUTPUT_FILEPATH"
        fi
    fi
}

# __load_formula_repository_config <REPO-NAME> [REPO-PATH]
  __load_formula_repository_config() {
    FORMULA_REPO_NAME="$1"
    FORMULA_REPO_PATH="$PPKG_FORMULA_REPO_ROOT/$1"
    FORMULA_REPO_CONFIG_FILEPATH="$FORMULA_REPO_PATH/.ppkg-formula-repo.yml"

    [ -d "$FORMULA_REPO_PATH" ] || abort 1 "$1 named formula repository does not exist."
    [ -f "$FORMULA_REPO_CONFIG_FILEPATH" ] || abort 1 "$1 formula repository is broken."

    FORMULA_REPO_URL=
    FORMULA_REPO_BRANCH=
    FORMULA_REPO_PINNED=
    FORMULA_REPO_ENABLED=
    FORMULA_REPO_TIMESTAMP_CREATED=
    FORMULA_REPO_TIMESTAMP_UPDATED=

    FORMULA_REPO_URL="$(yq .url "$FORMULA_REPO_CONFIG_FILEPATH")"

    [ "$FORMULA_REPO_URL" = null ] && abort 1 "$1 formula repository is broken."

    FORMULA_REPO_BRANCH="$(yq .branch "$FORMULA_REPO_CONFIG_FILEPATH")"

    [ "$FORMULA_REPO_BRANCH" = null ] && abort 1 "$1 formula repository is broken."

    FORMULA_REPO_PINNED="$(yq .pinned "$FORMULA_REPO_CONFIG_FILEPATH")"

    case $FORMULA_REPO_PINNED in
        0|1) ;;
        *)   abort 1 "$1 formula repository is broken."
    esac

    FORMULA_REPO_ENABLED="$(yq .enabled "$FORMULA_REPO_CONFIG_FILEPATH")"

    case $FORMULA_REPO_ENABLED in
        0|1) ;;
        *)   abort 1 "$1 formula repository is broken."
    esac

    FORMULA_REPO_TIMESTAMP_CREATED="$(yq .created "$FORMULA_REPO_CONFIG_FILEPATH")"

    [ "${#FORMULA_REPO_TIMESTAMP_CREATED}" -eq 10 ] || abort 1 "$1 formula repository is broken."

    FORMULA_REPO_TIMESTAMP_UPDATED="$(yq .updated "$FORMULA_REPO_CONFIG_FILEPATH")"

    if [ "$FORMULA_REPO_TIMESTAMP_UPDATED" = null ] ; then
           FORMULA_REPO_TIMESTAMP_UPDATED=
    else
        [ "${#FORMULA_REPO_TIMESTAMP_UPDATED}" -eq 10 ] || abort 1 "$1 formula repository is broken."
    fi
}

# }}}
##############################################################################
# {{{ ppkg formula-repo-add

# __create_a_formula_repository_then_sync_it <REPO-NAME> <REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]
  __create_a_formula_repository_then_sync_it() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "please specify a repository url."

    FORMULA_REPO_NAME="$1"
    FORMULA_REPO_URL="$2"

    if [ -z "$PPKG_URL_TRANSFORM" ] ; then
        GIT_FETCH_URL="$FORMULA_REPO_URL"
    else
        GIT_FETCH_URL="$("$PPKG_URL_TRANSFORM" "$FORMULA_REPO_URL")"
    fi

    shift 2

    FORMULA_REPO_BRANCH=
    FORMULA_REPO_PINNED=
    FORMULA_REPO_ENABLED=

    while [ -n "$1" ]
    do
        case $1 in
            --branch=*)
                FORMULA_REPO_BRANCH="${1#*=}"
                ;;
            --pin)
                FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                FORMULA_REPO_PINNED=0
                ;;
            --enable)
                FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    FORMULA_REPO_BRANCH="${FORMULA_REPO_BRANCH:-master}"
    FORMULA_REPO_PINNED="${FORMULA_REPO_PINNED:-0}"
    FORMULA_REPO_ENABLED="${FORMULA_REPO_ENABLED:-1}"

    FORMULA_REPO_PATH="$PPKG_FORMULA_REPO_ROOT/$FORMULA_REPO_NAME"

    if [ -d "$FORMULA_REPO_PATH" ] ; then
        abort 1 "$FORMULA_REPO_NAME named formula repository already exists."
    fi

    printf '%b\n' "${COLOR_PURPLE}==> Adding formula repository${COLOR_OFF} ${COLOR_GREEN}$FORMULA_REPO_NAME${COLOR_OFF}"

    SESSION_DIR="$PPKG_HOME/run/$$/$FORMULA_REPO_NAME"

    run rm -rf     "$SESSION_DIR"
    run install -d "$SESSION_DIR"
    run cd         "$SESSION_DIR"

    run git -c init.defaultBranch=master init
    run git remote add origin "$GIT_FETCH_URL"
    run git -c protocol.version=2 fetch --progress origin "+refs/heads/$FORMULA_REPO_BRANCH:refs/remotes/origin/$FORMULA_REPO_BRANCH"
    run git checkout --progress --force -B "$FORMULA_REPO_BRANCH" "refs/remotes/origin/$FORMULA_REPO_BRANCH"

    cat > .ppkg-formula-repo.yml <<EOF
url: $FORMULA_REPO_URL
branch: $FORMULA_REPO_BRANCH
pinned: $FORMULA_REPO_PINNED
enabled: $FORMULA_REPO_ENABLED
created: $TIMESTAMP_UNIX
EOF

    run install -d        "$PPKG_FORMULA_REPO_ROOT"
    run mv "$SESSION_DIR" "$PPKG_FORMULA_REPO_ROOT/"
}

# }}}
##############################################################################
# {{{ ppkg formula-repo-init

# __create_a_formula_repository <REPO-NAME> <REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]
  __create_a_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "please specify a repository url."

    FORMULA_REPO_NAME="$1"

    if [ -z "$PPKG_URL_TRANSFORM" ] ; then
        FORMULA_REPO_URL="$2"
    else
        FORMULA_REPO_URL="$("$PPKG_URL_TRANSFORM" "$2")"
    fi

    shift 2

    FORMULA_REPO_BRANCH=
    FORMULA_REPO_PINNED=
    FORMULA_REPO_ENABLED=

    while [ -n "$1" ]
    do
        case $1 in
            --branch=*)
                FORMULA_REPO_BRANCH="${1#*=}"
                ;;
            --pin)
                FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                FORMULA_REPO_PINNED=0
                ;;
            --enable)
                FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    FORMULA_REPO_BRANCH="${FORMULA_REPO_BRANCH:-master}"
    FORMULA_REPO_PINNED="${FORMULA_REPO_PINNED:-1}"
    FORMULA_REPO_ENABLED="${FORMULA_REPO_ENABLED:-1}"

    FORMULA_REPO_PATH="$PPKG_FORMULA_REPO_ROOT/$FORMULA_REPO_NAME"

    if [ -d "$FORMULA_REPO_PATH" ] ; then
        abort 1 "$FORMULA_REPO_NAME named formula repository already exists."
    fi

    printf '%b\n' "${COLOR_PURPLE}==> Creating formula repository${COLOR_OFF} ${COLOR_GREEN}$FORMULA_REPO_NAME${COLOR_OFF}"

    SESSION_DIR="$PPKG_HOME/run/$$/$FORMULA_REPO_NAME"

    run rm -rf     "$SESSION_DIR"
    run install -d "$SESSION_DIR/formula"
    run cd         "$SESSION_DIR"

    run git -c init.defaultBranch=master init
    run git remote add origin "$FORMULA_REPO_URL"

    cat > .ppkg-formula-repo.yml <<EOF
url: $FORMULA_REPO_URL
branch: $FORMULA_REPO_BRANCH
pinned: $FORMULA_REPO_PINNED
enabled: $FORMULA_REPO_ENABLED
created: $TIMESTAMP_UNIX
EOF

    run install -d        "$PPKG_FORMULA_REPO_ROOT"
    run mv "$SESSION_DIR" "$PPKG_FORMULA_REPO_ROOT/"
}

# }}}
##############################################################################
# {{{ ppkg formula-repo-del

# __delete_a_formula_repository <REPO-NAME>
  __delete_a_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    [ "$1" = 'official-core' ] && abort 1 "'official-core' formula repository is not allowed to delete."

    if [ -d    "$PPKG_FORMULA_REPO_ROOT/$1" ] ; then
        rm -rf "$PPKG_FORMULA_REPO_ROOT/$1"
    else
        warn "'$1' named formula repository does not exist."
    fi
}

# }}}
##############################################################################
# {{{ ppkg formula-repo-sync

# __sync_the_given_formula_repository <REPO-NAME>
  __sync_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    __load_formula_repository_config "$1"

    [ "$FORMULA_REPO_PINNED" = 1 ] && abort 1 "'$FORMULA_REPO_NAME' named formula repository is pinned."

    if [ -z "$PPKG_URL_TRANSFORM" ] ; then
        GIT_FETCH_URL="$FORMULA_REPO_URL"
    else
        GIT_FETCH_URL="$("$PPKG_URL_TRANSFORM" "$FORMULA_REPO_URL")"
    fi

    printf '%b\n' "${COLOR_PURPLE}==> Updating formula repository${COLOR_OFF} ${COLOR_GREEN}$FORMULA_REPO_NAME${COLOR_OFF}"

    run cd "$FORMULA_REPO_PATH"
    run git remote set-url origin "$GIT_FETCH_URL"
    run git -c protocol.version=2 fetch --progress origin "+refs/heads/$FORMULA_REPO_BRANCH:refs/remotes/origin/$FORMULA_REPO_BRANCH"
    run git checkout --progress --force -B "$FORMULA_REPO_BRANCH" "refs/remotes/origin/$FORMULA_REPO_BRANCH"

    cat > .ppkg-formula-repo.yml <<EOF
url: $FORMULA_REPO_URL
branch: $FORMULA_REPO_BRANCH
pinned: $FORMULA_REPO_PINNED
enabled: $FORMULA_REPO_ENABLED
created: $FORMULA_REPO_TIMESTAMP_CREATED
updated: $TIMESTAMP_UNIX
EOF
}

# }}}
##############################################################################
# {{{ ppkg formula-repo-conf

# __conf_the_given_formula_repository <REPO-NAME> [--url=VALUE --branch=VALUE --pin/--unpin --enable/--disable]
  __conf_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "at least one option should be given. supported options are: --url=VALUE --branch=VALUE --pin/--unpin --enable/--disable"

    __load_formula_repository_config "$1"

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --url=*)
                FORMULA_REPO_URL="${1#*=}"

                if [ -z "$FORMULA_REPO_URL" ] ; then
                    abort 1 "--url=<VALUE> , <VALUE> should be non-empty."
                else
                    FORMULA_REPO_URL="$FORMULA_REPO_URL"
                fi
                ;;
            --branch=*)
                FORMULA_REPO_BRANCH="${1#*=}"

                if [ -z "$FORMULA_REPO_BRANCH" ] ; then
                    abort 1 "--branch=<VALUE> , <VALUE> should be non-empty."
                else
                    FORMULA_REPO_BRANCH="$FORMULA_REPO_BRANCH"
                fi
                ;;
            --pin)
                FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                FORMULA_REPO_PINNED=0
                ;;
            --enable)
                FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    if [ -z "$FORMULA_REPO_TIMESTAMP_UPDATED" ] ; then
        cat > "$FORMULA_REPO_PATH/.ppkg-formula-repo.yml" <<EOF
url:  $FORMULA_REPO_URL
branch: $FORMULA_REPO_BRANCH
pinned:  $FORMULA_REPO_PINNED
enabled: $FORMULA_REPO_ENABLED
created: $FORMULA_REPO_TIMESTAMP_CREATED
EOF
    else
        cat > "$FORMULA_REPO_PATH/.ppkg-formula-repo.yml" <<EOF
url:  $FORMULA_REPO_URL
branch: $FORMULA_REPO_BRANCH
pinned:  $FORMULA_REPO_PINNED
enabled: $FORMULA_REPO_ENABLED
created: $FORMULA_REPO_TIMESTAMP_CREATED
updated: $FORMULA_REPO_TIMESTAMP_UPDATED
EOF
fi
}

# }}}
##############################################################################
# {{{ ppkg formula-repo-info

# __info_the_given_formula_repository <REPO-NAME>
  __info_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    __load_formula_repository_config "$1"

    cat <<EOF
name: $FORMULA_REPO_NAME
path: $FORMULA_REPO_PATH
url:  $FORMULA_REPO_URL
branch: $FORMULA_REPO_BRANCH
pinned: $FORMULA_REPO_PINNED
enabled: $FORMULA_REPO_ENABLED
created: $(date -d "@$FORMULA_REPO_TIMESTAMP_CREATED" '+%Y-%m-%d %H:%M:%S%:z')
EOF

    if [ -n "$FORMULA_REPO_TIMESTAMP_UPDATED" ] ; then
        printf 'updated: %s\n' "$(date -d "@$FORMULA_REPO_TIMESTAMP_UPDATED" '+%Y-%m-%d %H:%M:%S%:z')"
    fi
}

# }}}
##############################################################################
# {{{ ppkg formula-repo-list

__list_available_formula_repositories() {
    [ -d "$PPKG_FORMULA_REPO_ROOT" ] || return 0

    I=0

    for item in $(cd "$PPKG_FORMULA_REPO_ROOT" && ls)
    do
        if [ -f "$PPKG_FORMULA_REPO_ROOT/$item/.ppkg-formula-repo.yml" ] ; then
            I="$(expr "$I" + 1)"

            [ "$I" -gt 1 ] && printf '\n'

            __info_the_given_formula_repository "$item"
        fi
    done
}

# }}}
##############################################################################
# {{{ ppkg update

__sync_available_formula_repositories() {
    [ -d "$PPKG_FORMULA_REPO_ROOT" ] && {
        for item in $(cd "$PPKG_FORMULA_REPO_ROOT" && ls)
        do
            if [ -f "$PPKG_FORMULA_REPO_ROOT/$item/.ppkg-formula-repo.yml" ] ; then
                __sync_the_given_formula_repository "$item"
            fi
        done
    }

    [ -d "$PPKG_FORMULA_REPO_ROOT/official-core" ] || {
        __create_a_formula_repository_then_sync_it official-core "$PPKG_OFFICIAL_FORMULA_REPO_URL"
    }
}

# __path_of_formula_of_the_given_package <PACKAGE-NAME>
  __path_of_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__path_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."

    [ -d "$PPKG_FORMULA_REPO_ROOT" ] || return 0

    AVAILABLE_FORMULA_REPOSITORY_NAMES=

    for item in $(cd "$PPKG_FORMULA_REPO_ROOT" && ls)
    do
        if [ -f "$PPKG_FORMULA_REPO_ROOT/$item/.ppkg-formula-repo.yml" ] ; then
            AVAILABLE_FORMULA_REPOSITORY_NAMES="$AVAILABLE_FORMULA_REPOSITORY_NAMES $item"
        fi
    done

    for FORMULA_REPOSITORY_NAME in $AVAILABLE_FORMULA_REPOSITORY_NAMES
    do
        if [ -e           "$PPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$TARGET_PLATFORM_NAME/$1.yml" ] ; then
            printf '%s\n' "$PPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$TARGET_PLATFORM_NAME/$1.yml"
            return 0
        fi

        if [ -e           "$PPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$1.yml" ] ; then
            printf '%s\n' "$PPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$1.yml"
            return 0
        fi
    done
}

# }}}
##############################################################################
# {{{ formula parse

filetype_from_url() {
    # remove query params
    URL="${1%%'?'*}"

    FNAME="${URL##*/}"

    case $FNAME in
        *.tar.gz|*.tgz)
            printf '%s\n' '.tgz'
            ;;
        *.tar.lz|*.tlz)
            printf '%s\n' '.tlz'
            ;;
        *.tar.xz|*.txz)
            printf '%s\n' '.txz'
            ;;
        *.tar.bz2|*.tbz2)
            printf '%s\n' '.tbz2'
            ;;
        *.*)printf '%s\n' ".${FNAME##*.}"
    esac
}

# __load_formula_of_the_given_package <PACKAGE-NAME> [FORMULA-FILEPATH]
  __load_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__load_formula_of_the_given_package <PACKAGE-NAME> [FORMULA-FILEPATH], <PACKAGE-NAME> is unspecified."

    unset PACKAGE_FORMULA_FILEPATH

    unset PACKAGE_FORMULA_LOADED

    unset PACKAGE_NAME
    unset PACKAGE_NAME_UPPERCASE_UNDERSCORE

    unset PACKAGE_SUMMARY
    unset PACKAGE_WEB_URL

    unset PACKAGE_GIT_URL
    unset PACKAGE_GIT_SHA
    unset PACKAGE_GIT_REF
    unset PACKAGE_GIT_NTH

    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_URI
    unset PACKAGE_SRC_SHA
    unset PACKAGE_SRC_FILENAME
    unset PACKAGE_SRC_FILETYPE
    unset PACKAGE_SRC_FILEPATH

    unset PACKAGE_FIX_URL
    unset PACKAGE_FIX_URI
    unset PACKAGE_FIX_SHA
    unset PACKAGE_FIX_FILENAME
    unset PACKAGE_FIX_FILETYPE
    unset PACKAGE_FIX_FILEPATH

    unset PACKAGE_RES_URL
    unset PACKAGE_RES_URI
    unset PACKAGE_RES_SHA
    unset PACKAGE_RES_FILENAME
    unset PACKAGE_RES_FILETYPE
    unset PACKAGE_RES_FILEPATH

    unset PACKAGE_VERSION
    unset PACKAGE_VERSION_MAJOR
    unset PACKAGE_VERSION_MINOR
    unset PACKAGE_VERSION_PATCH
    unset PACKAGE_VERSION_TWEAK

    unset PACKAGE_DEVELOPER

    unset PACKAGE_LICENSE

    unset PACKAGE_BSYSTEM

    unset PACKAGE_USE_BSYSTEM_GO
    unset PACKAGE_USE_BSYSTEM_RAKE
    unset PACKAGE_USE_BSYSTEM_NINJA
    unset PACKAGE_USE_BSYSTEM_GMAKE
    unset PACKAGE_USE_BSYSTEM_CMAKE
    unset PACKAGE_USE_BSYSTEM_XMAKE
    unset PACKAGE_USE_BSYSTEM_MESON
    unset PACKAGE_USE_BSYSTEM_CARGO
    unset PACKAGE_USE_BSYSTEM_AUTOGENSH
    unset PACKAGE_USE_BSYSTEM_AUTOTOOLS
    unset PACKAGE_USE_BSYSTEM_CONFIGURE

    # dir relative to $PACKAGE_WORKING_DIR/src, which contains build script such as autogen.sh, configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, xmake.lua, etc.
    unset PACKAGE_BSCRIPT

    # if build in build script dir, otherwise build in build dir
    unset PACKAGE_BINBSTD
    unset PACKAGE_BUILD_IN_BSCRIPT_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL
    unset PACKAGE_PARALLEL

    # space-separated    perl modules that are depended by this package when installing and/or runtime, which will be installed via cpan
    unset PACKAGE_DEP_PLM

    # space-separated python packages that are depended by this package when installing and/or runtime, which will be installed via pip3
    unset PACKAGE_DEP_PYM

    # space-separated   ppkg packages that are depended by this package when installing and/or runtime, which will be installed via uppm
    unset PACKAGE_DEP_UPP

    # space-separated   ppkg packages that are depended by this package when installing and/or runtime, which will be installed via ppkg
    unset PACKAGE_DEP_PKG

    unset PACKAGE_PPFLAGS
    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_ACTIONS_DO12345
    unset PACKAGE_ACTIONS_DOPATCH
    unset PACKAGE_ACTIONS_DOBUILD

    unset PACKAGE_SYMLINK

    # whether to support to create fully statically linked executables
    unset PACKAGE_SFSLINK

    #########################################################################################

    if [ -z "$2" ] ; then
        PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package "$1")"
    else
        PACKAGE_FORMULA_FILEPATH="$2"
    fi

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        abort 1 "package '$1' is not available."
    fi

    #########################################################################################

    PACKAGE_SUMMARY="$(yq '.summary | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_LICENSE="$(yq '.license | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_VERSION="$(yq '.version | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_WEB_URL="$(yq '.web-url | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_GIT_URL="$(yq '.git-url | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_GIT_SHA="$(yq '.git-sha | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_GIT_REF="$(yq '.git-ref | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_GIT_NTH="$(yq '.git-nth | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_SRC_URL="$(yq '.src-url | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_SRC_URI="$(yq '.src-uri | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_SRC_SHA="$(yq '.src-sha | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_FIX_URL="$(yq '.fix-url | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_FIX_URI="$(yq '.fix-uri | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_FIX_SHA="$(yq '.fix-sha | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_RES_URL="$(yq '.res-url | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_RES_URI="$(yq '.res-uri | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_RES_SHA="$(yq '.res-sha | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_DEP_PKG="$(yq '.dep-pkg | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_DEP_UPP="$(yq '.dep-upp | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_DEP_PYM="$(yq '.dep-pym | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_DEP_PLM="$(yq '.dep-plm | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_BSYSTEM="$(yq '.bsystem | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_BSCRIPT="$(yq '.bscript | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_BINBSTD="$(yq '.binbstd | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_CCFLAGS="$(yq '.ccflags | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_XXFLAGS="$(yq '.xxflags | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_PPFLAGS="$(yq '.ppflags | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_LDFLAGS="$(yq '.ldflags | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_SYMLINK="$(yq '.symlink | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_SFSLINK="$(yq '.sfslink | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_PARALLEL="$(yq '.parallel | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_DEVELOPER="$(yq '.developer | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_ACTIONS_DO12345="$(yq '.do12345 | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_ACTIONS_DOPATCH="$(yq '.dopatch | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"
    PACKAGE_ACTIONS_DOBUILD="$(yq '.install | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    #########################################################################################

    if [ -z "$PACKAGE_BSYSTEM" ] && [ -n "$PACKAGE_ACTIONS_DOBUILD" ] ; then
        for FirstWordOfLineInInstallActions in $(printf '%s\n' "$PACKAGE_ACTIONS_DOBUILD" | sed 's|^[[:space:]]*||' | cut -d ' ' -f1)
        do
            case "$FirstWordOfLineInInstallActions" in
                configure)    PACKAGE_BSYSTEM=configure ; break ;;
                cmakew)       PACKAGE_BSYSTEM=cmake ; break ;;
                xmakew)       PACKAGE_BSYSTEM=xmake ; break ;;
                mesonw)       PACKAGE_BSYSTEM=meson ; break ;;
                gmakew)       PACKAGE_BSYSTEM=gmake ; break ;;
                cargow)       PACKAGE_BSYSTEM=cargo ; break ;;
                go|gow)       PACKAGE_BSYSTEM=go    ; break ;;
            esac
        done
    fi

    #########################################################################################

    PACKAGE_NAME="$1"
    PACKAGE_NAME_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')

    if [ -n "$PACKAGE_GIT_NTH" ] ; then
        is_integer "$PACKAGE_GIT_NTH" || abort "the value of git-nth mapping should be an integer."
    fi

    if [ -z "$PACKAGE_BINBSTD" ] ; then
        PACKAGE_BINBSTD=0
        PACKAGE_BUILD_IN_BSCRIPT_DIR=0
    else
        PACKAGE_BUILD_IN_BSCRIPT_DIR=$PACKAGE_BINBSTD
    fi

    if [ -z "$PACKAGE_PARALLEL" ] ; then
        PACKAGE_PARALLEL=1
        PACKAGE_BUILD_IN_PARALLEL=1
    else
        PACKAGE_BUILD_IN_PARALLEL="$PACKAGE_PARALLEL"
    fi

    [ -z "$PACKAGE_SYMLINK" ] && PACKAGE_SYMLINK=1

    [ -z "$PACKAGE_SUMMARY" ] && abort 1 "summary mapping not found in $PACKAGE_FORMULA_FILEPATH"

    if [ -z "$PACKAGE_WEB_URL" ] && [ -z "$PACKAGE_GIT_URL" ] ; then
        abort 1 "neither web-url nor git-url mapping was found in $PACKAGE_FORMULA_FILEPATH"
    fi

    #########################################################################################

    unset PACKAGE_NEED_CURL
    unset PACKAGE_NEED_BTAR

    #########################################################################################

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        if [ -z "$PACKAGE_GIT_URL" ] ; then
            abort 1 "neither src-url nor git-url mapping was found in $PACKAGE_FORMULA_FILEPATH"
        fi

        PACKAGE_SRC_FILETYPE=.git

        if [ -z "$PACKAGE_VERSION" ] ; then
            PACKAGE_VERSION="$(date -u -d "@$TIMESTAMP_UNIX" '+%Y.%m.%d')"
        fi

        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP git"
    else
        case $PACKAGE_SRC_URL in
            dir://*)
                PACKAGE_SRC_FILETYPE=.dir
                PACKAGE_SRC_FILEPATH=$(printf '%s\n' "$PACKAGE_SRC_URL" | cut -c7-)

                if [ -z "$PACKAGE_VERSION" ] ; then
                    PACKAGE_VERSION="$(date -u -d "@$TIMESTAMP_UNIX" '+%Y.%m.%d')"
                fi
                ;;
            *)  PACKAGE_SRC_FILETYPE="$(filetype_from_url "$PACKAGE_SRC_URL")"
                PACKAGE_SRC_FILENAME="$PACKAGE_SRC_SHA$PACKAGE_SRC_FILETYPE"
                PACKAGE_SRC_FILEPATH="$PPKG_DOWNLOADS_DIR/$PACKAGE_SRC_FILENAME"

                if [ -z "$PACKAGE_SRC_SHA" ] ; then
                    abort 1 "src-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"
                fi

                if [ -z "$PACKAGE_VERSION" ] ; then
                    PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr '_@' - | sed -e 's|\.tar\.[glx]z$||' -e 's|\.tar\.bz2$||' -e 's|\.t[glx]z$||' -e 's|\.zip$||' -e 's|-stable||' -e 's|-source||' -e 's|[-.]src$||' -e 's|\.orig||' | awk -F- '{print $NF}')"
                    case $PACKAGE_VERSION in
                        '') abort 1 "version mapping not found in $PACKAGE_FORMULA_FILEPATH" ;;
                        v*) PACKAGE_VERSION=$(printf '%s\n' "$PACKAGE_VERSION" | cut -c2-)
                    esac
                fi

                PACKAGE_NEED_CURL=1

                case $PACKAGE_SRC_FILETYPE in
                    .zip|.txz|.tgz|.tlz|.tbz2|.crate)
                        PACKAGE_NEED_BTAR=1
                esac
        esac
    fi

    #########################################################################################

    [ -n "$PACKAGE_FIX_URL" ] && {
        [ -z "$PACKAGE_FIX_SHA" ] && abort 1 "fix-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"

        PACKAGE_FIX_FILETYPE="$(filetype_from_url "$PACKAGE_FIX_URL")"
        PACKAGE_FIX_FILENAME="$PACKAGE_FIX_SHA$PACKAGE_FIX_FILETYPE"
        PACKAGE_FIX_FILEPATH="$PPKG_DOWNLOADS_DIR/$PACKAGE_FIX_FILENAME"

        PACKAGE_NEED_CURL=1

        case $PACKAGE_SRC_FILETYPE in
            .zip|.txz|.tgz|.tlz|.tbz2|.crate)
                PACKAGE_NEED_BTAR=1
        esac
    }

    #########################################################################################

    [ -n "$PACKAGE_RES_URL" ] && {
        [ -z "$PACKAGE_RES_SHA" ] && abort 1 "res-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"

        PACKAGE_RES_FILETYPE="$(filetype_from_url "$PACKAGE_RES_URL")"
        PACKAGE_RES_FILENAME="$PACKAGE_RES_SHA$PACKAGE_RES_FILETYPE"
        PACKAGE_RES_FILEPATH="$PPKG_DOWNLOADS_DIR/$PACKAGE_RES_FILENAME"

        PACKAGE_NEED_CURL=1

        case $PACKAGE_SRC_FILETYPE in
            .zip|.txz|.tgz|.tlz|.tbz2|.crate)
                PACKAGE_NEED_BTAR=1
        esac
    }

    #########################################################################################

    [ "$PACKAGE_NEED_CURL" = 1 ] && PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl"
    [ "$PACKAGE_NEED_BTAR" = 1 ] && PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP bsdtar"

    #########################################################################################

    [ -n "$PACKAGE_VERSION" ] && {
        PACKAGE_VERSION_MAJOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f1)"
        PACKAGE_VERSION_MINOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f2)"
        PACKAGE_VERSION_PATCH="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f3)"
        PACKAGE_VERSION_TWEAK="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f4)"
    }

    #########################################################################################

    for item in $PACKAGE_BSYSTEM
    do
        case $item in
            autogen)     PACKAGE_USE_BSYSTEM_AUTOGENSH=1 ; PACKAGE_USE_BSYSTEM_GMAKE=1 ;;
            autotools)   PACKAGE_USE_BSYSTEM_AUTOTOOLS=1 ; PACKAGE_USE_BSYSTEM_GMAKE=1 ;;
            configure)   PACKAGE_USE_BSYSTEM_CONFIGURE=1 ; PACKAGE_USE_BSYSTEM_GMAKE=1 ;;
            cmake-gmake) PACKAGE_USE_BSYSTEM_CMAKE=1     ; PACKAGE_USE_BSYSTEM_GMAKE=1 ;;
            cmake-ninja) PACKAGE_USE_BSYSTEM_CMAKE=1     ; PACKAGE_USE_BSYSTEM_NINJA=1 ;;
            cmake)       PACKAGE_USE_BSYSTEM_CMAKE=1     ; PACKAGE_USE_BSYSTEM_NINJA=1 ;;
            xmake)       PACKAGE_USE_BSYSTEM_XMAKE=1     ;;
            meson)       PACKAGE_USE_BSYSTEM_MESON=1     ; PACKAGE_USE_BSYSTEM_NINJA=1 ;;
            ninja)       PACKAGE_USE_BSYSTEM_NINJA=1     ;;
            gmake)       PACKAGE_USE_BSYSTEM_GMAKE=1     ;;
            rake)        PACKAGE_USE_BSYSTEM_RAKE=1      ;;
            cargo)       PACKAGE_USE_BSYSTEM_CARGO=1     ;;
            go)          PACKAGE_USE_BSYSTEM_GO=1        ;;
        esac
    done

    #########################################################################################

    for item in $PACKAGE_BSYSTEM
    do
        case $item in
            autogen)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake gm4 perl autoconf automake" ;;
            autotools)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake gm4 perl autoconf automake" ;;
            configure)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"        ;;
            cmake-gmake) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake gmake"  ;;
            cmake-ninja) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            cmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            xmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP xmake"  ;;
            meson)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            ninja)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            gmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"  ;;
            rake)        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ruby"   ;;
            go)          PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP golang" ;;
        esac
    done

    #########################################################################################

    [ -z "$PACKAGE_ACTIONS_DOBUILD" ] && {
        case $PACKAGE_BSYSTEM in
            autogen)   PACKAGE_ACTIONS_DOBUILD='configure' ;;
            autotools) PACKAGE_ACTIONS_DOBUILD='configure' ;;
            configure) PACKAGE_ACTIONS_DOBUILD='configure' ;;
            cmake*)    PACKAGE_ACTIONS_DOBUILD='cmakew' ;;
            xmake)     PACKAGE_ACTIONS_DOBUILD='xmakew' ;;
            meson)     PACKAGE_ACTIONS_DOBUILD='mesonw' ;;
            ninja)     PACKAGE_ACTIONS_DOBUILD='ninjaw clean && ninjaw && ninjaw install' ;;
            gmake)     PACKAGE_ACTIONS_DOBUILD='gmakew clean && gmakew && gmakew install' ;;
            cargo)     PACKAGE_ACTIONS_DOBUILD='cargow install' ;;
            go)        PACKAGE_ACTIONS_DOBUILD='gow' ;;
            *)         abort 1 "install mapping not found in $PACKAGE_FORMULA_FILEPATH"
        esac
    }

    #########################################################################################

    [ "$PACKAGE_USE_BSYSTEM_MESON" = 1 ] && {
        PACKAGE_DEP_PYM="$PACKAGE_DEP_PYM meson"
    }

    [ -n "$PACKAGE_DEP_PYM" ] && {
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP python3"
    }

    [ -n "$PACKAGE_DEP_PLM" ] && {
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP perl gmake"
    }

    [ "$PACKAGE_BUILD_IN_PARALLEL" = 0 ] && {
        BUILD_NJOBS=1
    }

    [ "$PACKAGE_USE_BSYSTEM_GO" = 1 ] && {
        PACKAGE_BINBSTD=1
        PACKAGE_BUILD_IN_BSCRIPT_DIR=1
    }

    [ "$PACKAGE_USE_BSYSTEM_CARGO" = 1 ] && {
        PACKAGE_BINBSTD=1
        PACKAGE_BUILD_IN_BSCRIPT_DIR=1
    }

    [ "$PACKAGE_USE_BSYSTEM_XMAKE" = 1 ] && {
        PACKAGE_BINBSTD=1
        PACKAGE_BUILD_IN_BSCRIPT_DIR=1
    }

    PACKAGE_DEP_UPP="${PACKAGE_DEP_UPP#' '}"

    PACKAGE_FORMULA_LOADED=1
}

# }}}
##############################################################################
# {{{ ppkg is-available

# check if the given package is available
# if the version condition is given, check if the condition is matched
#
# condition operator:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available automake eq 1.16.0
# is_package_available automake lt 1.16.0
# is_package_available automake gt 1.16.0
# is_package_available automake le 1.16.0
# is_package_available automake ge 1.16.0
# is_package_available automake
  is_package_available() {
    [ -z "$1" ] && abort 1 "is_package_available <PACKAGE-NAME> [<eq|lt|gt|le|ge> <VERSION>], <PACKAGE-NAME> is unspecified."

    case $# in
        1)  [ -n "$(__path_of_formula_of_the_given_package "$1" || true)" ] ;;
        3)  __load_formula_of_the_given_package "$1" || return 1
            shift
            version_match "$PACKAGE_VERSION" "$@"
            ;;
        *)  abort 1 "is available command only accept 1 or 3 argument."
    esac
}

# }}}
##############################################################################
# {{{ ppkg is-installed

# is_package_installed <PACKAGE-SPEC>
  is_package_installed() {
    [ -z "$1" ] && abort 1 "is_package_installed <PACKAGE-SPEC>, <PACKAGE-SPEC> is unspecified."

    [ -d "$PPKG_PACKAGE_INSTALLED_ROOT/$1" ]                    || return 10
    [ -d "$PPKG_PACKAGE_INSTALLED_ROOT/$1/.ppkg" ]              || return 11
    [ -f "$PPKG_PACKAGE_INSTALLED_ROOT/$1/.ppkg/MANIFEST.txt" ] || return 13
    [ -f "$PPKG_PACKAGE_INSTALLED_ROOT/$1/.ppkg/RECEIPT.yml" ]  || return 14
}

# }}}
##############################################################################
# {{{ ppkg is-symlinked

# is_package_symlinked <PACKAGE-SPEC>
  is_package_symlinked() {
    is_package_installed "$1" && [ -f "$PPKG_PACKAGE_SYMLINKED_ROOT/.registry/$1" ]
}

# }}}
##############################################################################
# {{{ ppkg is-outdated

# is_package__outdated <PACKAGE-SPEC>
  is_package__outdated() {
    __load_formula_of_the_given_package "${1##*/}"
    __load_receipt_of_the_given_package "$1"
    version_match "$PACKAGE_VERSION" gt "$RECEIPT_PACKAGE_VERSION"
}

# }}}
##############################################################################
# {{{ ppkg ls-available

__list_available_packages() {
    [ -d "$PPKG_FORMULA_REPO_ROOT" ] || return 0

    {
        AVAILABLE_FORMULA_REPOSITORY_NAMES=

        for item in $(cd "$PPKG_FORMULA_REPO_ROOT" && ls)
        do
            if [ -f "$PPKG_FORMULA_REPO_ROOT/$item/.ppkg-formula-repo.yml" ] ; then
                AVAILABLE_FORMULA_REPOSITORY_NAMES="$AVAILABLE_FORMULA_REPOSITORY_NAMES $item"
            fi
        done

        for FORMULA_REPOSITORY_NAME in $AVAILABLE_FORMULA_REPOSITORY_NAMES
        do
            FORMULA_SEARCH_DIR="$PPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$NATIVE_OS_TYPE"

            if [ -d "$FORMULA_SEARCH_DIR" ] ; then
                find "$FORMULA_SEARCH_DIR" -maxdepth 1 -type f -name '*.yml' -exec basename {} .yml \; || return 1
            fi

            FORMULA_SEARCH_DIR="$PPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula"

            if [ -d "$FORMULA_SEARCH_DIR" ] ; then
                find "$FORMULA_SEARCH_DIR" -maxdepth 1 -type f -name '*.yml' -exec basename {} .yml \; || return 1
            fi
        done
    } | sort | uniq
}

# }}}
##############################################################################
# {{{ ppkg ls-installed

__list_installed_packages() {
    if [  -d "$PPKG_PACKAGE_INSTALLED_ROOT" ] ; then
        find "$PPKG_PACKAGE_INSTALLED_ROOT" -maxdepth 2 -mindepth 2 -type l -printf '%P\n'
    else
        return 0
    fi
}

# }}}
##############################################################################
# {{{ ppkg ls-symlinked

__list_symlinked_packages() {
    if [ -d "$PPKG_PACKAGE_SYMLINKED_ROOT/.registry" ] ; then
         cd "$PPKG_PACKAGE_SYMLINKED_ROOT/.registry" || return 1
    else
        return 0
    fi

    ls -1
}

# }}}
##############################################################################
# {{{ ppkg ls-outdated

__list__outdated_packages() {
    [ -d "$PPKG_PACKAGE_INSTALLED_ROOT" ] || return 0

    for pkg in $(find "$PPKG_PACKAGE_INSTALLED_ROOT" -maxdepth 2 -mindepth 2 -type l -printf '%P\n')
    do
        if is_package__outdated "$pkg" ; then
            printf '%s\n' "$pkg"
        fi
    done
}

# }}}
##############################################################################
# {{{ ppkg search

__search_packages() {
    [ -z "$1" ] && abort 1 "please specify a regular express partten."

    __list_available_packages | grep "$1"
}

# }}}
##############################################################################
# {{{ ppkg info

# __info_all_available_packages [--json|--yaml|--shell]
  __info_all_available_packages() {
    case $1 in
        --json) __info_all_available_packages_as_json ;;
        --yaml) __info_all_available_packages_as_yaml ;;
        --shell)__info_all_available_packages_as_shell ;;
        '')     __info_all_available_packages_as_mixed ;;
        *)    abort 1 "__info_all_available_packages [--json|--yaml|--shell], unrecognized option: $1"
    esac
}

__info_all_available_packages_as_mixed() {
    FIRST=1

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = 1 ] ; then
            FIRST=0
        else
            printf '%s\n' '---'
        fi
        __info_the_given_available_package "$PACKAGE"
    done
}

__info_all_available_packages_as_json() {
    printf '%s\n' '['

    FIRST=1

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = 1 ] ; then
            FIRST=0
        else
            printf '%s\n' ','
        fi
        __info_the_given_available_package_as_json "$PACKAGE"
    done

    printf '%s\n' ']'
}

__info_all_available_packages_as_yaml() {
    FIRST=1

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = 1 ] ; then
            FIRST=0
        else
            printf '%s\n' '---'
        fi
        __info_the_given_available_package_as_yaml "$PACKAGE"
    done
}

__info_all_available_packages_as_shell() {
    FIRST=1

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = 1 ] ; then
            FIRST=0
        else
            printf '%s\n' '#---'
        fi
        __info_the_given_available_package_as_shell "$PACKAGE"
    done
}

# __info_the_given_available_package_as_json <PACKAGE-NAME>
  __info_the_given_available_package_as_json() {
    __load_formula_of_the_given_package "$1"

    if [ -z "$PACKAGE_WEB_URL" ] ; then
        PACKAGE_WEB_URL="$PACKAGE_GIT_URL"
    fi

    jq  --null-input \
        --arg pkgname "$PACKAGE_NAME" \
        --arg version "$PACKAGE_VERSION" \
        --arg summary "$PACKAGE_SUMMARY" \
        --arg license "$PACKAGE_LICENSE" \
        --arg web_url "$PACKAGE_WEB_URL" \
        --arg git_url "$PACKAGE_GIT_URL" \
        --arg git_sha "$PACKAGE_GIT_SHA" \
        --arg git_ref "$PACKAGE_GIT_REF" \
        --arg git_nth "$PACKAGE_GIT_NTH" \
        --arg src_url "$PACKAGE_SRC_URL" \
        --arg src_uri "$PACKAGE_SRC_URI" \
        --arg src_sha "$PACKAGE_SRC_SHA" \
        --arg fix_url "$PACKAGE_FIX_URL" \
        --arg fix_uri "$PACKAGE_FIX_URI" \
        --arg fix_sha "$PACKAGE_FIX_SHA" \
        --arg res_url "$PACKAGE_RES_URL" \
        --arg res_uri "$PACKAGE_RES_URI" \
        --arg res_sha "$PACKAGE_RES_SHA" \
        --arg dep_pkg "$PACKAGE_DEP_PKG" \
        --arg dep_upp "$PACKAGE_DEP_UPP" \
        --arg dep_pym "$PACKAGE_DEP_PYM" \
        --arg dep_plm "$PACKAGE_DEP_PLM" \
        --arg dopatch "$PACKAGE_ACTIONS_DOPATCH" \
        --arg install "$PACKAGE_ACTIONS_DOBUILD" \
        --arg bsystem "$PACKAGE_BSYSTEM" \
        --arg binbstd "$PACKAGE_BINBSTD" \
        --arg ccflags "$PACKAGE_CCFLAGS" \
        --arg xxflags "$PACKAGE_XXFLAGS" \
        --arg ppflags "$PACKAGE_PPFLAGS" \
        --arg ldflags "$PACKAGE_LDFLAGS" \
        --arg parallel $PACKAGE_BUILD_IN_PARALLEL \
'{
    "pkgname":$pkgname,
    "version":$version,
    "license":$license,
    "summary":$summary,
    "web-url":$web_url,
    "git-url":$git_url,
    "git-sha":$git_sha,
    "git-ref":$git_ref,
    "git-nth":$git_nth,
    "src-url":$src_url,
    "src-uri":$src_uri,
    "src-sha":$src_sha,
    "fix-url":$fix_url,
    "fix-uri":$fix_uri,
    "fix-sha":$fix_sha,
    "res-url":$res_url,
    "res-uri":$res_uri,
    "res-sha":$res_sha,
    "dep-pkg":$dep_pkg,
    "dep-upp":$dep_upp,
    "dep-pym":$dep_pym,
    "dep-plm":$dep_plm,
    "bsystem":$bsystem,
    "binbstd":$binbstd,
    "ccflags":$ccflags,
    "xxflags":$xxflags,
    "ppflags":$ppflags,
    "ldflags":$ldflags,
    "parallel":$parallel,
    "dopatch":$dopatch,
    "install":$install
}' | jq 'with_entries(select(.value != ""))'
}

# __info_the_given_available_package_as_yaml <PACKAGE-NAME>
  __info_the_given_available_package_as_yaml() {
    __load_formula_of_the_given_package "$1"

    if [ -z "$PACKAGE_WEB_URL" ] ; then
        PACKAGE_WEB_URL="$PACKAGE_GIT_URL"
    fi

    {
    cat <<EOF
pkgname: $PACKAGE_NAME
version: $PACKAGE_VERSION
license: $PACKAGE_LICENSE
summary: $PACKAGE_SUMMARY
web-url: $PACKAGE_WEB_URL
git-url: $PACKAGE_GIT_URL
git-sha: $PACKAGE_GIT_SHA
git-ref: $PACKAGE_GIT_REF
git-nth: $PACKAGE_GIT_NTH
src-url: $PACKAGE_SRC_URL
src-uri: $PACKAGE_SRC_URI
src-sha: $PACKAGE_SRC_SHA
fix-url: $PACKAGE_FIX_URL
fix-uri: $PACKAGE_FIX_URI
fix-sha: $PACKAGE_FIX_SHA
res-url: $PACKAGE_RES_URL
res-uri: $PACKAGE_RES_URI
res-sha: $PACKAGE_RES_SHA
dep-pkg: $PACKAGE_DEP_PKG
dep-upp: $PACKAGE_DEP_UPP
dep-pym: $PACKAGE_DEP_PYM
dep-plm: $PACKAGE_DEP_PLM
bsystem: $PACKAGE_BSYSTEM
binbstd: $PACKAGE_BINBSTD
ppflags: $PACKAGE_PPFLAGS
ccflags: $PACKAGE_CCFLAGS
xxflags: $PACKAGE_XXFLAGS
ldflags: $PACKAGE_LDFLAGS
parallel: $PACKAGE_BUILD_IN_PARALLEL
EOF
    } | yq eval '. | with_entries(select(.value != null))'

    if is_package_installed "$1" ; then
        yq eval --null-input '.installed = "yes"'
    else
        yq eval --null-input '.installed = "no"'
    fi
}

# __info_the_given_available_package_as_shell <PACKAGE-NAME>
  __info_the_given_available_package_as_shell() {
    __load_formula_of_the_given_package "$1"

    while read KEY
    do
        printf "%s='%s'\n" "${PACKAGE_NAME_UPPERCASE_UNDERSCORE}_${KEY}" "$(eval echo \$$KEY)"
    done <<EOF
PACKAGE_NAME
PACKAGE_SUMMARY
PACKAGE_LICENSE
PACKAGE_VERSION
PACKAGE_VERSION_MAJOR
PACKAGE_VERSION_MINOR
PACKAGE_VERSION_PATCH
PACKAGE_VERSION_TWEAK
PACKAGE_WEB_URL
PACKAGE_GIT_URL
PACKAGE_GIT_SHA
PACKAGE_GIT_REF
PACKAGE_GIT_NTH
PACKAGE_SRC_URL
PACKAGE_SRC_URI
PACKAGE_SRC_SHA
PACKAGE_SRC_FILETYPE
PACKAGE_SRC_FILENAME
PACKAGE_SRC_FILEPATH
PACKAGE_FIX_URL
PACKAGE_FIX_URI
PACKAGE_FIX_SHA
PACKAGE_FIX_FILETYPE
PACKAGE_FIX_FILENAME
PACKAGE_FIX_FILEPATH
PACKAGE_RES_URL
PACKAGE_RES_URI
PACKAGE_RES_SHA
PACKAGE_RES_FILETYPE
PACKAGE_RES_FILENAME
PACKAGE_RES_FILEPATH
PACKAGE_BSCRIPT
PACKAGE_BSYSTEM
PACKAGE_BINBSTD
PACKAGE_USE_BSYSTEM_GO
PACKAGE_USE_BSYSTEM_RAKE
PACKAGE_USE_BSYSTEM_NINJA
PACKAGE_USE_BSYSTEM_GMAKE
PACKAGE_USE_BSYSTEM_CMAKE
PACKAGE_USE_BSYSTEM_XMAKE
PACKAGE_USE_BSYSTEM_MESON
PACKAGE_USE_BSYSTEM_CARGO
PACKAGE_USE_BSYSTEM_AUTOGENSH
PACKAGE_USE_BSYSTEM_AUTOTOOLS
PACKAGE_USE_BSYSTEM_CONFIGURE
PACKAGE_BUILD_IN_BSCRIPT_DIR
PACKAGE_BUILD_IN_PARALLEL
PACKAGE_DEP_PKG
PACKAGE_DEP_UPP
PACKAGE_DEP_PYM
PACKAGE_DEP_PLM
PACKAGE_CCFLAGS
PACKAGE_XXFLAGS
PACKAGE_PPFLAGS
PACKAGE_LDFLAGS
PACKAGE_FORMULA_FILEPATH
PACKAGE_DEVELOPER
EOF
}

# __info_the_given_available_package <PACKAGE-NAME> [--yaml] [--json] [<KEY>]
# __info_the_given_available_package curl
# __info_the_given_available_package curl version
# __info_the_given_available_package curl web-url
  __info_the_given_available_package() {
    case $2 in
        '') __info_the_given_available_package_as_yaml "$1"
            ;;
        --yaml)
            __info_the_given_available_package_as_yaml "$1"
            ;;
        --json)
            __info_the_given_available_package_as_json "$1"
            ;;
        dopatch)
            __load_formula_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_ACTIONS_DOPATCH"
            ;;
        install)
            __load_formula_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_ACTIONS_DOBUILD"
            ;;
        developer)
            __load_formula_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_DEVELOPER"
            ;;
        src-ft)
            __load_formula_of_the_given_package "$1"
            if [ -n "$PACKAGE_SRC_FILETYPE" ] ; then
                printf '%s\n' "$PACKAGE_SRC_FILETYPE"
            fi
            ;;
        src-fp)
            __load_formula_of_the_given_package "$1"
            if [ -n "$PACKAGE_SRC_FILEPATH" ] ; then
                printf '%s\n' "$PACKAGE_SRC_FILEPATH"
            fi
            ;;
        fix-ft)
            __load_formula_of_the_given_package "$1"
            if [ -n "$PACKAGE_FIX_FILETYPE" ] ; then
                printf '%s\n' "$PACKAGE_FIX_FILETYPE"
            fi
            ;;
        fix-fp)
            __load_formula_of_the_given_package "$1"
            if [ -n "$PACKAGE_FIX_FILEPATH" ] ; then
                printf '%s\n' "$PACKAGE_FIX_FILEPATH"
            fi
            ;;
        res-ft)
            __load_formula_of_the_given_package "$1"
            if [ -n "$PACKAGE_RES_FILETYPE" ] ; then
                printf '%s\n' "$PACKAGE_RES_FILETYPE"
            fi
            ;;
        res-fp)
            __load_formula_of_the_given_package "$1"
            if [ -n "$PACKAGE_RES_FILEPATH" ] ; then
                printf '%s\n' "$PACKAGE_RES_FILEPATH"
            fi
            ;;
        *)  __load_formula_of_the_given_package "$1"
            __PACKAGE_GET__KEY__="$(printf '%s\n' "$2" | tr '+-.' '_' | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_GET__KEY__
    esac
}

# __info_the_given_installed_package <PACKAGE-SPEC> [<KEY>]
# __info_the_given_installed_package curl
# __info_the_given_installed_package curl version
# __info_the_given_installed_package curl web-url
  __info_the_given_installed_package() {
    case $2 in
        installed-dir)
            PACKAGE_SPEC=
            PACKAGE_SPEC="$(inspect_package_spec "$1")"

            if is_package_installed "$PACKAGE_SPEC" ; then
                PACKAGE_INSTALLED_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
                printf '%s\n' "$PACKAGE_INSTALLED_DIR"
            else
                abort 1 "package '$PACKAGE_SPEC' is not installed."
            fi
            ;;
        installed-files)
            PACKAGE_SPEC=
            PACKAGE_SPEC="$(inspect_package_spec "$1")"

            if is_package_installed "$PACKAGE_SPEC" ; then
                cut -d '|' -f3 "$PPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC/.ppkg/MANIFEST.txt"
            else
                abort 1 "package '$PACKAGE_SPEC' is not installed."
            fi
            ;;
        builtat)
            __load_receipt_of_the_given_package "$1"
            printf '%s\n' "$RECEIPT_PACKAGE_BUILTAT"
            ;;
        builtat-rfc-3339)
            __load_receipt_of_the_given_package "$1"
            date -d "@$RECEIPT_PACKAGE_BUILTAT" '+%Y-%m-%d %H:%M:%S%:z'
            ;;
        builtat-iso-8601)
            __load_receipt_of_the_given_package "$1"
            date -d "@$RECEIPT_PACKAGE_BUILTAT" '+%Y-%m-%dT%H:%M:%S%:z'
            ;;
        builtat-rfc-3339-utc)
            __load_receipt_of_the_given_package "$1"
            date -u -d "@$RECEIPT_PACKAGE_BUILTAT" '+%Y-%m-%d %H:%M:%S%:z'
            ;;
        builtat-iso-8601-utc)
            __load_receipt_of_the_given_package "$1"
            date -u -d "@$RECEIPT_PACKAGE_BUILTAT" '+%Y-%m-%dT%H:%M:%SZ'
            ;;
        *)  __load_receipt_of_the_given_package "$1"
            __PACKAGE_GET__KEY__="$(printf '%s\n' "$2" | tr '+-.' '_' | tr a-z A-Z)"
            eval echo \$RECEIPT_PACKAGE_$__PACKAGE_GET__KEY__
    esac
}

# }}}
##############################################################################
# {{{ ppkg depends

# __show_packages_depended_by_the_given_package <PACKAGE-NAME> [-t <dot|box|svg|png>] [-o <OUTPUT-PATH>]
__show_packages_depended_by_the_given_package() {
    [ -z "$1" ] && abort 1 "_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], <PACKAGE-NAME> is unspecified."

    PACKAGE_NAME="$1"

    shift

    ###########################################################################################

    unset OUTPUT_TYPE
    unset OUTPUT_PATH

    while [ -n "$1" ]
    do
        case $1 in
            -t) shift
                case $1 in
                    dot|box|svg|png)
                        OUTPUT_TYPE="$1" ;;
                    '') abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -t option is given but <OUTPUT-TYPE> is unspecified." ;;
                    *)  abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>], unsupported <OUTPUT-TYPE>: $1, <OUTPUT-TYPE> should be one of dot|box|svg|png"
                esac
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -o option is given but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_PATH="$1"
                fi
                ;;
            *)  abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>] [--keep-session-dir], unrecognized option: $1"
        esac
        shift
    done

    ###########################################################################################

    unset OUTPUT_DIR
    unset OUTPUT_FILEPATH

    case $OUTPUT_PATH in
        '')
            if [ -z "$OUTPUT_TYPE" ] ; then
                OUTPUT_TYPE='box'
            fi
            ;;
        ..|../)
            if [ -z "$OUTPUT_TYPE" ] ; then
                OUTPUT_TYPE='box'
            fi

            OUTPUT_FILEPATH="$PWD/../$PACKAGE_NAME-dependencies.$OUTPUT_TYPE"
            ;;
        .|./)
            if [ -z "$OUTPUT_TYPE" ] ; then
                OUTPUT_TYPE='box'
            fi

            OUTPUT_FILEPATH="$PWD/$PACKAGE_NAME-dependencies.$OUTPUT_TYPE"
            ;;
        */)
            if [ -z "$OUTPUT_TYPE" ] ; then
                OUTPUT_TYPE='box'
            fi

            case $OUTPUT_PATH in
                /*) OUTPUT_DIR="$OUTPUT_PATH" ;;
                *)  OUTPUT_DIR="$PWD/$OUTPUT_PATH"
            esac

            OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKAGE_NAME-dependencies.$OUTPUT_TYPE"
            ;;
        *)
            if [ -z "$OUTPUT_TYPE" ] ; then
                case $OUTPUT_PATH in
                    *.box)
                        OUTPUT_TYPE='box'
                        ;;
                    *.dot)
                        OUTPUT_TYPE='dot'
                        ;;
                    *.svg)
                        OUTPUT_TYPE='svg'
                        ;;
                    *.png)
                        OUTPUT_TYPE='png'
                        ;;
                    *)  OUTPUT_TYPE='box'
                esac
            fi

            case $OUTPUT_PATH in
                /*) OUTPUT_DIR="${OUTPUT_PATH%/*}"
                    OUTPUT_FILEPATH="$OUTPUT_PATH"
                    ;;
                *)  OUTPUT_DIR="$PWD/$(dirname "$OUTPUT_PATH")"
                    OUTPUT_FILEPATH="$PWD/$OUTPUT_PATH"
            esac
    esac

    ###########################################################################################

    unset DOT_CONTENT

    unset DIRECTED_PATH_LIST

    STACK="$PACKAGE_NAME"

    while [ -n "$STACK" ]
    do
        case $STACK in
            *\;*) PACKAGE_NAME="${STACK##*;}" ; STACK="${STACK%;*}" ;;
            *)    PACKAGE_NAME="${STACK}"     ; STACK=
        esac

        ################################################################

        __load_formula_of_the_given_package "$PACKAGE_NAME"

        ################################################################

        [ -z "$PACKAGE_DEP_PKG" ] && continue

        ################################################################

        unset X; X="$(printf '"%s" ' $PACKAGE_DEP_PKG)"
        unset Y; Y="$(printf '    "%s" -> { %s}\n' "$PACKAGE_NAME" "$X")"

        if [ -z "$DOT_CONTENT" ] ; then
            DOT_CONTENT="$Y"
        else
            DOT_CONTENT="$(printf '%s\n%s\n' "$DOT_CONTENT" "$Y")"
        fi

        ################################################################

        DIRECTED_PATH_LIST_PART1=
        DIRECTED_PATH_LIST_PART2=

        for DIRECTED_PATH in $DIRECTED_PATH_LIST
        do
            case $DIRECTED_PATH in
                *\>"$PACKAGE_NAME")
                    DIRECTED_PATH_LIST_PART1="$DIRECTED_PATH_LIST_PART1 $DIRECTED_PATH" ;;
                *)  DIRECTED_PATH_LIST_PART2="$DIRECTED_PATH_LIST_PART2 $DIRECTED_PATH" ;;
            esac
        done

        ################################################################

        # it will be recalculated
        DIRECTED_PATH_LIST=

        ################################################################

        for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
        do
            if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                abort 1 "package [$PACKAGE_NAME] depends itself."
            fi

            ############################################################

            if [ -z "$DIRECTED_PATH_LIST_PART1" ] ; then
                DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $PACKAGE_NAME>$DEPENDENT_PACKAGE_NAME"
            else
                for DIRECTED_PATH in $DIRECTED_PATH_LIST_PART1
                do
                    export IFS='>'

                    # check if have duplicate nodes in every directed path
                    for node in $DIRECTED_PATH
                    do
                        if [ "$node" = "$DEPENDENT_PACKAGE_NAME" ] ; then
                            abort 1 "depends has circle: $DIRECTED_PATH>$DEPENDENT_PACKAGE_NAME"
                        fi
                    done

                    unset IFS

                    DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $DIRECTED_PATH>$DEPENDENT_PACKAGE_NAME"
                done
            fi

            ############################################################

            if [ -z "$STACK" ] ; then
                STACK="$DEPENDENT_PACKAGE_NAME"
            else
                STACK="$STACK;$DEPENDENT_PACKAGE_NAME"
            fi
        done

        DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $DIRECTED_PATH_LIST_PART2"
    done

    ###########################################################################################

    [ -z "$DOT_CONTENT" ] && return 0

    DOT_CONTENT="digraph G {
$DOT_CONTENT
}"

    ###########################################################################################

    case $OUTPUT_TYPE in
        dot)
            if [ -z "$OUTPUT_FILEPATH" ] ; then
                printf '%s\n' "$DOT_CONTENT"
            else
                SESSION_DIR="$PPKG_HOME/run/$$"

                rm -rf     "$SESSION_DIR"
                install -d "$SESSION_DIR"
                cd         "$SESSION_DIR"

                printf '%s\n' "$DOT_CONTENT" > dependencies.dot

                if [ -n "$OUTPUT_DIR" ] && [ ! -d "$OUTPUT_DIR" ] ; then
                    install -d "$OUTPUT_DIR"
                fi

                mv dependencies.dot "$OUTPUT_FILEPATH"

                rm -rf "$SESSION_DIR"
            fi
            ;;
        box)
            if [ -z "$OUTPUT_FILEPATH" ] ; then
                # https://github.com/ggerganov/dot-to-ascii
                curl \
                    -s \
                    -G \
                    --data-urlencode "boxart=1" \
                    --data-urlencode "src=$DOT_CONTENT" \
                    'https://dot-to-ascii.ggerganov.com/dot-to-ascii.php'
            else
                SESSION_DIR="$PPKG_HOME/run/$$"

                rm -rf     "$SESSION_DIR"
                install -d "$SESSION_DIR"
                cd         "$SESSION_DIR"

                # https://github.com/ggerganov/dot-to-ascii
                curl \
                    -s \
                    -G \
                    -o dependencies.box \
                    --data-urlencode "boxart=1" \
                    --data-urlencode "src=$DOT_CONTENT" \
                    'https://dot-to-ascii.ggerganov.com/dot-to-ascii.php'

                if [ -n "$OUTPUT_DIR" ] && [ ! -d "$OUTPUT_DIR" ] ; then
                    install -d "$OUTPUT_DIR"
                fi

                mv dependencies.box "$OUTPUT_FILEPATH"

                rm -rf "$SESSION_DIR"
            fi
            ;;
        svg)
            SESSION_DIR="$PPKG_HOME/run/$$"

            rm -rf     "$SESSION_DIR"
            install -d "$SESSION_DIR"
            cd         "$SESSION_DIR"

            printf '%s\n' "$DOT_CONTENT" > dependencies.dot

            if [ -z "$OUTPUT_FILEPATH" ] ; then
                dot -Tsvg dependencies.dot
            else
                dot -Tsvg -o dependencies.svg dependencies.dot

                if [ -n "$OUTPUT_DIR" ] && [ ! -d "$OUTPUT_DIR" ] ; then
                    install -d "$OUTPUT_DIR"
                fi

                mv dependencies.svg "$OUTPUT_FILEPATH"
            fi

            rm -rf "$SESSION_DIR"
            ;;
        png)
            SESSION_DIR="$PPKG_HOME/run/$$"

            rm -rf     "$SESSION_DIR"
            install -d "$SESSION_DIR"
            cd         "$SESSION_DIR"

            printf '%s\n' "$DOT_CONTENT" > dependencies.dot

            if [ -z "$OUTPUT_FILEPATH" ] ; then
                dot -Tpng dependencies.dot
            else
                dot -Tpng -o dependencies.png dependencies.dot

                if [ -n "$OUTPUT_DIR" ] && [ ! -d "$OUTPUT_DIR" ] ; then
                    install -d "$OUTPUT_DIR"
                fi

                mv dependencies.png "$OUTPUT_FILEPATH"
            fi

            rm -rf "$SESSION_DIR"
    esac
}

# }}}
##############################################################################
# {{{ ppkg fetch

__fetch_resources_of_the_given_package() {
    if [ -z "$1" ] ; then
        abort 1 "__fetch_resources_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
    fi

    __load_formula_of_the_given_package "$1"

    if [ "$PACKAGE_SRC_FILETYPE" = '.dir' ] ; then
        note "$PACKAGE_SRC_URL is local path, no need to fetch."
        return 0
    fi

    SESSION_DIR="$PPKG_HOME/run/$$"

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        unset GIT_FETCH_URL

        if [ -z "$PPKG_URL_TRANSFORM" ] ; then
            GIT_FETCH_URL="$PACKAGE_GIT_URL"
        else
            GIT_FETCH_URL="$("$PPKG_URL_TRANSFORM" "$PACKAGE_GIT_URL")" || return 1
        fi

        if [ -z "$PACKAGE_GIT_SHA" ] ; then
            if [ -z "$PACKAGE_GIT_REF" ] ; then
                GIT_BRANCH_NAME=master
                GIT_REF_SPEC="+HEAD:refs/remotes/origin/master"
            else
                GIT_BRANCH_NAME="$(basename "$PACKAGE_GIT_REF")"
                GIT_REF_SPEC="+$PACKAGE_GIT_REF:refs/remotes/origin/$GIT_BRANCH_NAME"
            fi
        else
            GIT_BRANCH_NAME=master
            GIT_REF_SPEC="+$PACKAGE_GIT_SHA:refs/remotes/origin/master"
        fi

        if [ -z "$PACKAGE_GIT_NTH" ] ; then
            PACKAGE_GIT_NTH=1
        fi

        if [ "$PACKAGE_GIT_NTH" -eq 0 ] ; then
            if [ -f "$PACKAGE_SRC_FILEPATH/.git/shallow" ] ; then
                GIT_FETCH_EXTRA_OPTIONS='--unshallow'
            else
                GIT_FETCH_EXTRA_OPTIONS=
            fi
        else
            GIT_FETCH_EXTRA_OPTIONS="--depth=$PACKAGE_GIT_NTH"
        fi

        run rm -rf     "$SESSION_DIR"
        run install -d "$SESSION_DIR"
        run cd         "$SESSION_DIR"
        run git -c init.defaultBranch=master init
        run git remote add origin "$GIT_FETCH_URL"
        run git -c protocol.version=2 fetch --progress $GIT_FETCH_EXTRA_OPTIONS origin "$GIT_REF_SPEC"
        run git checkout --progress --force -B "$GIT_BRANCH_NAME" "refs/remotes/origin/$GIT_BRANCH_NAME"
        run git submodule update --init
    else
        wfetch "$PACKAGE_SRC_URL" --uri="$PACKAGE_SRC_URI" --sha256="$PACKAGE_SRC_SHA" -o "$PACKAGE_SRC_FILEPATH"
    fi

    if [ -n    "$PACKAGE_FIX_URL" ] ; then
        wfetch "$PACKAGE_FIX_URL" --uri="$PACKAGE_FIX_URI" --sha256="$PACKAGE_FIX_SHA" -o "$PACKAGE_FIX_FILEPATH"
    fi

    if [ -n    "$PACKAGE_RES_URL" ] ; then
        wfetch "$PACKAGE_RES_URL" --uri="$PACKAGE_RES_URI" --sha256="$PACKAGE_RES_SHA" -o "$PACKAGE_RES_FILEPATH"
    fi

    if [    -d "$SESSION_DIR" ] ; then
        rm -rf "$SESSION_DIR"
    fi
}

# }}}
##############################################################################
# {{{ ppkg tree

# __tree_the_given_installed_package <PACKAGE-SPEC>
  __tree_the_given_installed_package() {
    PACKAGE_SPEC=
    PACKAGE_SPEC="$(inspect_package_spec "$1")"

    if is_package_installed "$PACKAGE_SPEC" ; then
        PACKAGE_INSTALLED_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
    else
        abort 1 "package '$PACKAGE_SPEC' is not installed."
    fi

    shift

    run tree "$@" "$PACKAGE_INSTALLED_DIR"
}

# }}}
##############################################################################
# {{{ ppkg logs

# __logs_the_given_installed_package <PACKAGE-SPEC>
  __logs_the_given_installed_package() {
    PACKAGE_SPEC=
    PACKAGE_SPEC="$(inspect_package_spec "$1")"

    if is_package_installed "$PACKAGE_SPEC" ; then
        PACKAGE_INSTALLED_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
    else
        abort 1 "package '$PACKAGE_SPEC' is not installed."
    fi

    FILEPATHS=
    FILEPATHS="$(find "$PACKAGE_INSTALLED_DIR/.ppkg" -type f)"

    for filepath in $FILEPATHS
    do
        [ -d "$filepath" ] && continue

        case $filepath in
            *.png)  ;;
            *.yml)  run yq . "$filepath" ;;
            *.json) run jq . "$filepath" ;;
            *)  if command -v bat > /dev/null ; then
                    bat  "$filepath"
                else
                    less "$filepath"
                fi
        esac
    done
}

# }}}
##############################################################################
# {{{ ppkg pack

# examples:
# __pack_the_given_installed_package <PACKAGE-NAME> [-t <zip|tar.gz|tar.xz|tar.lz|tar.bz2>] [-o <OUTPUT-PATH>] [--keep-session-dir]
# __pack_the_given_installed_package    autoconf     -t tar.xz
  __pack_the_given_installed_package() {
    __load_receipt_of_the_given_package "$1"

    shift

    ###########################################################################################

    unset OUTPUT_PATH
    unset OUTPUT_TYPE

    while [ -n "$1" ]
    do
        case $1 in
            --keep-session-dir)
                KEEP_SESSION_DIR=1
                ;;
            -t) shift

                if [ -z "$1" ] ; then
                    abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -t option is specified but <OUTPUT-TYPE> is unspecified."
                else
                    OUTPUT_TYPE="$1"
                fi

                case $OUTPUT_TYPE in
                    zip|tar.gz|tar.xz|tar.lz|tar.bz2) ;;
                    *) abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>], unsupported <OUTPU-TYPE>: $OUTPUT_TYPE, <OUTPU-TYPE> should be one of zip|tar.gz|tar.xz|tar.lz|tar.bz2"
                esac
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPU-TYPE>] [-o <OUTPUT-PATH>], -o option is specified but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_PATH="$1"
                fi
                ;;
            *)  abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>] [--keep-session-dir], unrecognized option: $1"
        esac
        shift
    done

    ###########################################################################################

    OUTPUT_FILENAME_NEED_CONTAIN_LIBC_NAME=0

    if [ "$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_NAME" = linux ] ; then
        if [ -d "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME/lib" ] ; then
            for FILEPATH in $(find "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME/lib" -type f)
            do
                case $FILEPATH in
                    */lib*.a)   OUTPUT_FILENAME_NEED_CONTAIN_LIBC_NAME=1; break ;;
                    */lib*.so*) OUTPUT_FILENAME_NEED_CONTAIN_LIBC_NAME=1; break ;;
                    */*.o)      OUTPUT_FILENAME_NEED_CONTAIN_LIBC_NAME=1; break ;;
                esac
            done
        fi

        if [ -z "$PACKED_DIR_NAME" ] ; then
            if [ -d "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME/bin" ] ; then
                for FILEPATH in $(find "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME/bin" -type f)
                do
                    FILEMAGIC=
                    FILEMAGIC="$(head -c 4 "$FILEPATH" | base16-encode)"

                    if [ "$FILEMAGIC" = '7F454C46' ] ; then
                        # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
                        PT_INTERP=
                        PT_INTERP="$(patchelf --print-interpreter "$FILEPATH" 2>/dev/null || true)"

                        if [ -n "$PT_INTERP" ] ; then
                            OUTPUT_FILENAME_NEED_CONTAIN_LIBC_NAME=1
                            break
                        fi
                    fi
                done
            fi
        fi

        if [ -z "$PACKED_DIR_NAME" ] ; then
            for FILEPATH in $(find "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME" -type f -a -name "*.a")
            do
                OUTPUT_FILENAME_NEED_CONTAIN_LIBC_NAME=1
            done
        fi
    fi

    if [ "$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_NAME" = linux ] ; then
        if [ "$OUTPUT_FILENAME_NEED_CONTAIN_LIBC_NAME" = 1 ] ; then
            PACKED_DIR_NAME="$RECEIPT_PACKAGE_PKGNAME-$RECEIPT_PACKAGE_VERSION-$RECEIPT_PACKAGE_BUILTFOR_PLATFORM"
        else
            PACKED_DIR_NAME="$RECEIPT_PACKAGE_PKGNAME-$RECEIPT_PACKAGE_VERSION-$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_NAME-$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH"
        fi
    else
            PACKED_DIR_NAME="$RECEIPT_PACKAGE_PKGNAME-$RECEIPT_PACKAGE_VERSION-$RECEIPT_PACKAGE_BUILTFOR_PLATFORM"
    fi

    ###########################################################################################

    unset OUTPUT_DIR
    unset OUTPUT_FILEPATH

    case $OUTPUT_PATH in
        '')
            if [ -z "$OUTPUT_TYPE" ] ; then
                OUTPUT_TYPE='tar.xz'
            fi

            OUTPUT_DIR="$PWD"
            OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKED_DIR_NAME.$OUTPUT_TYPE"
            ;;
        .|./)
            if [ -z "$OUTPUT_TYPE" ] ; then
                OUTPUT_TYPE='tar.xz'
            fi

            OUTPUT_DIR="$PWD"
            OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKED_DIR_NAME.$OUTPUT_TYPE"
            ;;
        ..|../)
            if [ -z "$OUTPUT_TYPE" ] ; then
                OUTPUT_TYPE='tar.xz'
            fi

            OUTPUT_DIR="$PWD/.."
            OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKED_DIR_NAME.$OUTPUT_TYPE"
            ;;
        */)
            if [ -z "$OUTPUT_TYPE" ] ; then
                OUTPUT_TYPE='tar.xz'
            fi

            case $OUTPUT_PATH in
                /*) OUTPUT_DIR="$OUTPUT_PATH" ;;
                *)  OUTPUT_DIR="$PWD/$OUTPUT_PATH"
            esac

            OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKED_DIR_NAME.$OUTPUT_TYPE"
            ;;
        *)
            if [ -z "$OUTPUT_TYPE" ] ; then
                case $OUTPUT_PATH in
                    *.tar.gz|*.tgz)
                        OUTPUT_TYPE=tar.gz
                        ;;
                    *.tar.xz|*.txz)
                        OUTPUT_TYPE=tar.xz
                        ;;
                    *.tar.lz|*.tlz)
                        OUTPUT_TYPE=tar.lz
                        ;;
                    *.tar.bz2|*.tbz2)
                        OUTPUT_TYPE=tar.bz2
                        ;;
                    *.zip)
                        OUTPUT_TYPE=zip
                        ;;
                    *.7z)
                        OUTPUT_TYPE=7z
                        ;;
                    *)  OUTPUT_TYPE=tar.xz
                esac
            fi

            case $OUTPUT_PATH in
                /*) OUTPUT_DIR="${OUTPUT_PATH%/*}"
                    OUTPUT_FILEPATH="$OUTPUT_PATH"
                    ;;
                *)  OUTPUT_DIR="$PWD/$(dirname "$OUTPUT_PATH")"
                    OUTPUT_FILEPATH="$PWD/$OUTPUT_PATH"
            esac
    esac

    ###########################################################################################

    SESSION_DIR="$PPKG_HOME/run/$$"

    step "create the session directory and change to it"
    run rm -rf     "$SESSION_DIR"
    run install -d "$SESSION_DIR"
    run cd         "$SESSION_DIR"

    step "make link refer to installed package root directory"
    run ln -s "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME" "$PACKED_DIR_NAME"

    step "packing"
    run bsdtar cvaf "packed.$OUTPUT_TYPE" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.ppkg"

    step "show size of packed file"
    run "du -sh "packed.$OUTPUT_TYPE" | cut -f1"

    if [ ! -d "$OUTPUT_DIR" ] ; then
        step "create output directory"
        run install -d "$OUTPUT_DIR"
    fi

    step "move the packed file to output directory"
    run mv "packed.$OUTPUT_TYPE" "$OUTPUT_FILEPATH"

    if [ "$KEEP_SESSION_DIR" = 1 ] ; then
        echo
        note "the session directory '$SESSION_DIR' is not deleted as --keep-session-dir option is specified."
    else
        step "delete the session directory"
        run rm -rf "$SESSION_DIR"
    fi
}

# }}}
##############################################################################
# {{{ ppkg export.<TYPE>

# examples:
# __export_the_given_installed_package <CMD> <PACKAGE-NAME> [-o <OUTPUT-PATH>] [--keep-session-dir]
# __export_the_given_installed_package          autoconf
  __export_the_given_installed_package() {
    unset OUTPUT_PATH
    unset OUTPUT_TYPE

    case $1 in
        export.deb)
            OUTPUT_TYPE=deb
            ;;
        export.rpm)
            OUTPUT_TYPE=rpm
            ;;
        export.pkg)
            OUTPUT_TYPE=pkg
            ;;
        export.apk)
            OUTPUT_TYPE=apk
            ;;
        '') abort 1 "$_0 export.<OUTPUT-TYPE> <PACKAGE-NAME> , export.<OUTPUT-TYPE> is unspecified." ;;
        *)  abort 1 "$_0 export.<OUTPUT-TYPE> <PACKAGE-NAME> , unsupported type: $1, <OUTPUT-TYPE> must be any one of deb|rpm|pkg|apk"
    esac

    __load_receipt_of_the_given_package "$2"

    if [ "$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_NAME" != linux ] ; then
        abort 1 "package $PACKAGE_SPEC was not built for Linux."
    fi

    shift 2

    while [ -n "$1" ]
    do
        case $1 in
            --keep-session-dir)
                KEEP_SESSION_DIR=1
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "$_0 export <PACKAGE-NAME> <OUTPUT-TYPE> [-o <OUTPUT-PATH>], -o option is specified but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_PATH="$1"
                fi
                ;;
            *)  abort 1 "$_0 export <PACKAGE-NAME> <OUTPUT-TYPE> [-o <OUTPUT-PATH>] [--keep-session-dir], unrecognized option: $1"
        esac
        shift
    done

    ###########################################################################################

    case $OUTPUT_PATH in
        '')
            OUTPUT_DIR="$PWD"
            OUTPUT_PATH="$OUTPUT_DIR/"
            ;;
        .|./)
            OUTPUT_DIR="$PWD"
            OUTPUT_PATH="$OUTPUT_DIR/"
            ;;
        ..|../)
            OUTPUT_DIR="$PWD/.."
            OUTPUT_PATH="$OUTPUT_DIR/"
            ;;
        /*/)
            OUTPUT_DIR="$OUTPUT_PATH"
            ;;
        */) OUTPUT_PATH="$PWD/$OUTPUT_PATH"
            OUTPUT_DIR="$OUTPUT_PATH"
            ;;
        /*) OUTPUT_DIR="$(dirname "$OUTPUT_PATH")"
            ;;
        *)  OUTPUT_DIR="$PWD/$(dirname "$OUTPUT_PATH")"
            OUTPUT_PATH="$PWD/$OUTPUT_PATH"
    esac

    ###########################################################################################

    SESSION_DIR="$PPKG_HOME/run/$$"

    run rm -rf     "$SESSION_DIR"
    run install -d "$SESSION_DIR"
    run cd         "$SESSION_DIR"

    unset TEPPUT_FILEPATH

    eval "__export_the_given_installed_package_as_$OUTPUT_TYPE"

    run du -sh "$TEPPUT_FILEPATH"

    if [ !          -d "$OUTPUT_DIR" ] ; then
        run install -d "$OUTPUT_DIR"
    fi

    run mv "$TEPPUT_FILEPATH" "$OUTPUT_PATH"

    if [ "$KEEP_SESSION_DIR" = 1 ] ; then
        echo
        note "the session directory '$SESSION_DIR' is not deleted as --keep-session-dir option is specified."
    else
        run rm -rf "$SESSION_DIR"
    fi
}

__export_the_given_installed_package_as_deb() {
    run install -d pkg/DEBIAN

    run cp -r -L "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME" pkg/usr
    run rm -rf pkg/usr/.ppkg

    SIZE="$(du -sk pkg | cut -f1)"

    case $RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH in
        x86_64) ARCHITECTURE='amd64' ;;
        x86)    ARCHITECTURE='i386'  ;;
        *)      ARCHITECTURE="$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH"
    esac

    case $RECEIPT_PACKAGE_GIT_URL in
        https://github.com/*)
            ISSUE_TRACKER_URL="$RECEIPT_PACKAGE_GIT_URL/issues" ;;
        *)  ISSUE_TRACKER_URL="$RECEIPT_PACKAGE_WEB_URL"
    esac

    # https://manpages.debian.org/buster/dpkg-dev/deb-control.5.en.html
    run tee pkg/DEBIAN/control <<EOF
Package: $RECEIPT_PACKAGE_PKGNAME
Version: $RECEIPT_PACKAGE_VERSION
Section: custom
Priority: optional
Essential: no
Bugs: $ISSUE_TRACKER_URL
Homepage: $RECEIPT_PACKAGE_WEB_URL
Maintainer: $RECEIPT_PACKAGE_WEB_URL
Description: $RECEIPT_PACKAGE_SUMMARY
Architecture: $ARCHITECTURE
Installed-Size: $SIZE
EOF

    # https://manpages.debian.org/buster/dpkg/dpkg-deb.1.en.html
    run dpkg-deb --root-owner-group --build pkg pkg.deb
    run dpkg-deb --contents pkg.deb
    run dpkg-deb --show pkg.deb
    run dpkg-deb --info pkg.deb

    TEPPUT_FILEPATH="$RECEIPT_PACKAGE_PKGNAME-$RECEIPT_PACKAGE_VERSION-$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_NAME-$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH.deb"

    run mv pkg.deb "$TEPPUT_FILEPATH"
}

__export_the_given_installed_package_as_rpm() {
    # https://www.redhat.com/sysadmin/create-rpm-package
    run install -d BUILD
    run install -d BUILDROOT
    run install -d RPMS
    run install -d SOURCES
    run install -d SPECS
    run install -d SRPMS

    run touch main.c
    run bsdtar cvaf SOURCES/src.tar.gz main.c

    run tee SPECS/pkg.spec <<EOF
Name:           $RECEIPT_PACKAGE_PKGNAME
Version:        $RECEIPT_PACKAGE_VERSION
Release:        1%{?dist}
Summary:        $RECEIPT_PACKAGE_SUMMARY
BuildArch:      $RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH

License:        $RECEIPT_PACKAGE_LICENSE
Source0:        %{name}-%{version}.tar.gz

%description
$RECEIPT_PACKAGE_SUMMARY

%prep

%build

%install
cp -r -L "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME"/* %{buildroot}/

%files
/*
EOF
    run rpmlint      SPECS/pkg.spec
    run rpmbuild -bb SPECS/pkg.spec

    run ls

    TEPPUT_FILEPATH='*.rpm'
}

__export_the_given_installed_package_as_pkg() {
    # https://wiki.archlinux.org/title/PKGBUILD
    run tee PKGBUILD <<EOF
pkgname=('$RECEIPT_PACKAGE_PKGNAME')
pkgver='$RECEIPT_PACKAGE_VERSION'
pkgrel=1
pkgdesc="$RECEIPT_PACKAGE_SUMMARY"
arch=('$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH')
license=('$RECEIPT_PACKAGE_LICENSE')
url='$RECEIPT_PACKAGE_WEB_URL'
makedepends=()
source=(https://github.com/leleliu008/androidx/releases/download/v0.1.0/androidx-0.1.0.tar.gz)
sha256sums=('504601758154dd1bbf643ffe80ca49711cd5e76231ba1970a1fd88109e06fc52')

build() {
    :
}

package() {
    install -d "\${pkgdir}/usr/"
    cp -r -L "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME"/* "\${pkgdir}/usr/"
}
EOF

    # https://wiki.archlinux.org/title/Makepkg

    unset CARCH
    unset CHOST

    unset LOGDEST
    unset PKGDEST
    unset SRCDEST
    unset SRCPKGDEST
    unset BUILDDIR

    export SRCEXT=".src.tar.gz"
    export PKGEXT=".pkg.tar.xz"

    export PACKAGER="leleliu008 <leleliu008@gmail.com>"

    run makepkg --nodeps --noextract --noprepare --nocheck

    TEPPUT_FILEPATH='*.pkg.tar.xz'
}

__export_the_given_installed_package_as_apk() {
    # https://wiki.alpinelinux.org/wiki/Creating_an_Alpine_package
    # https://wiki.alpinelinux.org/wiki/APKBUILD_Reference

    run export APORTSDIR="$PWD/aports"

    run install -d aports/community/pkg
    run cd         aports/community/pkg
    run tee APKBUILD <<EOF
# Maintainer: leleliu008 <leleliu008@gmail.com>
pkgname=$RECEIPT_PACKAGE_PKGNAME
pkgver=$RECEIPT_PACKAGE_VERSION
pkgrel=0
pkgdesc="$RECEIPT_PACKAGE_SUMMARY"
url="$RECEIPT_PACKAGE_WEB_URL"
arch="$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH"
license="$RECEIPT_PACKAGE_LICENSE"
source="https://github.com/leleliu008/test/releases/download/2023.10.08/ppkg-0.1000.2-linux-x86_64.tar.xz"
sha512sums="52206434938da1d5ead71145cc8fef1439cc567c631c7448006e835a073a8d06ef4c8f62f635927390fcf9dd4a07aadc73a29087854af4468fe914cd0b270591  ppkg-0.1000.2-linux-x86_64.tar.xz"
builddir="\$srcdir/build.d"

build() {
    :
}

check() {
    :
}

package() {
    install -d "\$pkgdir"
    cp -r -L "$PPKG_PACKAGE_INSTALLED_ROOT/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM/$RECEIPT_PACKAGE_PKGNAME"/* "\$pkgdir"
    ls "\$pkgdir"
}
EOF

    run abuild -F

    run cd -

    run ls

    TEPPUT_FILEPATH="packages/community/$RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH/*.apk"
}

# }}}
##############################################################################
# {{{ configure

configure_only() {
    export FORCE_UNSAFE_CONFIGURE=1

    export ac_cv_func_malloc_0_nonnull=yes
    export ac_cv_func_calloc_0_nonnull=yes
    export ac_cv_func_realloc_0_nonnull=yes

    CONFIGURE_ARGS="--prefix=$PACKAGE_INSTALL_DIR"

    if [ "$CROSS_COMPILING" = 1 ] ; then
        if [ "$TARGET_PLATFORM_NAME" = linux ] ; then
            case $TARGET_PLATFORM_VERS in
                glibc) TARGET_TRIPLE="$TARGET_PLATFORM_ARCH-unknown-linux-gnu"  ;;
                musl)  TARGET_TRIPLE="$TARGET_PLATFORM_ARCH-unknown-linux-musl" ;;
                *)     TARGET_TRIPLE="$TARGET_PLATFORM_ARCH-unknown-linux"
            esac
        elif [ "$TARGET_PLATFORM_NAME" = macos ] ; then
            TARGET_TRIPLE="$TARGET_PLATFORM_ARCH-apple-darwin"
        else
            TARGET_TRIPLE="$TARGET_PLATFORM_ARCH-unknown-$TARGET_PLATFORM_NAME"
        fi

        CONFIGURE_ARGS="$CONFIGURE_ARGS --host=$TARGET_TRIPLE"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-debug"
    else
        CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-debug"
    fi

    case $INSTALL_LIB in
        static) CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --disable-shared" ;;
        shared) CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-shared --disable-static" ;;
        both)   CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --enable-shared"  ;;
        no)     CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-static --disable-shared";;
    esac

    CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-option-checking --enable-rpath --disable-nls --enable-largefile"

    if [ -n "$PPKG_XTRACE" ] ; then
        sed_in_place '1a set -x' "$PACKAGE_BSCRIPT_DIR/configure"
    fi

    if run "$PACKAGE_BSCRIPT_DIR/configure" "$CONFIGURE_ARGS" "$@" ; then
        printf '\n'
    else
        if [ -f "$PACKAGE_BCACHED_DIR/config.log" ] ; then
            run cat "$PACKAGE_BCACHED_DIR/config.log"
        elif [ -f "$PACKAGE_BSCRIPT_DIR/config.log" ] ; then
            run cat "$PACKAGE_BSCRIPT_DIR/config.log"
        fi

        return 1
    fi

    if [ "$LOG_LEVEL" -ge 2 ] ; then
        for Makefile in $(find "$PACKAGE_BSCRIPT_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done

        unset Makefile
    fi
}

configure() {
    configure_only "$@" &&
    gmakew clean &&
    gmakew V=1   &&
    gmakew install
}

# }}}
##############################################################################
# {{{ gmakew

gmakew() {
    if [ "$LOG_LEVEL" -ge 3 ] ; then
        run "$GMAKE" "-j$BUILD_NJOBS" --debug "$@"
    else
        run "$GMAKE" "-j$BUILD_NJOBS" "$@"
    fi
}

# }}}
##############################################################################
# {{{ cmakew

# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
#
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_IGNORE_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PROGRAM_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_LIBRARY_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INCLUDE_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
#
# run in a subshell
cmakew() {
    echo "CMAKE_TOOLCHAIN_FILE=$CMAKE_TOOLCHAIN_FILE"

    cat > "$CMAKE_TOOLCHAIN_FILE" <<EOF
message(STATUS "CMake command: \${CMAKE_COMMAND}")
message(STATUS "CMake version: \${CMAKE_VERSION}")
EOF

    if [ "$CROSS_COMPILING" = 1 ] ; then
        case $TARGET_PLATFORM_NAME in
            linux)    CMAKE_SYSTEM_NAME=Linux   ;;
            macos)    CMAKE_SYSTEM_NAME=Darwin  ;;
            freebsd)  CMAKE_SYSTEM_NAME=FreeBSD ;;
            openbsd)  CMAKE_SYSTEM_NAME=OpenBSD ;;
            netbsd)   CMAKE_SYSTEM_NAME=NetBSD  ;;
            dragonflybsd)
                      CMAKE_SYSTEM_NAME=FreeBSD ;;
            *)        CMAKE_SYSTEM_NAME="$TARGET_PLATFORM_NAME"
        esac

        cat >> "$CMAKE_TOOLCHAIN_FILE" <<EOF
set(CMAKE_SYSTEM_NAME      $CMAKE_SYSTEM_NAME)
set(CMAKE_SYSTEM_VERSION   $TARGET_PLATFORM_VERS)
set(CMAKE_SYSTEM_PROCESSOR $TARGET_PLATFORM_ARCH)
EOF
    fi

    cat >> "$CMAKE_TOOLCHAIN_FILE" <<EOF

message(STATUS "CMAKE_HOST_SYSTEM_NAME: \${CMAKE_HOST_SYSTEM_NAME}")
message(STATUS "     CMAKE_SYSTEM_NAME: \${CMAKE_SYSTEM_NAME}")

if ("\${BUILD_SHARED_LIBS}" STREQUAL "")
    set(BUILD_SHARED_LIBS $BUILD_SHARED_LIBS)
endif()

set(CMAKE_BUILD_TYPE  $CMAKE_BUILD_TYPE)

set(CMAKE_C_COMPILER "$CC")
set(CMAKE_C_FLAGS "$CPPFLAGS $CFLAGS")

set(CMAKE_CXX_COMPILER "$CXX")
set(CMAKE_CXX_FLAGS "$CPPFLAGS $CXXFLAGS")

set(CMAKE_ASM_COMPILER "$CC")

set(CMAKE_SHARED_LINKER_FLAGS "$(printf '%s\n' "$LDFLAGS" | sed -e 's|--static||g' -e 's|-static||g')")
set(CMAKE_EXE_LINKER_FLAGS    "$LDFLAGS")

set(CMAKE_C_COMPILER_AR     "$AR")
set(CMAKE_C_COMPILER_RANLIB "$RANLIB")

set(CMAKE_CXX_COMPILER_AR     "$AR")
set(CMAKE_CXX_COMPILER_RANLIB "$RANLIB")

set(CMAKE_AR      "$AR")
set(CMAKE_RANLIB  "$RANLIB")

set(CMAKE_LINKER  "$LD")

set(CMAKE_NM      "$NM")
set(CMAKE_READELF "$READELF")

set(CMAKE_OBJCOPY "$OBJCOPY")
set(CMAKE_OBJDUMP "$OBJDUMP")

set(CMAKE_STRIP   "$STRIP")

set(CMAKE_ADDR2LINE "$ADDR2LINE")

if ("\${CMAKE_EXE_LINKER_FLAGS}" MATCHES ".*-static.*")
    set(CMAKE_SKIP_INSTALL_RPATH ON)
endif()

set(CMAKE_FIND_DEBUG_MODE $CMAKE_FIND_DEBUG_MODE)
set(CMAKE_FIND_ROOT_PATH "$CMAKE_FIND_ROOT_PATH")
EOF

    if [ "$CROSS_COMPILING" = 1 ] ; then
        cat >> "$CMAKE_TOOLCHAIN_FILE" <<EOF
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
EOF
    fi

    if [ "$LOG_LEVEL" -gt 0 ] ; then
        if command -v bat > /dev/null ; then
            run bat --language=cmake --paging=never --style=plain "$CMAKE_TOOLCHAIN_FILE"
        else
            run cat "$CMAKE_TOOLCHAIN_FILE"
        fi
    fi

    run "$CMAKE" \
        -Wno-dev \
        -DCMAKE_INSTALL_LIBDIR="$PACKAGE_INSTALL_DIR/lib" \
        -DCMAKE_INSTALL_PREFIX="$PACKAGE_INSTALL_DIR" \
        -DCMAKE_TOOLCHAIN_FILE="$CMAKE_TOOLCHAIN_FILE" \
        -DCMAKE_PROJECT_INCLUDE="$CMAKE_PROJECT_INCLUDE" \
        -DCMAKE_VERBOSE_MAKEFILE="$CMAKE_VERBOSE_MAKEFILE" \
        -DCMAKE_COLOR_MAKEFILE="$CMAKE_COLOR_MAKEFILE" \
        -DBUILD_TESTING=OFF \
        -S "$PACKAGE_BSCRIPT_DIR" \
        -B "$PACKAGE_BCACHED_DIR" "$@" &&
    run "$CMAKE" --build   "$PACKAGE_BCACHED_DIR" -- "-j$BUILD_NJOBS" &&
    run "$CMAKE" --install "$PACKAGE_BCACHED_DIR"
}

# }}}
##############################################################################
# {{{ xmakew

# https://github.com/xmake-io/xmake/issues/2003
# run in a subshell
xmakew() {
    XMAKE_CONFIG_OPTIONS="$*"

    XMAKE_CONFIG_OPTION_CLEAN=
    XMAKE_CONFIG_OPTION_MODE=
    XMAKE_CONFIG_OPTION_vD=

    for arg in "$@"
    do
        case $arg in
            -c|--clean)  XMAKE_CONFIG_OPTION_CLEAN='set' ;;
            -m|--mode=*) XMAKE_CONFIG_OPTION_MODE='set'  ;;
            -vD)         XMAKE_CONFIG_OPTION_vD='set' ;;
        esac
    done

    if [ "$LOG_LEVEL" -ge 3 ] && [ -z "$XMAKE_CONFIG_OPTION_vD" ]; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTION_vD -vD"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_CLEAN" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --clean"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_MODE" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --mode=$BUILD_TYPE"
    fi

    run "$XMAKE" config "$XMAKE_CONFIG_OPTIONS" "--project=$PACKAGE_BSCRIPT_DIR" "--buildir=$PACKAGE_BCACHED_DIR" &&
    run "$XMAKE" "--jobs=$BUILD_NJOBS" &&
    run "$XMAKE" install -o "$PACKAGE_INSTALL_DIR"
}

# }}}
##############################################################################
# {{{ mesonw

# https://mesonbuild.com/Native-environments.html
mesonw() {
    MESON_NATIVE_FILE="$PACKAGE_WORKING_DIR/native-file.ini"

    cat > "$MESON_NATIVE_FILE" <<EOF
[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'

[built-in options]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF

    MESON_SETUP_ARGS="--prefix=$PACKAGE_INSTALL_DIR --buildtype=$BUILD_TYPE --backend=ninja --pkg-config-path='$PKG_CONFIG_PATH' --native-file=$MESON_NATIVE_FILE -Dlibdir=lib"

    case $INSTALL_LIB in
        static|shared|both) MESON_SETUP_ARGS="$MESON_SETUP_ARGS -Ddefault_library=$INSTALL_LIB"
    esac

    case $LINK_TYPE in
        static-full|static-most) MESON_SETUP_ARGS="$MESON_SETUP_ARGS --prefer-static"
    esac

    MESON_COMPILE_ARGS="-C $PACKAGE_BCACHED_DIR -j $BUILD_NJOBS"
    MESON_INSTALL_ARGS="-C $PACKAGE_BCACHED_DIR"

    if [ "$LOG_LEVEL" -ge 3 ] ; then
        MESON_COMPILE_ARGS="$MESON_COMPILE_ARGS -v"
    fi

    run "$MESON" setup   "$MESON_SETUP_ARGS" "$@" "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR" &&
    run "$MESON" compile "$MESON_COMPILE_ARGS" &&
    run "$MESON" install "$MESON_INSTALL_ARGS"
}

to_meson_array() {
    RESULT=

    for item in "$@"
    do
        if [ -z "$RESULT" ] ; then
            RESULT="'$item'"
        else
            RESULT="$RESULT, '$item'"
        fi
    done

    printf '[%s]\n' "$RESULT"
}

# }}}
##############################################################################
# {{{ cargow

cargow() {
    run rustup target add "$RUST_TARGET"

    case $1 in
        build)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-build.html

            unset CARGO_BUILD_ARGS
            unset CARGO_BUILD_ARG_VV
            unset CARGO_BUILD_ARG_TARGET
            unset CARGO_BUILD_ARG_RELEASE

            for arg in "$@"
            do
                case $arg in
                    --vv)      CARGO_BUILD_ARG_VV='set'      ;;
                    --target)  CARGO_BUILD_ARG_TARGET='set'  ;;
                    --release) CARGO_BUILD_ARG_RELEASE='set' ;;
                esac
            done

            CARGO_BUILD_ARGS="$*"

            if [ -z "$CARGO_BUILD_ARG_VV" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS -vv"
            fi

            if [ -z "$CARGO_BUILD_ARG_RELEASE" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --release"
            fi

            if [ -z "$CARGO_BUILD_ARG_TARGET" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --target $RUST_TARGET"
            fi

            # shellcheck disable=SC2086
            run cargo clean && run cargo $CARGO_BUILD_ARGS
            ;;
        install)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-install.html

            unset CARGO_INSTALL_ARGS
            unset CARGO_INSTALL_ARG_TARGET
            unset CARGO_INSTALL_ARG_PATH
            unset CARGO_INSTALL_ARG_ROOT
            unset CARGO_INSTALL_ARG_VV

            for arg in "$@"
            do
                case $arg in
                    --target) CARGO_INSTALL_ARG_TARGET='set' ;;
                    --path)   CARGO_INSTALL_ARG_PATH='set'   ;;
                    --root)   CARGO_INSTALL_ARG_ROOT='set'   ;;
                    --vv)     CARGO_INSTALL_ARG_VV='set'     ;;
                esac
            done

            CARGO_INSTALL_ARGS="$*"

            if [ -z "$CARGO_INSTALL_ARG_VV" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_INSTALL_ARG_TARGET" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_INSTALL_ARG_PATH" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --path $PACKAGE_BSCRIPT_DIR"
            fi

            if [ -z "$CARGO_INSTALL_ARG_ROOT" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --root=$PACKAGE_INSTALL_DIR"
            fi

            # shellcheck disable=SC2086
            run cargo clean && run cargo $CARGO_INSTALL_ARGS
            ;;
        cbuild|cinstall)
            unset CARGO_CINSTALL_ARGS
            unset CARGO_CINSTALL_ARG_Q
            unset CARGO_CINSTALL_ARG_V
            unset CARGO_CINSTALL_ARG_VV
            unset CARGO_CINSTALL_ARG_DEBUG
            unset CARGO_CINSTALL_ARG_RELEASE
            unset CARGO_CINSTALL_ARG_TARGET
            unset CARGO_CINSTALL_ARG_PREFIX

            for arg in "$@"
            do
                case $arg in
                    -q|--quiet)   CARGO_CINSTALL_ARG_Q='set'       ;;
                    -v|--verbose) CARGO_CINSTALL_ARG_V='set'       ;;
                    -vv)          CARGO_CINSTALL_ARG_VV='set'      ;;
                    --debug)      CARGO_CINSTALL_ARG_DEBUG='set'   ;;
                    --release)    CARGO_CINSTALL_ARG_RELEASE='set' ;;
                    --target)     CARGO_CINSTALL_ARG_TARGET='set'  ;;
                    --prefix)     CARGO_CINSTALL_ARG_PREFIX='set'  ;;
                esac
            done

            CARGO_CINSTALL_ARGS="$*"

            if [ -z "$CARGO_CINSTALL_ARG_Q" ] && [ -z "$CARGO_CINSTALL_ARG_V" ] && [ -z "$CARGO_CINSTALL_ARG_VV" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_DEBUG" ] && [ -z "$CARGO_CINSTALL_ARG_RELEASE" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --release"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_TARGET" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_PREFIX" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --prefix $PACKAGE_INSTALL_DIR"
            fi

            # shellcheck disable=SC2086
            run cargo $CARGO_CINSTALL_ARGS
            ;;
        *) cargo "$@"
    esac
}

# }}}
##############################################################################
# {{{ gow

gow() {
    if command -v bat > /dev/null ; then
        run "go env | bat --language=bash --paging=never --style=plain"
    else
        run "go env"
    fi

    printf '\n'

    # /Users/runner/go/pkg/mod/golang.org/x/sys@v0.0.0-20191028164358-195ce5e7f934/unix/syscall_darwin.1_13.go:25:3: //go:linkname must refer to declared function or variable
    if [ "$TARGET_PLATFORM_NAME" = macos ] ; then
        GOMOD="$PACKAGE_BSCRIPT_DIR/go.mod"

        if [ -f "$GOMOD" ] && go mod graph | grep -q 'golang\.org/x/sys' ; then
            run go get -u golang.org/x/sys

            if [ -d "$PACKAGE_BSCRIPT_DIR/vendor" ] ; then
                unset GO_VERSION_MAJOR
                unset GO_VERSION_MINOR

                GO_VERSION_MAJOR=$(go env GOVERSION | cut -c3- | cut -d. -f1)
                GO_VERSION_MINOR=$(go env GOVERSION | cut -c3- | cut -d. -f2)

                sed_in_place "/^go[[:space:]]*[1-9]\.[0-9][0-9]/c go $GO_VERSION_MAJOR.$GO_VERSION_MINOR" "$GOMOD"

                run go mod tidy
                run go mod vendor
            fi
        fi
    fi

    # https://pkg.go.dev/cmd/go
    # https://pkg.go.dev/cmd/link

    unset GO_BUILD_ARGS
    unset GO_BUILD_ARGV_V
    unset GO_BUILD_ARGV_X
    unset GO_BUILD_ARGV_O
    unset GO_BUILD_ARGV_MOD
    unset GO_BUILD_ARGV_TAGS
    unset GO_BUILD_ARGV_LDFLAGS

    unset GO_BUILD_ARGS_EXTRA

    while [ -n "$1" ]
    do
        case $1 in
            -v) shift ; GO_BUILD_ARGV_V='-v' ;;
            -x) shift ; GO_BUILD_ARGV_X='-x' ;;
            -o) shift ; GO_BUILD_ARGV_O="$1" ; shift ;;
            -X) shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="-X $1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -X $1"
                fi
                shift
                ;;
            -ldflags)
                shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="$1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$1 $GO_BUILD_ARGV_LDFLAGS"
                fi
                shift
                ;;
            *)  GO_BUILD_ARGS_EXTRA="$GO_BUILD_ARGS_EXTRA $1" ; shift
        esac
    done

    GO_BUILD_ARGS='-trimpath'

    if [ -z "$GO_BUILD_ARGV_V" ] ; then
        if [ "$LOG_LEVEL" -gt 0 ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
    fi

    if [ -z "$GO_BUILD_ARGV_X" ] ; then
        if [ "$LOG_LEVEL" -ge 2 ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -s -w"
    fi

    if [ "$LINK_TYPE" = 'static-full' ] && [ "$CGO_ENABLED" -eq 1 ] ; then
        GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -linkmode external \"-extldflags=-static\""
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS -ldflags '$GO_BUILD_ARGV_LDFLAGS'"

    if [ -z "$GO_BUILD_ARGV_O" ] ; then
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_BCACHED_DIR/"
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_BCACHED_DIR/$GO_BUILD_ARGV_O"
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS $GO_BUILD_ARGS_EXTRA"

    # shellcheck disable=SC2086
    run go build $GO_BUILD_ARGS

    for item in $(ls "$PACKAGE_BCACHED_DIR")
    do
        case $item in
            *.a)  run install_libs "$PACKAGE_BCACHED_DIR/$item" ;;
            *.so) run install_libs "$PACKAGE_BCACHED_DIR/$item" ;;
            *)    run install_bins "$PACKAGE_BCACHED_DIR/$item" ;;
        esac
    done
}

# }}}
##############################################################################
# {{{ inspect_package_spec

# inspect_package_spec <PACKAGE-NAME|PACKAGE-SPEC> [DEFAULT-TARGET]
  inspect_package_spec() {
    case $1 in
        '') abort 1 "package-name or package-spec is unspecified."
            ;;
        */*)
            PACKAGE_NAME="${1##*/}"

            if [ -z "$PACKAGE_NAME" ] ; then
                abort 1 "invalid package-spec: $1\npackage-name is unspecified."
            elif printf '%s\n' "$PACKAGE_NAME" | grep -q -E '^[A-Za-z0-9+-._@]{1,50}$' ; then
                :
            else
                abort 1 "invalid package-spec: $1\npackage-name does not match pattern ^[A-Za-z0-9+-._@]{1,50}$"
            fi

            TARGET_PLATFORM_SPEC="${1%/*}"

            TARGET_PLATFORM_NAME=
            TARGET_PLATFORM_VERS=
            TARGET_PLATFORM_ARCH=

            TARGET_PLATFORM_NAME="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f1)"
            TARGET_PLATFORM_VERS="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f2)"
            TARGET_PLATFORM_ARCH="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f3)"

            if [ -z "$TARGET_PLATFORM_NAME" ] ; then
                abort 1 "invalid package-spec: $1, platform-name is unspecified."
            fi

            if [ -z "$TARGET_PLATFORM_VERS" ] ; then
                abort 1 "invalid package-spec: $1, platform-arch is unspecified."
            fi

            if [ -z "$TARGET_PLATFORM_ARCH" ] ; then
                abort 1 "invalid package-spec: $1, platform-arch is unspecified."
            fi

            case $TARGET_PLATFORM_NAME in
                linux)
                    case $TARGET_PLATFORM_VERS in
                        glibc|musl) ;;
                        *)  abort 1 "invalid package-spec: $1, unrecognized libc: $TARGET_PLATFORM_VERS"
                    esac
                    ;;
                macos)
                    case $TARGET_PLATFORM_ARCH in
                        x86_64|arm64) ;;
                        *)  abort 1 "invalid package-spec: $1, unsupported arch: $TARGET_PLATFORM_ARCH"
                    esac
                    ;;
                freebsd)
                    case $TARGET_PLATFORM_ARCH in
                        x86_64) TARGET_PLATFORM_ARCH='amd64'
                    esac
                    ;;
                openbsd)
                    case $TARGET_PLATFORM_ARCH in
                        x86_64) TARGET_PLATFORM_ARCH='amd64'
                    esac
                    ;;
                netbsd)
                    case $TARGET_PLATFORM_ARCH in
                        x86_64) TARGET_PLATFORM_ARCH='amd64'
                    esac
                    ;;
                dragonflybsd)
                    case $TARGET_PLATFORM_ARCH in
                        amd64) TARGET_PLATFORM_ARCH='x86_64'
                    esac
                    ;;
                *)  abort 1 "invalid package-spec: $1, unsupported platform: $TARGET_PLATFORM_NAME"
            esac

            PACKAGE_SPEC="$TARGET_PLATFORM_SPEC/$PACKAGE_NAME"
            printf '%s\n' "$PACKAGE_SPEC"
            ;;
        *)  if printf '%s\n' "$1" | grep -q -E '^[A-Za-z0-9+-._@]{1,50}$' ; then
                case $2 in
                    '') ;;
                    *-*-*-*)
                        abort 1 "you have specified --target=$2 , but it is an invalid target."
                        ;;
                    *-*-*)
                        TARGET_PLATFORM_NAME=
                        TARGET_PLATFORM_VERS=
                        TARGET_PLATFORM_ARCH=

                        TARGET_PLATFORM_NAME="$(printf '%s\n' "$2" | cut -d- -f1)"
                        TARGET_PLATFORM_VERS="$(printf '%s\n' "$2" | cut -d- -f2)"
                        TARGET_PLATFORM_ARCH="$(printf '%s\n' "$2" | cut -d- -f3)"

                        if [ -z "$TARGET_PLATFORM_NAME" ] ; then
                            abort 1 "you have specified --target=$2 , but it is an invalid target."
                        fi

                        if [ -z "$TARGET_PLATFORM_VERS" ] ; then
                            abort 1 "you have specified --target=$2 , but it is an invalid target."
                        fi

                        if [ -z "$TARGET_PLATFORM_ARCH" ] ; then
                            abort 1 "you have specified --target=$2 , but it is an invalid target."
                        fi

                        case $TARGET_PLATFORM_NAME in
                            linux)
                                case $TARGET_PLATFORM_VERS in
                                    glibc|musl) ;;
                                    *)  abort 1 "you have specified --target=$2 , but it is an invalid target, unrecognized libc: $TARGET_PLATFORM_VERS"
                                esac
                                ;;
                            macos)
                                case $TARGET_PLATFORM_ARCH in
                                    x86_64|arm64) ;;
                                    *)  abort 1 "you have specified --target=$2 , but it is an invalid target, unsupported arch: $TARGET_PLATFORM_ARCH"
                                esac
                                ;;
                            freebsd)
                                case $TARGET_PLATFORM_ARCH in
                                    x86_64) TARGET_PLATFORM_ARCH='amd64'
                                esac
                                ;;
                            openbsd)
                                case $TARGET_PLATFORM_ARCH in
                                    x86_64) TARGET_PLATFORM_ARCH='amd64'
                                esac
                                ;;
                            netbsd)
                                case $TARGET_PLATFORM_ARCH in
                                    x86_64) TARGET_PLATFORM_ARCH='amd64'
                                esac
                                ;;
                            dragonflybsd)
                                case $TARGET_PLATFORM_ARCH in
                                    amd64) TARGET_PLATFORM_ARCH='x86_64'
                                esac
                                ;;
                            *)  abort 1 "you have specified --target=$2 , but it is an invalid target, unsupported platform: $TARGET_PLATFORM_NAME"
                        esac

                        TARGET_PLATFORM_SPEC="$TARGET_PLATFORM_NAME-$TARGET_PLATFORM_VERS-$TARGET_PLATFORM_ARCH"
                        PACKAGE_SPEC="$TARGET_PLATFORM_SPEC/$1"

                        note "$1 will be treated as a package-name, and it will be expanded to $PACKAGE_SPEC"
                        printf '%s\n' "$PACKAGE_SPEC"
                        return 0
                        ;;
                    *)  abort 1 "you have specified --target=$2 , but it is an invalid target."
                esac

                case $PPKG_DEFAULT_TARGET in
                    '')
                        TARGET_PLATFORM_NAME="$NATIVE_OS_TYPE"
                        TARGET_PLATFORM_ARCH="$NATIVE_OS_ARCH"

                        if [ "$NATIVE_OS_TYPE" = linux ] ; then
                            TARGET_PLATFORM_VERS="$NATIVE_OS_LIBC"
                        else
                            TARGET_PLATFORM_VERS="$NATIVE_OS_VERS"
                        fi

                        TARGET_PLATFORM_SPEC="$TARGET_PLATFORM_NAME-$TARGET_PLATFORM_VERS-$TARGET_PLATFORM_ARCH"

                        PACKAGE_SPEC="$TARGET_PLATFORM_SPEC/$1"
                        ;;
                    *-*-*-*)
                        abort 1 "you have set PPKG_DEFAULT_TARGET=$PPKG_DEFAULT_TARGET , but it is an invalid target."
                        ;;
                    *-*-*)
                        TARGET_PLATFORM_NAME=
                        TARGET_PLATFORM_VERS=
                        TARGET_PLATFORM_ARCH=

                        TARGET_PLATFORM_NAME="$(printf '%s\n' "$PPKG_DEFAULT_TARGET" | cut -d- -f1)"
                        TARGET_PLATFORM_VERS="$(printf '%s\n' "$PPKG_DEFAULT_TARGET" | cut -d- -f2)"
                        TARGET_PLATFORM_ARCH="$(printf '%s\n' "$PPKG_DEFAULT_TARGET" | cut -d- -f3)"

                        if [ -z "$TARGET_PLATFORM_NAME" ] ; then
                            abort 1 "you have set PPKG_DEFAULT_TARGET=$PPKG_DEFAULT_TARGET , but it is an invalid package spec."
                        fi

                        if [ -z "$TARGET_PLATFORM_VERS" ] ; then
                            abort 1 "you have set PPKG_DEFAULT_TARGET=$PPKG_DEFAULT_TARGET , but it is an invalid target."
                        fi

                        if [ -z "$TARGET_PLATFORM_ARCH" ] ; then
                            abort 1 "you have set PPKG_DEFAULT_TARGET=$PPKG_DEFAULT_TARGET , but it is an invalid target."
                        fi

                        case $TARGET_PLATFORM_NAME in
                            linux)
                                case $TARGET_PLATFORM_VERS in
                                    glibc|musl) ;;
                                    *)  abort 1 "you have set PPKG_DEFAULT_TARGET=$PPKG_DEFAULT_TARGET , but it is an invalid target, unrecognized libc: $TARGET_PLATFORM_VERS"
                                esac
                                ;;
                            macos)
                                case $TARGET_PLATFORM_ARCH in
                                    x86_64|arm64) ;;
                                    *)  abort 1 "you have set PPKG_DEFAULT_TARGET=$PPKG_DEFAULT_TARGET , but it is an invalid target, unsupported arch: $TARGET_PLATFORM_ARCH"
                                esac
                                ;;
                            freebsd)
                                case $TARGET_PLATFORM_ARCH in
                                    x86_64) TARGET_PLATFORM_ARCH='amd64'
                                esac
                                ;;
                            openbsd)
                                case $TARGET_PLATFORM_ARCH in
                                    x86_64) TARGET_PLATFORM_ARCH='amd64'
                                esac
                                ;;
                            netbsd)
                                case $TARGET_PLATFORM_ARCH in
                                    x86_64) TARGET_PLATFORM_ARCH='amd64'
                                esac
                                ;;
                            dragonflybsd)
                                case $TARGET_PLATFORM_ARCH in
                                    amd64) TARGET_PLATFORM_ARCH='x86_64'
                                esac
                                ;;
                            *)  abort 1 "you have set PPKG_DEFAULT_TARGET=$PPKG_DEFAULT_TARGET , but it is an invalid target, unsupported platform: $TARGET_PLATFORM_NAME"
                        esac

                        TARGET_PLATFORM_SPEC="$TARGET_PLATFORM_NAME-$TARGET_PLATFORM_VERS-$TARGET_PLATFORM_ARCH"
                        PACKAGE_SPEC="$TARGET_PLATFORM_SPEC/$1"
                        ;;
                    *) abort 1 "you have set PPKG_DEFAULT_TARGET=$PPKG_DEFAULT_TARGET , but it is an invalid target."
                esac

                note "$1 will be treated as a package-name, and it will be expanded to $PACKAGE_SPEC"
                printf '%s\n' "$PACKAGE_SPEC"
            else
                abort 1 "invalid package-name: $1\npackage-name does not match pattern ^[A-Za-z0-9+-._@]{1,50}$"
            fi
    esac
}

# }}}
##############################################################################
# {{{ __inspect_install_arguments

__inspect_install_arguments() {
    # 0 : quiet
    # 1 : normal
    # 2 : vebose
    # 3 : very verbose
    LOG_LEVEL=1

    BUILD_NJOBS="$NATIVE_OS_NCPU"

    BUILD_TYPE=release

    LINK_TYPE=shared-most

    INSTALL_LIB=both

    KEEP_SESSION_DIR=0

    CCACHE_ENABLED=0

    UPGRAGE=0

    DRYRUN=0

    EXPORT_COMPILE_COMMANDS_JSON=0

    unset SPECIFIED_TARGET

    unset SPECIFIED_PACKAGE_LIST

    unset TOOLCHAIN


    while [ -n "$1" ]
    do
        case "$1" in
            -vv)LOG_LEVEL=3 ;;
            -v) LOG_LEVEL=2 ;;
            -q) LOG_LEVEL=0 ;;
            --dry-run)
                DRYRUN=1
                ;;
            --keep-session-dir)
                KEEP_SESSION_DIR=1
                ;;
            --upgrade)
                UPGRAGE=1
                ;;
            --target=*)
                SPECIFIED_TARGET="${1#*=}"
                ;;
            --toolchain=*)
                TOOLCHAIN="${1#*=}"

                case $TOOLCHAIN in
                    '') abort 1 "--toolchain=<VALUE>, VALUE must be non-empty." ;;
                    *.yml)
                        if [ -e "$TOOLCHAIN" ] ; then
                            __inspect_toolchain_config_file "$TOOLCHAIN"
                        else
                            abort 1 "$TOOLCHAIN toolchain config file does not exist."
                        fi
                        ;;
                    */*)abort 1 "--toolchain=<NAME|FILEPATH>, <FILEPATH> must ends with .yml"
                        ;;
                    *)  TOOLCHAIN_CONFIG_FILEPATH="$PPKG_HOME/toolchains/$TOOLCHAIN.yml"

                        if [ -e "$TOOLCHAIN_CONFIG_FILEPATH" ] ; then
                            __inspect_toolchain_config_file "$TOOLCHAIN_CONFIG_FILEPATH"
                        else
                            abort 1 "$TOOLCHAIN.yml toolchain config file was not found in $PPKG_HOME/toolchains directory."
                        fi
                esac
                ;;
            --build-type=*)
                BUILD_TYPE="${1#*=}"

                case $BUILD_TYPE in
                    debug|release) ;;
                    '') abort 1 "--build-type=<VALUE>, VALUE must be non-empty." ;;
                    *)  abort 1 "--build-type=<VALUE>, VALUE must be one of debug|release"
                esac

                ;;
            --link-type=*)
                LINK_TYPE="${1#*=}"

                case $LINK_TYPE in
                    static-full|shared-full|static-most|shared-most) ;;
                    '') abort 1 "--link-type=<VALUE>, VALUE must be non-empty." ;;
                    *)  abort 1 "--link-type=<VALUE>, VALUE must be one of static-full|shared-full|static-most|shared-most"
                esac
                ;;
            --jobs=*)
                BUILD_NJOBS="${1#*=}"
                is_integer "$BUILD_NJOBS" || abort 1 "--jobs=<VALUE>, VALUE must be an integer."
                ;;
            -*) abort 1 "unrecognized option: $1"
                ;;
            *)  SPECIFIED_PACKAGE_LIST="$SPECIFIED_PACKAGE_LIST $1"
        esac
        shift
    done

    #########################################################################################

    unset SPECIFIED_PACKAGE_SPEC_LIST

    for PACKAGE in $SPECIFIED_PACKAGE_LIST
    do
        PACKAGE_SPEC=
        PACKAGE_SPEC="$(inspect_package_spec "$PACKAGE" $SPECIFIED_TARGET)"

        if [ -z "$SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
            SPECIFIED_PACKAGE_SPEC_LIST="$PACKAGE_SPEC"
        else
            SPECIFIED_PACKAGE_SPEC_LIST="$SPECIFIED_PACKAGE_SPEC_LIST $PACKAGE_SPEC"
        fi
    done

    #########################################################################################

    [ "$LOG_LEVEL" -eq 0 ] && {
        exec 1>/dev/null
        exec 2>&1
    }

    #########################################################################################

    if [ -z "$TOOLCHAIN" ] ; then
        DEFAULT_TOOLCHAIN_CONFIG_FILEPATH="$PPKG_HOME/toolchains/default.yml"

        if [ -e "$DEFAULT_TOOLCHAIN_CONFIG_FILEPATH" ] ; then
            __inspect_toolchain_config_file "$DEFAULT_TOOLCHAIN_CONFIG_FILEPATH"
        fi
    fi

    #########################################################################################

    unset      CC_FOR_BUILD
    unset    OBJC_FOR_BUILD
    unset     CXX_FOR_BUILD
    unset     CPP_FOR_BUILD
    unset      AS_FOR_BUILD
    unset      AR_FOR_BUILD
    unset  RANLIB_FOR_BUILD
    unset      LD_FOR_BUILD
    unset      NM_FOR_BUILD
    unset    SIZE_FOR_BUILD
    unset   STRIP_FOR_BUILD
    unset STRINGS_FOR_BUILD
    unset OBJDUMP_FOR_BUILD
    unset OBJCOPY_FOR_BUILD
    unset READELF_FOR_BUILD
    unset SYSROOT_FOR_BUILD

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
             CC_FOR_BUILD="$(xcrun --sdk macosx --find clang)"
           OBJC_FOR_BUILD="$(xcrun --sdk macosx --find clang)"
            CXX_FOR_BUILD="$(xcrun --sdk macosx --find clang++)"
             AS_FOR_BUILD="$(xcrun --sdk macosx --find as)"
             AR_FOR_BUILD="$(xcrun --sdk macosx --find ar)"
         RANLIB_FOR_BUILD="$(xcrun --sdk macosx --find ranlib)"
             LD_FOR_BUILD="$(xcrun --sdk macosx --find ld)"
             NM_FOR_BUILD="$(xcrun --sdk macosx --find nm)"
           SIZE_FOR_BUILD="$(xcrun --sdk macosx --find size)"
          STRIP_FOR_BUILD="$(xcrun --sdk macosx --find strip)"
        STRINGS_FOR_BUILD="$(xcrun --sdk macosx --find strings)"
        OBJDUMP_FOR_BUILD="$(xcrun --sdk macosx --find objdump)"
        SYSROOT_FOR_BUILD="$(xcrun --sdk macosx --show-sdk-path)"
    else
             CC_FOR_BUILD="$(command -v cc || command -v clang || command -v gcc)" || abort 1 "C Compiler for native not found."
           OBJC_FOR_BUILD="$(command -v cc || command -v clang || command -v gcc)" || abort 1 "C Compiler for native not found."
            CXX_FOR_BUILD="$(command -v c++ || command -v clang++ || command -v g++)" || abort 1 "C++ Compiler for native not found."
             AS_FOR_BUILD="$(command -v as)"      || abort 1 "command not found: as"
             AR_FOR_BUILD="$(command -v ar)"      || abort 1 "command not found: ar"
         RANLIB_FOR_BUILD="$(command -v ranlib)"  || abort 1 "command not found: ranlib"
             LD_FOR_BUILD="$(command -v ld)"      || abort 1 "command not found: ld"
             NM_FOR_BUILD="$(command -v nm)"      || abort 1 "command not found: nm"
           SIZE_FOR_BUILD="$(command -v size)"    || abort 1 "command not found: size"
          STRIP_FOR_BUILD="$(command -v strip)"   || abort 1 "command not found: strip"
        STRINGS_FOR_BUILD="$(command -v strings)" || abort 1 "command not found: strings"
        OBJDUMP_FOR_BUILD="$(command -v objdump)" || abort 1 "command not found: objdump"
        OBJCOPY_FOR_BUILD="$(command -v objcopy)" || abort 1 "command not found: objcopy"
        READELF_FOR_BUILD="$(command -v readelf)" || abort 1 "command not found: readelf"
    fi

    PROXIED_CC_FOR_BUILD="$CC_FOR_BUILD"
    PROXIED_CXX_FOR_BUILD="$CXX_FOR_BUILD"
    PROXIED_OBJC_FOR_BUILD="$OBJC_FOR_BUILD"

     CC_FOR_BUILD="$PPKG_CORE_DIR/wrapper-native-cc"
   OBJC_FOR_BUILD="$PPKG_CORE_DIR/wrapper-native-objc"
    CXX_FOR_BUILD="$PPKG_CORE_DIR/wrapper-native-c++"
    CPP_FOR_BUILD="$CC_FOR_BUILD -E"

    #########################################################################################

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
          CFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
       OBJCFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
        CXXFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
        CPPFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -Qunused-arguments"
         LDFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH"
    else
          CFLAGS_FOR_BUILD="-fPIC -fno-common"
       OBJCFLAGS_FOR_BUILD="-fPIC -fno-common"
        CXXFLAGS_FOR_BUILD="-fPIC -fno-common"
        CPPFLAGS_FOR_BUILD=
        # https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html
         LDFLAGS_FOR_BUILD="-Wl,--as-needed -Wl,-z,muldefs -Wl,--allow-multiple-definition"
    fi

    if [ "$LOG_LEVEL" -ge 3 ] ; then
          CFLAGS_FOR_BUILD="$CFLAGS_FOR_BUILD -v"
        CXXFLAGS_FOR_BUILD="$CXXFLAGS_FOR_BUILD -v"
       OBJCFLAGS_FOR_BUILD="$OBJCFLAGS_FOR_BUILD -v"
         LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -Wl,-v"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
          CFLAGS_FOR_BUILD="$CFLAGS_FOR_BUILD -Os"
        CXXFLAGS_FOR_BUILD="$CXXFLAGS_FOR_BUILD -Os"
       OBJCFLAGS_FOR_BUILD="$OBJCFLAGS_FOR_BUILD -Os"
         LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -Wl,-S"
    fi

    case $NATIVE_OS_KIND in
        netbsd)  LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -lpthread" ;;
        openbsd) LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -lpthread" ;;
    esac

    #########################################################################################

    for TOOL in PROXIED_CC PROXIED_CXX PROXIED_OBJC 
    do
        export "${TOOL}_FOR_BUILD"
        printf "%21s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$"${TOOL}_FOR_BUILD")"
    done

    for TOOL in CC OBJC CXX CPP AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP OBJCOPY READELF SYSROOT CFLAGS OBJCFLAGS CXXFLAGS CPPFLAGS LDFLAGS
    do
        export "${TOOL}_FOR_BUILD"
        printf "%21s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$"${TOOL}_FOR_BUILD")"
    done

    #########################################################################################

    # DO NOT use these environment variables

    unset LIBS

    # autoreconf --help

    unset AUTOCONF
    unset AUTOHEADER
    unset AUTOM4TE
    unset AUTOMAKE
    unset AUTOPOINT
    unset ACLOCAL
    unset GTKDOCIZE
    unset INTLTOOLIZE
    unset LIBTOOLIZE
    unset M4
    unset MAKE

    # https://cmake.org/cmake/help/latest/envvar/MACOSX_DEPLOYMENT_TARGET.html
    unset   MACOSX_DEPLOYMENT_TARGET
    unset IPHONEOS_DEPLOYMENT_TARGET
    unset  WATCHOS_DEPLOYMENT_TARGET

    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    # https://keith.github.io/xcode-man-pages/xcrun.1.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_SYSROOT.html
    unset SDKROOT

    # https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html#manual:cmake-env-variables(7)

    unset CMAKE_APPBUNDLE_PATH
    unset CMAKE_FRAMEWORK_PATH
    unset CMAKE_PROGRAM_PATH
    unset CMAKE_INCLUDE_PATH
    unset CMAKE_LIBRARY_PATH
    unset CMAKE_PREFIX_PATH
    unset CMAKE_MAXIMUM_RECURSION_DEPTH
    unset CMAKE_APPLE_SILICON_PROCESSOR
    unset CMAKE_BUILD_PARALLEL_LEVEL
    unset CMAKE_BUILD_TYPE
    unset CMAKE_CONFIGURATION_TYPES
    unset CMAKE_CONFIG_TYPE
    unset CMAKE_EXPORT_COMPILE_COMMANDS
    unset CMAKE_GENERATOR
    unset CMAKE_GENERATOR_INSTANCE
    unset CMAKE_GENERATOR_PLATFORM
    unset CMAKE_GENERATOR_TOOLSET
    unset CMAKE_INSTALL_MODE
    unset CMAKE_C_COMPILER_LAUNCHER
    unset CMAKE_C_LINKER_LAUNCHER
    unset CMAKE_CXX_COMPILER_LAUNCHER
    unset CMAKE_CXX_LINKER_LAUNCHER
    unset CMAKE_MSVCIDE_RUN_PATH
    unset CMAKE_NO_VERBOSE
    unset CMAKE_OSX_ARCHITECTURES
    unset CMAKE_TOOLCHAIN_FILE
    unset DESTDIR
    unset VERBOSE
    unset CTEST_INTERACTIVE_DEBUG_MODE
    unset CTEST_OUTPUT_ON_FAILURE
    unset CTEST_PARALLEL_LEVEL
    unset CTEST_PROGRESS_OUTPUT
    unset CTEST_USE_LAUNCHERS_DEFAULT
    unset DASHBOARD_TEST_FROM_CTEST

    # https://cmake.org/cmake/help/latest/envvar/CMAKE_BUILD_PARALLEL_LEVEL.html
    export CMAKE_BUILD_PARALLEL_LEVEL="$BUILD_NJOBS"

    # https://cmake.org/cmake/help/latest/envvar/CMAKE_EXPORT_COMPILE_COMMANDS.html
    if [ "$EXPORT_COMPILE_COMMANDS_JSON" = 1 ] ; then
        export CMAKE_EXPORT_COMPILE_COMMANDS=ON
    else
        export CMAKE_EXPORT_COMPILE_COMMANDS=OFF
    fi

    case $BUILD_TYPE in
        debug)   CMAKE_BUILD_TYPE=Debug   ;;
        release) CMAKE_BUILD_TYPE=Release ;;
    esac

    if [ "$LOG_LEVEL" -eq 0 ] ; then
        CMAKE_VERBOSE_MAKEFILE=OFF
        CMAKE_COLOR_MAKEFILE=OFF
    else
        CMAKE_VERBOSE_MAKEFILE=ON
        CMAKE_COLOR_MAKEFILE=ON
    fi

    # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
    if [ "$LOG_LEVEL" -ge 3 ] ; then
        CMAKE_FIND_DEBUG_MODE=ON
    else
        CMAKE_FIND_DEBUG_MODE=OFF
    fi

    run env
}

__inspect_toolchain_config_file() {
    return 0
    [ -z "$1" ] && abort 1 "__inspect_toolchain_config_file <TOOLCHAIN_CONFIG_FILEPATH>, <TOOLCHAIN_CONFIG_FILEPATH> is unspecified."

    TOOLCHAIN_CONFIG_FILEPATH="$1"

    unset TOOLCHAIN_CONFIG_CC
    unset TOOLCHAIN_CONFIG_CXX
    unset TOOLCHAIN_CONFIG_CPP
    unset TOOLCHAIN_CONFIG_AS
    unset TOOLCHAIN_CONFIG_AR
    unset TOOLCHAIN_CONFIG_RANLIB
    unset TOOLCHAIN_CONFIG_LD
    unset TOOLCHAIN_CONFIG_NM
    unset TOOLCHAIN_CONFIG_STRIP
    unset TOOLCHAIN_CONFIG_SIZE
    unset TOOLCHAIN_CONFIG_STRINGS
    unset TOOLCHAIN_CONFIG_OBJDUMP
    unset TOOLCHAIN_CONFIG_OBJCOPY
    unset TOOLCHAIN_CONFIG_READELF
    unset TOOLCHAIN_CONFIG_ADDR2LINE

    unset TOOLCHAIN_CONFIG_CCFLAGS
    unset TOOLCHAIN_CONFIG_XXFLAGS
    unset TOOLCHAIN_CONFIG_PPFLAGS
    unset TOOLCHAIN_CONFIG_LDFLAGS

    #######################################################################################################

    for KEY in cc cxx cpp as ar ranlib ld nm size strip strings objdump objcopy readelf addr2line ccflags xxflags ppflags ldflags
    do
        VALUE=
        VALUE="$(yq ".$KEY" "$TOOLCHAIN_CONFIG_FILEPATH")"

        if [ "$VALUE" != null ] ; then
            case $KEY in
                ccflags|xxflags|ppflags|ldflags) ;;
                *)  [ -e "$VALUE" ] || abort 1 "$KEY: $VALUE file does not exist."
                    [ -x "$VALUE" ] || abort 1 "$KEY: $VALUE file is not a executable."
            esac

            unset KEY_UPPERCASE_UNDERSCORE
            KEY_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$KEY" | tr '-' '_' | tr a-z A-Z)"
            eval "TOOLCHAIN_CONFIG_$KEY_UPPERCASE_UNDERSCORE='$VALUE'"
        fi
    done

    cat <<EOF
cc:        $TOOLCHAIN_CONFIG_CC
cxx:       $TOOLCHAIN_CONFIG_CXX
cpp:       $TOOLCHAIN_CONFIG_CPP
as:        $TOOLCHAIN_CONFIG_AS
ar:        $TOOLCHAIN_CONFIG_AR
ranlib:    $TOOLCHAIN_CONFIG_RANLIB
ld:        $TOOLCHAIN_CONFIG_LD
nm:        $TOOLCHAIN_CONFIG_NM
strip:     $TOOLCHAIN_CONFIG_STRIP
size:      $TOOLCHAIN_CONFIG_SIZE
strings:   $TOOLCHAIN_CONFIG_STRINGS
objdump:   $TOOLCHAIN_CONFIG_OBJDUMP
objcopy:   $TOOLCHAIN_CONFIG_OBJCOPY
readelf:   $TOOLCHAIN_CONFIG_READELF
addr2line: $TOOLCHAIN_CONFIG_ADDR2LINE

ccflags: $TOOLCHAIN_CONFIG_CCFLAGS
xxflags: $TOOLCHAIN_CONFIG_XXFLAGS
ppflags: $TOOLCHAIN_CONFIG_PPFLAGS
ldflags: $TOOLCHAIN_CONFIG_LDFLAGS
EOF
}

# }}}
##############################################################################
# {{{ __install_native_package

# this function must run in subshell
# __install_native_package <PACKAGE-NAME>
  __install_native_package() {
    case $1 in
        '') abort 1 "__install_native_package <PACKAGE-NAME> , <PACKAGE-NAME> is unspecified."
            ;;
        expat)
            NATIVE_PACKAGE_SRC_URL='https://github.com/libexpat/libexpat/releases/download/R_2_5_0/expat-2.5.0.tar.xz'
            NATIVE_PACKAGE_SRC_SHA='ef2420f0232c087801abf705e89ae65f6257df6b7931d37846a193ef2e8cdcbe'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='cmake'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='-DEXPAT_BUILD_DOCS=OFF -DEXPAT_BUILD_TESTS=OFF -DEXPAT_BUILD_FUZZERS=OFF -DEXPAT_BUILD_EXAMPLES=OFF -DEXPAT_BUILD_TOOLS=OFF'
            ;;
        zlib)
            NATIVE_PACKAGE_SRC_URL='https://zlib.net/fossils/zlib-1.3.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='ff0ba4c292013dbc27530b3a81e1f9a813cd39de01ca5e0f8bf355702efa593e'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='cmake'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS=
            ;;
        libbz2)
            NATIVE_PACKAGE_SRC_URL='https://github.com/leleliu008/bzip2/archive/refs/tags/1.0.8.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='fb36d769189faaf841390fae88639fb02c79b87b0691a340fbbfc32b4f82b789'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='cmake'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='-DINSTALL_EXECUTABLES=OFF -DINSTALL_LIBRARIES=ON -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF'
            ;;
        perl)
            NATIVE_PACKAGE_SRC_URL='https://cpan.metacpan.org/authors/id/R/RJ/RJBS/perl-5.38.0.tar.xz'
            NATIVE_PACKAGE_SRC_SHA='eca551caec3bc549a4e590c0015003790bdd1a604ffe19cc78ee631d51f7072e'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS=
            ;;
        openssl)
            NATIVE_PACKAGE_SRC_URL='https://www.openssl.org/source/openssl-3.1.1.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='b3aa61334233b852b63ddb048df181177c2c659eb9d4376008118f9c08d07674'
            NATIVE_PACKAGE_DEPENDENCIES='perl'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS=
            ;;
        texinfo)
            NATIVE_PACKAGE_SRC_URL='https://ftp.gnu.org/gnu/texinfo/texinfo-7.1.tar.xz'
            NATIVE_PACKAGE_SRC_SHA='deeec9f19f159e046fdf8ad22231981806dac332cc372f1c763504ad82b30953'
            NATIVE_PACKAGE_DEPENDENCIES='perl'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--with-included-regex --enable-threads=posix --disable-nls'
            ;;
        help2man)
            NATIVE_PACKAGE_SRC_URL='https://ftp.gnu.org/gnu/help2man/help2man-1.49.3.tar.xz'
            NATIVE_PACKAGE_SRC_SHA='4d7e4fdef2eca6afe07a2682151cea78781e0a4e8f9622142d9f70c083a2fd4f'
            NATIVE_PACKAGE_DEPENDENCIES='perl'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS=
            ;;
        intltool)
            NATIVE_PACKAGE_SRC_URL='https://launchpad.net/intltool/trunk/0.51.0/+download/intltool-0.51.0.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='67c74d94196b153b774ab9f89b2fa6c6ba79352407037c8c14d5aeb334e959cd'
            NATIVE_PACKAGE_DEPENDENCIES='perl expat perl-XML-Parser'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS=
            ;;
        libtool)
            NATIVE_PACKAGE_SRC_URL='https://ftp.gnu.org/gnu/libtool/libtool-2.4.7.tar.xz'
            NATIVE_PACKAGE_SRC_SHA='4f7f217f057ce655ff22559ad221a0fd8ef84ad1fc5fcb6990cecc333aa1635d'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--enable-ltdl-install'
            ;;
        autoconf)
            NATIVE_PACKAGE_SRC_URL='https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='431075ad0bf529ef13cb41e9042c542381103e80015686222b8a9d4abef42a1c'
            NATIVE_PACKAGE_DEPENDENCIES='perl'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS=
            ;;
        automake)
            NATIVE_PACKAGE_SRC_URL='https://ftp.gnu.org/gnu/automake/automake-1.16.5.tar.xz'
            NATIVE_PACKAGE_SRC_SHA='f01d58cd6d9d77fbdca9eb4bbd5ead1988228fdb73d6f7a201f5f8d6b118b469'
            NATIVE_PACKAGE_DEPENDENCIES='perl autoconf'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS=
            ;;
        liblzma)
            NATIVE_PACKAGE_SRC_URL='https://github.com/tukaani-project/xz/releases/download/v5.4.4/xz-5.4.4.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='aae39544e254cfd27e942d35a048d592959bd7a79f9a624afb0498bb5613bdf8'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --disable-nls --enable-largefile --disable-xz --disable-xzdec --disable-lzmadec --disable-lzmainfo --disable-lzma-links --disable-scripts --disable-doc'
            ;;
        gdbm)
            NATIVE_PACKAGE_SRC_URL='https://ftp.gnu.org/gnu/gdbm/gdbm-1.23.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='74b1081d21fff13ae4bd7c16e5d6e504a4c26f7cde1dca0d963a484174bbcacd'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --disable-nls --enable-largefile --enable-libgdbm-compat --without-readline'
            ;;
        sqlite3)
            NATIVE_PACKAGE_SRC_URL='https://www.sqlite.org/2023/sqlite-autoconf-3440000.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='b9cd386e7cd22af6e0d2a0f06d0404951e1bef109e42ea06cc0450e10cd15550'
            NATIVE_PACKAGE_DEPENDENCIES='zlib'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --enable-largefile --disable-editline --disable-readline'
            ;;
        libffi)
            NATIVE_PACKAGE_SRC_URL='https://github.com/libffi/libffi/releases/download/v3.4.4/libffi-3.4.4.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='d66c56ad259a82cf2a9dfc408b32bf5da52371500b84745f7fb8b645712df676'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --disable-docs --disable-symvers'
            ;;
        libyaml)
            NATIVE_PACKAGE_SRC_URL='https://github.com/yaml/libyaml/releases/download/0.2.5/yaml-0.2.5.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='c642ae9b75fee120b2d96c712538bd2cf283228d2337df2cf2988e3c02678ef4'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --enable-largefile'
            ;;
        ruby)
            NATIVE_PACKAGE_SRC_URL='https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.2.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='96c57558871a6748de5bc9f274e93f4b5aad06cd8f37befa0e8d94e7b8a423bc'
            NATIVE_PACKAGE_DEPENDENCIES='zlib libyaml libffi'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --enable-shared --disable-docs'
            ;;
        python3)
            NATIVE_PACKAGE_SRC_URL='https://www.python.org/ftp/python/3.11.6/Python-3.11.6.tgz'
            NATIVE_PACKAGE_SRC_SHA='c049bf317e877cbf9fce8c3af902436774ecef5249a29d10984ca3a37f7f4736'
            NATIVE_PACKAGE_DEPENDENCIES='zlib libbz2 liblzma gdbm expat sqlite3 libffi openssl perl'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS="--with-system-expat --with-system-ffi --with-openssl=$NATIVE_PACKAGE_INSTALLED_ROOT/openssl --with-ensurepip=yes --with-lto --enable-ipv6 --enable-shared --enable-largefile --disable-option-checking --disable-nls --disable-debug --disable-loadable-sqlite-extensions --disable-profiling"
            ;;
        perl-XML-Parser)
            NATIVE_PACKAGE_SRC_URL='https://cpan.metacpan.org/authors/id/T/TO/TODDR/XML-Parser-2.46.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='d331332491c51cccfb4cb94ffc44f9cd73378e618498d4a37df9e043661c515d'
            NATIVE_PACKAGE_DEPENDENCIES='perl expat'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS=
            ;;
        libpcre2)
            NATIVE_PACKAGE_SRC_URL='https://github.com/PCRE2Project/pcre2/releases/download/pcre2-10.42/pcre2-10.42.tar.bz2'
            NATIVE_PACKAGE_SRC_SHA='8d36cd8cb6ea2a4c2bb358ff6411b0c788633a2a45dabbf1aeb4b701d1b5e840'
            NATIVE_PACKAGE_DEPENDENCIES=
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='cmake'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='-DCMAKE_C_STANDARD=99 -DCMAKE_C_STANDARD_REQUIRED=ON -DPCRE2_BUILD_PCRE2_8=ON -DPCRE2_BUILD_PCRE2_16=ON -DPCRE2_BUILD_PCRE2_32=ON -DPCRE2_BUILD_PCRE2GREP=OFF -DPCRE2_BUILD_TESTS=OFF -DPCRE2_DEBUG=OFF -DPCRE2_SUPPORT_VALGRIND=OFF -DPCRE2_SUPPORT_UNICODE=ON'
            ;;
        swig)
            NATIVE_PACKAGE_SRC_URL='https://downloads.sourceforge.net/project/swig/swig/swig-4.1.1/swig-4.1.1.tar.gz'
            NATIVE_PACKAGE_SRC_SHA='2af08aced8fcd65cdb5cc62426768914bedc735b1c250325203716f78e39ac9b'
            NATIVE_PACKAGE_DEPENDENCIES='libpcre2'
            NATIVE_PACKAGE_USE_BSYSTEM_NAME='configure'
            NATIVE_PACKAGE_BUILD_CONFIG_ARGS='--enable-ccache --enable-cpp11-testing --with-popen --with-pcre --without-boost --without-android --without-java --without-javascript --without-python --without-perl5 --without-ruby --without-php --without-tcl --without-guile --without-octave --without-scilab --without-ocaml --without-mzscheme --without-csharp --without-lua --without-r --without-d --without-go'
            ;;
        *)  abort 1 "unknown native package name: $1"
    esac

    #########################################################################################

    for NATIVE_PACKAGE_DEPENDENCY in $NATIVE_PACKAGE_DEPENDENCIES
    do
        (__install_native_package "$NATIVE_PACKAGE_DEPENDENCY")
    done

    #########################################################################################

    step "install native package : $1"

    NATIVE_PACKAGE_INSTALLED_DIR="$NATIVE_PACKAGE_INSTALLED_ROOT/$1"

    if [ -f "$NATIVE_PACKAGE_INSTALLED_DIR/receipt.txt" ] && [ "$(cat "$NATIVE_PACKAGE_INSTALLED_DIR/receipt.txt")" = "$NATIVE_PACKAGE_SRC_SHA" ] ; then
        note "native package '$1' already has been installed, skipped."
        return 0
    fi

    #########################################################################################

    NATIVE_PACKAGE_INSTALL_UTS=
    NATIVE_PACKAGE_INSTALL_UTS="$(date +%s)"

    NATIVE_PACKAGE_INSTALL_SHA=
    NATIVE_PACKAGE_INSTALL_SHA="$(
{
    sha256sum <<EOF
$1:$NATIVE_PACKAGE_SRC_URL:$$:$NATIVE_PACKAGE_INSTALL_UTS
EOF
} | cut -d ' ' -f1)"

    #########################################################################################

    NATIVE_PACKAGE_INSTALL_DIR="$NATIVE_PACKAGE_INSTALLED_ROOT/$NATIVE_PACKAGE_INSTALL_SHA"

    NATIVE_PACKAGE_SRC_FILETYPE="$(filetype_from_url "$NATIVE_PACKAGE_SRC_URL")"
    NATIVE_PACKAGE_SRC_FILENAME="$NATIVE_PACKAGE_SRC_SHA$NATIVE_PACKAGE_SRC_FILETYPE"
    NATIVE_PACKAGE_SRC_FILEPATH="$PPKG_DOWNLOADS_DIR/$NATIVE_PACKAGE_SRC_FILENAME"

    NATIVE_PACKAGE_WORKING_DIR="$PACKAGE_WORKING_DIR/native/$1"

    #########################################################################################

    # override the default search directory (usually /usr/lib/pkgconfig:/usr/share/pkgconfig)
    # because we only want to use our own
    export PKG_CONFIG_LIBDIR="$NATIVE_PACKAGE_WORKING_DIR/lib/pkgconfig"
    export PKG_CONFIG_PATH="$NATIVE_PACKAGE_WORKING_DIR/lib/pkgconfig"
    export ACLOCAL_PATH="$NATIVE_PACKAGE_WORKING_DIR/share/aclocal"
    export CPPFLAGS="-I$NATIVE_PACKAGE_WORKING_DIR/include $CPPFLAGS"
    export LDFLAGS="-L$NATIVE_PACKAGE_WORKING_DIR/lib -Wl,-rpath,$NATIVE_PACKAGE_INSTALL_DIR/lib $LDFLAGS"

    for DEPENDENT_NATIVE_PACKAGE_NAME in $NATIVE_PACKAGE_DEPENDENCIES
    do
        DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR="$NATIVE_PACKAGE_INSTALLED_ROOT/$DEPENDENT_NATIVE_PACKAGE_NAME"

        if [ -d  "$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/include" ] ; then
            CPPFLAGS="$CPPFLAGS -I$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/include"
        fi

        if [ -d  "$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/lib" ] ; then
            LDFLAGS="$LDFLAGS -L$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/lib -Wl,-rpath,$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/lib"
        fi

        if [ -d  "$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/bin" ] ; then
            PATH="$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/bin:$PATH"
        fi

        if [ -d  "$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/sbin" ] ; then
            PATH="$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/sbin:$PATH"
        fi

        if [ -d          "$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
            ACLOCAL_PATH="$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/share/aclocal:$ACLOCAL_PATH"
        fi

        for d in lib share
        do
            DEPENDENT_NATIVE_PACKAGE_PKGCONF_DIR="$DEPENDENT_NATIVE_PACKAGE_INSTALLED_DIR/$d/pkgconfig"

            if [ -d "$DEPENDENT_NATIVE_PACKAGE_PKGCONF_DIR" ] ; then
                PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$DEPENDENT_NATIVE_PACKAGE_PKGCONF_DIR"
            fi
        done
    done

    #########################################################################################

    cat <<EOF
PKG_CONFIG_LIBDIR=$PKG_CONFIG_LIBDIR

PKG_CONFIG_PATH=$PKG_CONFIG_PATH

ACLOCAL_PATH=$ACLOCAL_PATH

PATH=$PATH

NATIVE_PACKAGE_SRC_URL      = $NATIVE_PACKAGE_SRC_URL
NATIVE_PACKAGE_SRC_SHA      = $NATIVE_PACKAGE_SRC_SHA
NATIVE_PACKAGE_SRC_FILENAME = $NATIVE_PACKAGE_SRC_FILENAME
NATIVE_PACKAGE_SRC_FILETYPE = $NATIVE_PACKAGE_SRC_FILETYPE

NATIVE_PACKAGE_DEPENDENCIES = $NATIVE_PACKAGE_DEPENDENCIES

NATIVE_PACKAGE_USE_BSYSTEM_NAME = $NATIVE_PACKAGE_USE_BSYSTEM_NAME
NATIVE_PACKAGE_BUILD_CONFIG_ARGS = $NATIVE_PACKAGE_BUILD_CONFIG_ARGS

NATIVE_PACKAGE_WORKING_DIR = $NATIVE_PACKAGE_WORKING_DIR
NATIVE_PACKAGE_INSTALL_UTS = $NATIVE_PACKAGE_INSTALL_UTS
NATIVE_PACKAGE_INSTALL_SHA = $NATIVE_PACKAGE_INSTALL_SHA
NATIVE_PACKAGE_INSTALL_DIR = $NATIVE_PACKAGE_INSTALL_DIR

EOF

    #########################################################################################

    run install -d "$NATIVE_PACKAGE_WORKING_DIR/src"
    run cd         "$NATIVE_PACKAGE_WORKING_DIR"

    wfetch "$NATIVE_PACKAGE_SRC_URL" --sha256="$NATIVE_PACKAGE_SRC_SHA" -o "$NATIVE_PACKAGE_SRC_FILEPATH"

    run bsdtar xvf "$NATIVE_PACKAGE_SRC_FILEPATH" --strip-components=1 --no-same-owner -C src

    run cd src

    if   [ "$1" = 'zlib' ] ; then
        sed_in_place 's|/share/pkgconfig|/lib/pkgconfig|' CMakeLists.txt
    elif [ "$1" = 'texinfo' ] ; then
        sed_in_place '/libintl/d' tp/Texinfo/XS/parsetexi/api.c
    elif [ "$1" = 'python3' ] ; then
        unset PYTHONHOME
        unset PYTHONPATH

        export ZLIB_CFLAGS="-I$NATIVE_PACKAGE_INSTALLED_ROOT/zlib/include"
        export ZLIB_LIBS="-L$NATIVE_PACKAGE_INSTALLED_ROOT/zlib/lib -lz"

        export BZIP2_CFLAGS="-I$NATIVE_PACKAGE_INSTALLED_ROOT/libbz2/include"
        export BZIP2_LIBS="-L$NATIVE_PACKAGE_INSTALLED_ROOT/libbz2/lib -lbz2"

        export LIBLZMA_CFLAGS="-I$NATIVE_PACKAGE_INSTALLED_ROOT/liblzma/include"
        export LIBLZMA_LIBS="-L$NATIVE_PACKAGE_INSTALLED_ROOT/liblzma/lib -llzma"

        export LIBSQLITE3_CFLAGS="-I$NATIVE_PACKAGE_INSTALLED_ROOT/sqlite3/include"
        export LIBSQLITE3_LIBS="-L$NATIVE_PACKAGE_INSTALLED_ROOT/sqlite3/lib -lsqlite3"

        export GDBM_CFLAGS="-I$NATIVE_PACKAGE_INSTALLED_ROOT/gdbm/include"
        export GDBM_LIBS="-L$NATIVE_PACKAGE_INSTALLED_ROOT/gdbm/lib -lgdbm -lgdbm_compat"

        export LIBS='-lm'
    fi

    #########################################################################################

    case $NATIVE_PACKAGE_USE_BSYSTEM_NAME in
        cmake)
            CMAKE="$(command -v cmake)" || abort 1 "command not found: cmake"

            run "$CMAKE" -DCMAKE_INSTALL_PREFIX="$NATIVE_PACKAGE_INSTALL_DIR" -DCMAKE_INSTALL_LIBDIR=lib -DBUILD_SHARED_LIBS=ON "$NATIVE_PACKAGE_BUILD_CONFIG_ARGS -G 'Unix Makefiles'" -S . -B build.d
            run "$CMAKE" --build   build.d -- -j$BUILD_NJOBS
            run "$CMAKE" --install build.d
            ;;
        configure)
            if [ "$1" = openssl ] ; then
                # https://github.com/openssl/openssl/blob/master/INSTALL.md
                run ./config no-tests no-ssl3 no-ssl3-method no-zlib --prefix="$NATIVE_PACKAGE_INSTALL_DIR" --libdir=lib --openssldir=etc/ssl

                GMAKE="$(command -v gmake)" || abort 1 "command not found: gmake"

                run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                run "$GMAKE" install_sw
            else
                case $1 in
                    perl)
                        run ./Configure "-Dprefix=$NATIVE_PACKAGE_INSTALL_DIR" -Dman1dir=none -Dman3dir=none -des -Dmake=gmake -Duselargefiles -Duseshrplib -Dusethreads -Dusenm=false -Dusedl=true
                        ;;
                    perl-XML-Parser)
                        run perl Makefile.PL EXPATLIBPATH="$NATIVE_PACKAGE_INSTALLED_ROOT/expat/lib" EXPATINCPATH="$NATIVE_PACKAGE_INSTALLED_ROOT/expat/include"
                        run install -d "$NATIVE_PACKAGE_INSTALL_DIR"
                        ;;
                    *)  run ./configure "--prefix=$NATIVE_PACKAGE_INSTALL_DIR" "$NATIVE_PACKAGE_BUILD_CONFIG_ARGS"
                esac

                GMAKE="$(command -v gmake)" || abort 1 "command not found: gmake"

                run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                run "$GMAKE" install
            fi
            ;;
    esac

    printf '%s\n' "$NATIVE_PACKAGE_SRC_SHA" > "$NATIVE_PACKAGE_INSTALL_DIR/receipt.txt"

    run ln -s -r -f -T "$NATIVE_PACKAGE_INSTALLED_ROOT/$NATIVE_PACKAGE_INSTALL_SHA" "$NATIVE_PACKAGE_INSTALLED_ROOT/$1"
}

# }}}
##############################################################################
# {{{ __install_the_given_package

__install_the_given_package_onexit() {
    if [ "$DRYRUN" != 1 ] ; then
        is_package_installed "$PACKAGE_SPEC" || {
            if [ -n "$PACKAGE_WORKING_DIR" ] ; then
                abort 1 "package installation failure: $PACKAGE_SPEC, if you want to figure out what had happeded, please change to the working directory: $PACKAGE_WORKING_DIR"
            else
                abort 1 "package installation failure: $PACKAGE_SPEC\n"
            fi
        }
    fi
}

# Note: this function must run in a subshell
__install_the_given_package() {
    printf '%b\n' "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}${1}${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"

    unset PACKAGE_WORKING_DIR

    trap  __install_the_given_package_onexit EXIT

    #########################################################################################

    STATIC_LIBRARY_SUFFIX='.a'

    if [ "$TARGET_PLATFORM_NAME" = macos ] ; then
        SHARED_LIBRARY_SUFFIX='.dylib'
    else
        SHARED_LIBRARY_SUFFIX='.so'
    fi

    #########################################################################################

    if [ "$NATIVE_OS_KIND" = linux ] ; then
        NATIVE_OS_SPEC="$NATIVE_OS_TYPE-$NATIVE_OS_LIBC-$NATIVE_OS_ARCH"
    else
        NATIVE_OS_SPEC="$NATIVE_OS_TYPE-$NATIVE_OS_VERS-$NATIVE_OS_ARCH"
    fi

    if [ "$TARGET_PLATFORM_SPEC" = "$NATIVE_OS_SPEC" ] ; then
        CROSS_COMPILING=0
    else
        CROSS_COMPILING=1
    fi

    #########################################################################################

    cat <<EOF
     TIMESTAMP_UNIX = $TIMESTAMP_UNIX

     NATIVE_OS_KIND = $NATIVE_OS_KIND
     NATIVE_OS_TYPE = $NATIVE_OS_TYPE
     NATIVE_OS_NAME = $NATIVE_OS_NAME
     NATIVE_OS_VERS = $NATIVE_OS_VERS
     NATIVE_OS_ARCH = $NATIVE_OS_ARCH
     NATIVE_OS_NCPU = $NATIVE_OS_NCPU
     NATIVE_OS_LIBC = $NATIVE_OS_LIBC
     NATIVE_OS_EUID = $NATIVE_OS_EUID
     NATIVE_OS_EGID = $NATIVE_OS_EGID

TARGET_PLATFORM_NAME= $TARGET_PLATFORM_NAME
TARGET_PLATFORM_VERS= $TARGET_PLATFORM_VERS
TARGET_PLATFORM_ARCH= $TARGET_PLATFORM_ARCH

    CROSS_COMPILING = $CROSS_COMPILING

PPKG_VERSION        = $PPKG_VERSION
PPKG_HOME           = $PPKG_HOME
PPKG                = $PPKG
PPKG_URL_TRANSFORM  = $PPKG_URL_TRANSFORM

          LOG_LEVEL = $LOG_LEVEL
         BUILD_TYPE = $BUILD_TYPE

             DRYRUN = $DRYRUN
     CCACHE_ENABLED = $CCACHE_ENABLED
   KEEP_SESSION_DIR = $KEEP_SESSION_DIR
EXPORT_COMPILE_COMMANDS_JSON = $EXPORT_COMPILE_COMMANDS_JSON
EOF

    #########################################################################################

    if [ "$LINK_TYPE" = 'static-full' ] && [ "$TARGET_PLATFORM_NAME" = macos ] ; then
        die "macOS does not support fully static linking, please use static-most instead."
    fi

    #########################################################################################

    step "create the working directory and change to it"

    PACKAGE_WORKING_DIR="$SESSION_DIR/$PACKAGE_NAME"
    PACKAGE_BCACHED_DIR="$PACKAGE_WORKING_DIR/src/_"

    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_WORKING_DIR/src"
    PACKAGE_INSTALLING_FIX_DIR="$PACKAGE_WORKING_DIR/fix"
    PACKAGE_INSTALLING_RES_DIR="$PACKAGE_WORKING_DIR/res"
    PACKAGE_INSTALLING_BIN_DIR="$PACKAGE_WORKING_DIR/bin"
    PACKAGE_INSTALLING_LIB_DIR="$PACKAGE_WORKING_DIR/lib"
    PACKAGE_INSTALLING_INC_DIR="$PACKAGE_WORKING_DIR/include"

    install -d "$PACKAGE_INSTALLING_SRC_DIR"
    install -d "$PACKAGE_INSTALLING_FIX_DIR"
    install -d "$PACKAGE_INSTALLING_RES_DIR"
    install -d "$PACKAGE_INSTALLING_BIN_DIR"
    install -d "$PACKAGE_INSTALLING_INC_DIR"
    install -d "$PACKAGE_INSTALLING_LIB_DIR"
    install -d "$PACKAGE_BCACHED_DIR"

    cd "$PACKAGE_WORKING_DIR"

    #########################################################################################

    PACKAGE_INSTALL_UTS=
    PACKAGE_INSTALL_UTS="$(date +%s)"

    PACKAGE_INSTALL_SHA=
    PACKAGE_INSTALL_SHA="$(
{
    sha256sum <<EOF
$PACKAGE_NAME:$$:$PACKAGE_INSTALL_UTS
EOF
} | cut -d ' ' -f1)"

    PACKAGE_INSTALL_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_SPEC/$PACKAGE_INSTALL_SHA"

    #########################################################################################

    cat <<EOF
PACKAGE_WORKING_DIR = $PACKAGE_WORKING_DIR
PACKAGE_BCACHED_DIR = $PACKAGE_BCACHED_DIR
PACKAGE_INSTALL_DIR = $PACKAGE_INSTALL_DIR
EOF

    #########################################################################################

    PACKAGE_FORMULA_FILEPATH="$SESSION_DIR/$PACKAGE_NAME.yml"

    step "view formula"
    run yq "$PACKAGE_FORMULA_FILEPATH"
   
    step "load formula"
    __load_formula_of_the_given_package "$PACKAGE_NAME" "$PACKAGE_FORMULA_FILEPATH"

    #########################################################################################

    if [ "$LINK_TYPE" = 'static-full' ] && [ "$PACKAGE_SFSLINK" = 0 ] ; then
        LINK_TYPE='static-most'
        note "user request to create fully statically linked executable, but package '$PACKAGE_NAME' DO NOT support it, so we will downgrade to mostly statically linked executable."
    fi

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = 0 ] ; then
        BUILD_NJOBS=1
    fi

    printf '%s\n' "
        BUILD_NJOBS = $BUILD_NJOBS
          LINK_TYPE = $LINK_TYPE
    "

    #########################################################################################

    unset RECURSIVE_DEPENDENT_PACKAGE_NAMES

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "calculate dependency list of $1"

        unset STACK

        for item in $PACKAGE_DEP_PKG
        do
            if [ -z "$item" ] ; then
                STACK="$item"
            else
                STACK="$STACK;$item"
            fi
        done

        while [ -n "$STACK" ]
        do
            case $STACK in
                *\;*) TOPE="${STACK##*;}" ; STACK="${STACK%;*}" ;;
                *)    TOPE="${STACK}"     ; STACK=
            esac

            RECURSIVE_DEPENDENT_PACKAGE_NAMES2="$TOPE"

            for item in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
            do
                if [ "$item" != "$TOPE" ] ; then
                    RECURSIVE_DEPENDENT_PACKAGE_NAMES2="$RECURSIVE_DEPENDENT_PACKAGE_NAMES2 $item"
                fi
            done

            RECURSIVE_DEPENDENT_PACKAGE_NAMES="$RECURSIVE_DEPENDENT_PACKAGE_NAMES2"

            unset TOPE_UPPERCASE_UNDERSCORE
            TOPE_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$TOPE" | tr '@+-.' '_' | tr a-z A-Z)

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${TOPE_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$item" ] ; then
                    STACK="$item"
                else
                    STACK="$STACK;$item"
                fi
            done
        done

        printf '%s\n' "$RECURSIVE_DEPENDENT_PACKAGE_NAMES"
    }

    #########################################################################################

    unset RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS

    [ -n "$PACKAGE_DEP_PKG" ] && {
        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            DEPENDENT_PACKAGE_INSTALL_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_SPEC/$DEPENDENT_PACKAGE_NAME"

            if [ -z "$RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS" ] ; then
                RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR"
            else
                RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS="$RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS $DEPENDENT_PACKAGE_INSTALL_DIR"
            fi

            if [ "$CROSS_COMPILING" = 1 ] ; then
                DEPENDENT_PACKAGE_BINARY__DIR="$NATIVE_PACKAGE_INSTALLED_ROOT/$DEPENDENT_PACKAGE_NAME/bin"

                if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                    PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
                fi

                DEPENDENT_PACKAGE_BINARY__DIR="$NATIVE_PACKAGE_INSTALLED_ROOT/$DEPENDENT_PACKAGE_NAME/sbin"

                if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                    PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
                fi

                if [ -d          "$NATIVE_PACKAGE_INSTALLED_ROOT/$DEPENDENT_PACKAGE_NAME/share/aclocal" ] ; then
                    ACLOCAL_PATH="$NATIVE_PACKAGE_INSTALLED_ROOT/$DEPENDENT_PACKAGE_NAME/share/aclocal:$ACLOCAL_PATH"
                fi
            else
                DEPENDENT_PACKAGE_BINARY__DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/bin"

                if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                    PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
                fi

                DEPENDENT_PACKAGE_BINARY__DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/sbin"

                if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                    PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
                fi
            fi

            if [ "$DEPENDENT_PACKAGE_NAME" = docbook ] ; then
                # http://xmlsoft.org/xslt/xsltproc.html
                export XML_CATALOG_FILES="$DEPENDENT_PACKAGE_INSTALL_DIR/catalog.xml"
                printf '%s\n' "XML_CATALOG_FILES=$XML_CATALOG_FILES"
            fi
        done
    }

    #########################################################################################

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "generate  dependency tree of $1"

        unset DOT_CONTENT

        STACK="$PACKAGE_NAME"

        while [ -n "$STACK" ]
        do
            case $STACK in
                *\;*) TOPE="${STACK##*;}" ; STACK="${STACK%;*}" ;;
                *)    TOPE="${STACK}"     ; STACK=
            esac

            unset TOPE_UPPERCASE_UNDERSCORE
            TOPE_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$TOPE" | tr '@+-.' '_' | tr a-z A-Z)

            TOPE_DEP_PKG="$(eval echo \$PACKAGE_DEP_PKG_"${TOPE_UPPERCASE_UNDERSCORE}")"

            if [ -n "$TOPE_DEP_PKG" ] ; then
                unset X; X="$(printf '"%s" ' $TOPE_DEP_PKG)"
                unset Y; Y="$(printf '    "%s" -> { %s}\n' "$TOPE" "$X")"

                if [ -z "$DOT_CONTENT" ] ; then
                    DOT_CONTENT="$Y"
                else
                    DOT_CONTENT="$(printf '%s\n%s\n' "$DOT_CONTENT" "$Y")"
                fi
            fi

            for item in $TOPE_DEP_PKG
            do

                if [ -z "$item" ] ; then
                    STACK="$item"
                else
                    STACK="$STACK;$item"
                fi
            done
        done

        DOT_CONTENT="digraph G {
$DOT_CONTENT
}"

        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#

        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT="$PACKAGE_WORKING_DIR/dependencies.dot"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX="$PACKAGE_WORKING_DIR/dependencies.box"

        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#

        printf '%s\n' "$DOT_CONTENT" > "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT"

        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#

        # https://github.com/ggerganov/dot-to-ascii
        curl \
            -o "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX" \
            -s \
            -G \
            --data-urlencode "boxart=1" \
            --data-urlencode "src=$DOT_CONTENT" \
            "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php" || true

        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#

        if command -v dot > /dev/null ; then
            run dot -Tsvg -o "$PACKAGE_WORKING_DIR/dependencies.svg" "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
            run dot -Tpng -o "$PACKAGE_WORKING_DIR/dependencies.png" "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
        fi

        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#

        if [ -f "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX" ] ; then
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX"
        else
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT"
        fi
    }

    #########################################################################################

    # these native packages would be installed by uppm
    PACKAGE_DEP_UPP_T1='pkg-config patchelf tree'

    # these native packages are not relocatable, we should build them from source locally at build time.
    PACKAGE_DEP_UPP_T2=

    for item in $PACKAGE_DEP_UPP
    do
        case $item in
            perl)     PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake"       ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            openssl)  PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake"       ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            texinfo)  PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake"       ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            help2man) PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake"       ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            intltool) PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake cmake" ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            python3)  PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake cmake" ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            ruby)     PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake cmake" ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            swig)     PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake cmake" ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            libtool)  PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake gm4"   ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            autoconf) PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake gm4"   ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            automake) PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 gmake gm4"   ; PACKAGE_DEP_UPP_T2="$PACKAGE_DEP_UPP_T2 $item" ;;
            *)        PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 $item"
        esac
    done

    #########################################################################################

    if [ "$PACKAGE_USE_BSYSTEM_GMAKE" = 1 ] && [ "$EXPORT_COMPILE_COMMANDS_JSON" = 1 ] && [ "$BEAR_ENABLED" = 1 ] ; then
        PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 bear"
    fi

    if [ "$CCACHE_ENABLED" = 1 ] ; then
        PACKAGE_DEP_UPP_T1="$PACKAGE_DEP_UPP_T1 ccache"
    fi

    PACKAGE_DEP_UPP_T1="${PACKAGE_DEP_UPP_T1#' '}"

    #########################################################################################

    [ -n "$PACKAGE_DEP_UPP_T1" ] && {
        PACKAGE_DEP_UPP_T1="$(printf '%s\n' $PACKAGE_DEP_UPP_T1 | sort | uniq)"

        step "install needed packages via uppm"

        run "$UPPM" env
        run "$UPPM" update

        for UPPM_PACKAGE_NAME in $PACKAGE_DEP_UPP_T1
        do
            if [ "$UPPM_PACKAGE_NAME" = cmake ] && [ "$NATIVE_OS_KIND" = netbsd ] ; then
                run $sudo pkgin -y update
                run $sudo pkgin -y install cmake
                continue
            fi

            run "$UPPM" install "$UPPM_PACKAGE_NAME"

            UPPM_PACKAGE_INSTALLED_DIR="$("$UPPM" info "$UPPM_PACKAGE_NAME" installed-dir)"

            if [ -d  "$UPPM_PACKAGE_INSTALLED_DIR/bin" ] ; then
                PATH="$UPPM_PACKAGE_INSTALLED_DIR/bin:$PATH"
            fi

            if [ -d  "$UPPM_PACKAGE_INSTALLED_DIR/sbin" ] ; then
                PATH="$UPPM_PACKAGE_INSTALLED_DIR/sbin:$PATH"
            fi

            if [ -d          "$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
                ACLOCAL_PATH="$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal:$ACLOCAL_PATH"
            fi

            if [ "$UPPM_PACKAGE_NAME" = 'docbook-xsl' ] ; then
                # http://xmlsoft.org/xslt/xsltproc.html
                export XML_CATALOG_FILES="$UPPM_PACKAGE_INSTALLED_DIR/catalog.xml"
                printf '%s\n' "XML_CATALOG_FILES=$XML_CATALOG_FILES"
            fi
        done
    }

    [ -n "$PACKAGE_DEP_UPP_T2" ] && {
        PACKAGE_DEP_UPP_T2="$(printf '%s\n' $PACKAGE_DEP_UPP_T2 | sort | uniq)"

        for NATIVE_PACKAGE_NAME in $PACKAGE_DEP_UPP_T2
        do

            (__install_native_package "$NATIVE_PACKAGE_NAME")

            NATIVE_PACKAGE_INSTALLED_DIR="$NATIVE_PACKAGE_INSTALLED_ROOT/$NATIVE_PACKAGE_NAME"

            if [ -d  "$NATIVE_PACKAGE_INSTALLED_DIR/include" ] ; then
                CPPFLAGS_FOR_BUILD="$CPPFLAGS_FOR_BUILD -I$NATIVE_PACKAGE_INSTALLED_DIR/include"
            fi

            if [ -d  "$NATIVE_PACKAGE_INSTALLED_DIR/lib" ] ; then
                LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -L$NATIVE_PACKAGE_INSTALLED_DIR/lib -Wl,-rpath,$NATIVE_PACKAGE_INSTALLED_DIR/lib"
            fi

            if [ -d  "$NATIVE_PACKAGE_INSTALLED_DIR/bin" ] ; then
                PATH="$NATIVE_PACKAGE_INSTALLED_DIR/bin:$PATH"
            fi

            if [ -d  "$NATIVE_PACKAGE_INSTALLED_DIR/sbin" ] ; then
                PATH="$NATIVE_PACKAGE_INSTALLED_DIR/sbin:$PATH"
            fi

            if [ -d          "$NATIVE_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
                ACLOCAL_PATH="$NATIVE_PACKAGE_INSTALLED_DIR/share/aclocal:$ACLOCAL_PATH"
            fi
        done
    }

    #########################################################################################

    [ -n "$PACKAGE_DEP_PYM" ] && {
        step "install needed python packages via pip3"

        PIP3="$(command -v pip3)" || abort 1 "command not found: pip3"

        run "$PIP3" --version
        run "$PIP3" install --upgrade pip setuptools wheel
        run "$PIP3" --version
        run "$PIP3" install --upgrade "$PACKAGE_DEP_PYM"
    }

    #########################################################################################

    [ -n "$PACKAGE_DEP_PLM" ] && {
        step "install needed perl modules via cpan"

        unset PACKAGE_DEP_PLM_T1
        unset PACKAGE_DEP_PLM_T2

        for item in $PACKAGE_DEP_PLM
        do
            if [ "$item" = 'XML::Parser' ] ; then
                PACKAGE_DEP_PLM_T1='XML::Parser'
            else
                PACKAGE_DEP_PLM_T2="$PACKAGE_DEP_PLM_T2 $item"
            fi
        done

        if [ -n "$PACKAGE_DEP_PLM_T1" ] ; then
            __install_native_package perl-XML-Parser
        fi

        if [ -n "$PACKAGE_DEP_PLM_T2" ] ; then
            PACKAGE_DEP_PLM_T2="${PACKAGE_DEP_PLM_T2# }"
        fi

        if [ -n "$PACKAGE_DEP_PLM_T2" ] ; then
            # Would you like to configure as much as possible automatically? [yes]
            # https://perldoc.perl.org/cpan#PERL_MM_USE_DEFAULT
            export PERL_MM_USE_DEFAULT=1
            run cpan "$PACKAGE_DEP_PLM_T2"
        fi

        if [ -d "$HOME/perl5/bin" ] ; then
            # cpan install to default local location
            bppend_to_PATH "$HOME/perl5/bin"
        fi
    }

    #########################################################################################

    [ "$PACKAGE_USE_BSYSTEM_CARGO" = 1 ] && {
        command -v rustup > /dev/null || {
            # https://www.rust-lang.org/tools/install
            note "${COLOR_GREEN}rustup cargo rustc${COLOR_OFF} ${COLOR_YELLOW}commands are required, but it was not found, let's install it.${COLOR_OFF}"

            wfetch 'https://sh.rustup.rs' -o rustup-init.sh

            run bash rustup-init.sh -y

            export CARGO_HOME="$HOME/.cargo"
            export PATH="$CARGO_HOME/bin:$PATH"
        }
    }

    #########################################################################################
    #                               below is for target                                     #
    #########################################################################################

    step "locate build tools"

    unset AUTORECONF
    unset AUTOCONF
    unset AUTOMAKE
    unset ACLOCAL
    unset PERL
    unset M4

    unset MESON
    unset CMAKE
    unset XMAKE
    unset GMAKE
    unset NINJA

    unset BEAR
    unset CCACHE
    unset PKG_CONFIG

    if [ "$PACKAGE_USE_BSYSTEM_AUTOGENSH" = 1 ] || [ "$PACKAGE_USE_BSYSTEM_AUTOTOOLS" = 1 ] ; then
        AUTORECONF=$(command -v autoreconf) || abort 1 "command not found: autoreconf"
        AUTOCONF=$(command -v autoconf)     || abort 1 "command not found: autoconf"
        AUTOMAKE=$(command -v automake)     || abort 1 "command not found: automake"
        ACLOCAL=$(command -v aclocal)       || abort 1 "command not found: aclocal"
        PERL=$(command -v perl)             || abort 1 "command not found: perl"
        M4=$(command -v m4)                 || abort 1 "command not found: m4"

        run "$AUTORECONF" --version
        printf '\n'
        run "$AUTOCONF"   --version
        printf '\n'
        run "$AUTOMAKE"   --version
        printf '\n'
        run "$ACLOCAL"    --version
        printf '\n'
        run "$PERL"       --version
        printf '\n'
        run "$M4"         --version
        printf '\n'
    fi

    [ "$PACKAGE_USE_BSYSTEM_MESON" = 1 ] && {
        MESON=$(command -v meson) || abort 1 "command not found: meson"
        run "$MESON"      --version
        printf '\n'
    }

    [ "$PACKAGE_USE_BSYSTEM_CMAKE" = 1 ] && {
        CMAKE=$(command -v cmake) || abort 1 "command not found: cmake"
        run "$CMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_USE_BSYSTEM_XMAKE" = 1 ] && {
        XMAKE=$(command -v xmake) || abort 1 "command not found: xmake"

        # error: Running xmake as root is extremely dangerous and no longer supported.
        # As xmake does not drop privileges on installation you would be giving all
        # build scripts full access to your system.
        # Or you can add `--root` option or XMAKE_ROOT=y to allow run as root temporarily.
        export XMAKE_ROOT=y

        run "$XMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_USE_BSYSTEM_GMAKE" = 1 ] && {
        GMAKE=$(command -v gmake || command -v make) || abort 1 "command not found: gmake and make"
        run "$GMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_USE_BSYSTEM_NINJA" = 1 ] && {
        NINJA=$(command -v ninja) || abort 1 "command not found: ninja"
        run "$NINJA"      --version
        printf '\n'
    }

    [ "$PACKAGE_USE_BSYSTEM_CARGO" = 1 ] && {
        RUSTUP=$(command -v rustup) || abort 1 "command not found: rustup"
        CARGO=$(command -v cargo)   || abort 1 "command not found: cargo"
        run "$RUSTUP"     --version
        printf '\n'
        run "$CARGO"      --version
        printf '\n'
    }

    [ "$PACKAGE_USE_BSYSTEM_GO" = 1 ] && {
        GO=$(command -v go) || abort 1 "command not found: go"
        run "$GO"      version
        printf '\n'
    }

    [ "$CCACHE_ENABLED" = 1 ] && {
        CCACHE=$(command -v ccache) || abort 1 "command not found: ccache"
        run "$CCACHE"    --version
        printf '\n'
    }

    PKG_CONFIG=$(command -v pkg-config || command -v pkgconf) || abort 1 "command not found: pkg-config"

    run "$PKG_CONFIG"    --version
    printf '\n'

    unset  M4
    export M4="$(command -v m4 || true)"

    #########################################################################################

    step "locate C/C++ toolchain for target build"

     CC="$PPKG_CORE_DIR/wrapper-target-cc"
    OBJC="$PPKG_CORE_DIR/wrapper-target-cc"
    CXX="$PPKG_CORE_DIR/wrapper-target-c++"
    CPP="$CC -E"

    if [ "$TARGET_PLATFORM_NAME" = macos ] ; then
        PROXIED_CC="$PROXIED_CC_FOR_BUILD"
        PROXIED_OBJC="$PROXIED_OBJC_FOR_BUILD"
        PROXIED_CXX="$PROXIED_CXX_FOR_BUILD"
    else
        if [ "$CROSS_COMPILING" = 1 ] ; then
            PROXIED_CC="$(command -v clang)"    || abort 1 "command not found: clang"
            PROXIED_OBJC="$(command -v clang)"  || abort 1 "command not found: clang"
            PROXIED_CXX="$(command -v clang++)" || abort 1 "command not found: clang++"
        else
            PROXIED_CC="$PROXIED_CC_FOR_BUILD"
            PROXIED_OBJC="$PROXIED_OBJC_FOR_BUILD"
            PROXIED_CXX="$PROXIED_CXX_FOR_BUILD"
        fi
    fi

    for TOOL in PROXIED_CC PROXIED_OBJC PROXIED_CXX CC OBJC CXX CPP
    do
        eval export "${TOOL}=\"\$${TOOL}\""
        printf "%21s = %s\n" "${TOOL}" "$(eval echo "\$${TOOL}")"
    done

    for TOOL in AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP OBJCOPY READELF ADDR2LINE SYSROOT
    do
        eval export "${TOOL}=\"\$${TOOL}_FOR_BUILD\""
        printf "%21s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo "\$${TOOL}_FOR_BUILD")"
    done

    #########################################################################################

    if [ "$CROSS_COMPILING" = 1 ] ; then
        step "prepare C/C++ sysroot for target build"

        export SYSROOT="$PPKG_SYSROOT/$TARGET_PLATFORM_SPEC"
        printf "%11s = %s\n" SYSROOT "$SYSROOT"

        [ -f "$SYSROOT/ok" ] || {
            run install -d "$PPKG_SYSROOT"
            run cd         "$PPKG_SYSROOT"

            case $TARGET_PLATFORM_NAME in
                dragonflybsd)
                    FILENAME="$TARGET_PLATFORM_SPEC.txz"

                    wfetch "https://github.com/leleliu008/test/releases/download/2023.10.08/dragonflybsd-6.4-x86_64-sysroot.tar.xz" -o "$FILENAME"

                    run install -d "$TARGET_PLATFORM_SPEC"
                    run bsdtar xvf "$FILENAME" -C "$TARGET_PLATFORM_SPEC" --strip-components=1
                    run touch "$TARGET_PLATFORM_SPEC/ok"
                    ;;
                freebsd)
                    FILENAME="$TARGET_PLATFORM_SPEC.txz"

                    # https://archive.freebsd.org/old-releases/
                    wfetch "https://archive.freebsd.org/old-releases/$TARGET_PLATFORM_ARCH/$TARGET_PLATFORM_VERS-RELEASE/base.txz" -o "$FILENAME"

                    run install -d "$TARGET_PLATFORM_SPEC"
                    run bsdtar xvf "$FILENAME" -C "$TARGET_PLATFORM_SPEC"

                    #run rm -rf "$TARGET_PLATFORM_SPEC/bin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/usr/bin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/sbin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/usr/sbin"

                    rm "$TARGET_PLATFORM_SPEC/usr/lib/libgcc.a"

                    printf '%s\n' 'INPUT(-lc++)'                  > "$TARGET_PLATFORM_SPEC/usr/lib/libstdc++.a"
                    printf '%s\n' 'INPUT(-lcompiler_rt -lgcc_eh)' > "$TARGET_PLATFORM_SPEC/usr/lib/libgcc.a"
                    printf '%s\n' 'INPUT(-lcompiler_rt -lgcc_eh)' > "$TARGET_PLATFORM_SPEC/usr/lib/libgcc_s.a"

                    run touch "$TARGET_PLATFORM_SPEC/ok"
                    ;;
                openbsd)
                    TARGET_PLATFORM_VERS_MAJOR="$(printf '%s\n' "$TARGET_PLATFORM_VERS" | cut -d. -f1)"
                    TARGET_PLATFORM_VERS_MINOR="$(printf '%s\n' "$TARGET_PLATFORM_VERS" | cut -d. -f2)"

                    run install -d "$TARGET_PLATFORM_SPEC"

                    for item in base comp
                    do
                        FILENAME="$TARGET_PLATFORM_SPEC-$item.tgz"
                        URL="https://cdn.openbsd.org/pub/OpenBSD/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH/$item$TARGET_PLATFORM_VERS_MAJOR$TARGET_PLATFORM_VERS_MINOR.tgz"
                        wfetch "$URL" -o "$FILENAME"
                        run bsdtar xvf   "$FILENAME" -C "$TARGET_PLATFORM_SPEC"
                    done

                    #run rm -rf "$TARGET_PLATFORM_SPEC/bin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/usr/bin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/sbin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/usr/sbin"

                    # https://github.com/mesonbuild/meson/issues/5390
                    printf '%s\n' 'INPUT(-lc)'                    > "$TARGET_PLATFORM_SPEC/usr/lib/libdl.a"
                    printf '%s\n' 'INPUT(-lc)'                    > "$TARGET_PLATFORM_SPEC/usr/lib/librt.a"
                    printf '%s\n' 'INPUT(-lc)'                    > "$TARGET_PLATFORM_SPEC/usr/lib/libcrypt.a"
                    printf '%s\n' 'INPUT(-lc++)'                  > "$TARGET_PLATFORM_SPEC/usr/lib/libstdc++.a"
                    printf '%s\n' 'INPUT(-lcompiler_rt -lc++abi)' > "$TARGET_PLATFORM_SPEC/usr/lib/libgcc.a"
                    printf '%s\n' 'INPUT(-lcompiler_rt -lc++abi)' > "$TARGET_PLATFORM_SPEC/usr/lib/libgcc_s.a"

                    run touch "$TARGET_PLATFORM_SPEC/ok"
                    ;;
                netbsd)
                    run install -d "$TARGET_PLATFORM_SPEC"

                    for item in base comp
                    do
                        FILENAME="$TARGET_PLATFORM_SPEC-$item.txz"
                        URL="https://ftp.netbsd.org/pub/NetBSD/NetBSD-$TARGET_PLATFORM_VERS/amd64/binary/sets/$item.tar.xz"
                        wfetch "$URL" -o "$FILENAME"
                        run bsdtar xvf "$FILENAME" -C "$TARGET_PLATFORM_SPEC"
                    done

                    #run rm -rf "$TARGET_PLATFORM_SPEC/bin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/usr/bin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/sbin"
                    #run rm -rf "$TARGET_PLATFORM_SPEC/usr/sbin"

                    printf '%s\n' 'INPUT(-lc)'      > "$TARGET_PLATFORM_SPEC/usr/lib/libdl.a"
                    printf '%s\n' 'INPUT(-lgcc_eh)' > "$TARGET_PLATFORM_SPEC/usr/lib/libgcc_s.a"

                    run touch "$TARGET_PLATFORM_SPEC/ok"
                    ;;
                linux)
                    if [ "$TARGET_PLATFORM_VERS" = musl ] ; then
                        FILENAME="$TARGET_PLATFORM_SPEC-libc.txz"

                        wfetch 'https://github.com/leleliu008/test/releases/download/2023.10.08/musl-libc-1.2.3-linux-x86_64-musl.tar.xz' -o "$FILENAME"

                        run install -d "$TARGET_PLATFORM_SPEC"
                        run bsdtar xvf "$FILENAME" -C "$TARGET_PLATFORM_SPEC" --strip-components=1

                        run touch "$TARGET_PLATFORM_SPEC/ok"
                    fi
                    ;;
            esac
        }
    fi

    #########################################################################################

    step "create symbolic link for ccache"

    if [ "$CCACHE_ENABLED" = 1 ] ; then
        run ln -sf "$CCACHE" "$PACKAGE_INSTALLING_BIN_DIR/$(basename "$CC")"
        run ln -sf "$CCACHE" "$PACKAGE_INSTALLING_BIN_DIR/$(basename "$CXX")"

        "$CCACHE" -s > "$PACKAGE_WORKING_DIR/ccache-s.txt"
    else
        note "ccache is disabled, skipped."
    fi

    #########################################################################################

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "create symbolic links for dependent libraries"

        unset libFileNameSuffix

        case $LINK_TYPE in
            static-full|static-most)
                libFileNameSuffix='.a'
                ;;
            shared-full|shared-most)
                if [ "$TARGET_PLATFORM_NAME" = macos ] ; then
                    libFileNameSuffix='.dylib'
                else
                    libFileNameSuffix='.so'
                fi
                ;;
            *)  die "unrecognized link type: $LINK_TYPE"
        esac

        for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
        do
            DEPENDENT_PACKAGE_LIBRARY_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib"

            if [ -d "$DEPENDENT_PACKAGE_LIBRARY_DIR" ] ; then
                for libFileName in $(find "$DEPENDENT_PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -name "lib*$libFileNameSuffix" -exec basename {} \;)
                do
                    if [ ! -e "$PACKAGE_INSTALLING_LIB_DIR/$libFileName" ] ; then
                        run ln -s "$DEPENDENT_PACKAGE_LIBRARY_DIR/$libFileName" "$PACKAGE_INSTALLING_LIB_DIR/$libFileName"
                    fi
                done
            fi
        done
    }

    #########################################################################################

    case $TARGET_PLATFORM_NAME in
        netbsd)
            printf '%s\n' 'INPUT(-lc)' > "$PACKAGE_WORKING_DIR/lib/libdl.a"
            ;;
        openbsd)
            # https://github.com/mesonbuild/meson/issues/5390
            printf '%s\n' 'INPUT(-lc)' > "$PACKAGE_WORKING_DIR/lib/libdl.a"
            printf '%s\n' 'INPUT(-lc)' > "$PACKAGE_WORKING_DIR/lib/librt.a"
            printf '%s\n' 'INPUT(-lc)' > "$PACKAGE_WORKING_DIR/lib/libcrypt.a"
            ;;
    esac

    #########################################################################################

    if [ "$LINK_TYPE" = static-full ] ; then
        if [ "$TARGET_PLATFORM_NAME" = netbsd ] ; then
            if [ "$CROSS_COMPILING" = 1 ] ; then
                printf 'INPUT(%s/usr/lib/libstdc++.a -lgcc_s)\n' "$SYSROOT" >  "$PACKAGE_WORKING_DIR/lib/libstdc++.a"
            fi
        fi
    fi

    #########################################################################################

    step "initialize CFLAGS CXXFLAGS CPPFLAGS LDFLAGS"

    PPFLAGS=
    CCFLAGS="-fPIC -fno-common"
    OCFLAGS="-fPIC -fno-common"
    XXFLAGS="-fPIC -fno-common"
    LDFLAGS=

    if [ "$TARGET_PLATFORM_NAME" = macos ] ; then
        PPFLAGS="-isysroot $SYSROOT -Qunused-arguments"
        CCFLAGS="-isysroot $SYSROOT -mmacosx-version-min=$TARGET_PLATFORM_VERS -arch $TARGET_PLATFORM_ARCH -Qunused-arguments $CCFLAGS"
        OCFLAGS="-isysroot $SYSROOT -mmacosx-version-min=$TARGET_PLATFORM_VERS -arch $TARGET_PLATFORM_ARCH -Qunused-arguments $OCFLAGS"
        XXFLAGS="-isysroot $SYSROOT -mmacosx-version-min=$TARGET_PLATFORM_VERS -arch $TARGET_PLATFORM_ARCH -Qunused-arguments $XXFLAGS"
        LDFLAGS="-isysroot $SYSROOT -mmacosx-version-min=$TARGET_PLATFORM_VERS -arch $TARGET_PLATFORM_ARCH -Wl,-search_paths_first"
    else
        # https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html
        LDFLAGS="-Wl,--as-needed -Wl,-z,muldefs -Wl,--allow-multiple-definition"

        if [ -n "$SYSROOT" ] ; then
            PPFLAGS="--sysroot=$SYSROOT"
            CCFLAGS="--sysroot=$SYSROOT $CCFLAGS"
            OCFLAGS="--sysroot=$SYSROOT $OCFLAGS"
            XXFLAGS="--sysroot=$SYSROOT $XXFLAGS"
            LDFLAGS="--sysroot=$SYSROOT $LDFLAGS"
        fi

        if [ "$CROSS_COMPILING" = 1 ] ; then
            if [ "$TARGET_PLATFORM_NAME" = linux ] ; then
                CLANG_TARGET="$TARGET_PLATFORM_ARCH-unknown-$TARGET_PLATFORM_NAME-$TARGET_PLATFORM_VERS"
            else
                CLANG_TARGET="$TARGET_PLATFORM_ARCH-unknown-$TARGET_PLATFORM_NAME"
            fi

            PPFLAGS="--target=$CLANG_TARGET $PPFLAGS"
            CCFLAGS="--target=$CLANG_TARGET $CCFLAGS"
            OCFLAGS="--target=$CLANG_TARGET $OCFLAGS"
            XXFLAGS="--target=$CLANG_TARGET $XXFLAGS"
            LDFLAGS="--target=$CLANG_TARGET $LDFLAGS"

            PPFLAGS="$PPFLAGS -I$SYSROOT/usr/include/c++/v1"
            XXFLAGS="$XXFLAGS -I$SYSROOT/usr/include/c++/v1"

            if [ "$TARGET_PLATFORM_NAME" = freebsd ] ; then
                # https://github.com/llvm/llvm-project/issues/74917
                # https://github.com/madler/zlib/issues/856
                LDFLAGS="$LDFLAGS -fuse-ld=lld -Wl,--undefined-version"
            fi
        fi
    fi

    if [ "$LOG_LEVEL" -ge 3 ] ; then
        CCFLAGS="$CCFLAGS -v"
        OCFLAGS="$OCFLAGS -v"
        XXFLAGS="$XXFLAGS -v"
        LDFLAGS="$LDFLAGS -Wl,-v"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        PPFLAGS="$PPFLAGS -DNDEBUG"
        CCFLAGS="$CCFLAGS -Os"
        OCFLAGS="$OCFLAGS -Os"
        XXFLAGS="$XXFLAGS -Os"
        LDFLAGS="$LDFLAGS -Wl,-S"
    else
        CCFLAGS="$CCFLAGS -g -O0"
        OCFLAGS="$OCFLAGS -g -O0"
        XXFLAGS="$XXFLAGS -g -O0"
    fi

    #case $TARGET_PLATFORM_NAME in
    #    netbsd)  LDFLAGS="$LDFLAGS -pthread" ;;
    #    openbsd) LDFLAGS="$LDFLAGS -pthread" ;;
    #esac

    #########################################################################################

    step "check if C compiler supports -Wno-error=unused-command-line-argument option"

    cat > test.c <<EOF
int main() {
    return 0;
}
EOF

    if "$CC" -Wno-error=unused-command-line-argument test.c 2>/dev/null ; then
        CCFLAGS="$CCFLAGS -Wno-error=unused-command-line-argument"
        success "YES"
    else
        error "NO"
    fi

    #########################################################################################

    step "check if C++ compiler supports -Wno-error=unused-command-line-argument option"

    cat > test.cc <<EOF
int main() {
    return 0;
}
EOF

    if "$CXX" -Wno-error=unused-command-line-argument test.cc 2>/dev/null ; then
        XXFLAGS="$XXFLAGS -Wno-error=unused-command-line-argument"
        success "YES"
    else
        error "NO"
    fi

    ##################################################################################

    for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
    do
        DEPENDENT_PACKAGE_NAME_UNDERSCORE=$(printf '%s\n' "$DEPENDENT_PACKAGE_NAME" | tr '@+-.' '_')

        DEPENDENT_PACKAGE_INSTALL_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_SPEC/$DEPENDENT_PACKAGE_NAME"
        DEPENDENT_PACKAGE_INCLUDE_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/include"
        DEPENDENT_PACKAGE_LIBRARY_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib"
        DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib/pkgconfig"

        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_INSTALL_DIR='$DEPENDENT_PACKAGE_INSTALL_DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_INCLUDE_DIR='$DEPENDENT_PACKAGE_INCLUDE_DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_LIBRARY_DIR='$DEPENDENT_PACKAGE_LIBRARY_DIR'"

        if [ -d "$DEPENDENT_PACKAGE_INCLUDE_DIR" ] ; then
            PPFLAGS="-I$DEPENDENT_PACKAGE_INCLUDE_DIR $PPFLAGS"
        fi

        if [ -d "$DEPENDENT_PACKAGE_LIBRARY_DIR" ] ; then
            LDFLAGS="-L$DEPENDENT_PACKAGE_LIBRARY_DIR -Wl,-rpath,$DEPENDENT_PACKAGE_LIBRARY_DIR $LDFLAGS"
        fi
    done

    PPFLAGS="-I$PACKAGE_INSTALLING_INC_DIR $PPFLAGS"
    LDFLAGS="-L$PACKAGE_INSTALLING_LIB_DIR $LDFLAGS"

    if [ "$LINK_TYPE" = 'static-full' ] ; then
        # both --static and -static flag should be given.
        #  -static flag will be filtered out by libtool, libtool recognize this flag as prefer to link static library.
        # --static flag will be passed to the linker, although this flag was not documented, but it indeed works.
        LDFLAGS="--static -static $LDFLAGS"
    fi

    ##################################################################################

    CCFLAGS="$CCFLAGS $PACKAGE_CCFLAGS"
    XXFLAGS="$XXFLAGS $PACKAGE_XXFLAGS"
    PPFLAGS="$PPFLAGS $PACKAGE_PPFLAGS"
    LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"

    export   CFLAGS="$CCFLAGS"
    export CXXFLAGS="$XXFLAGS"
    export CPPFLAGS="$PPFLAGS"
    export  LDFLAGS="$LDFLAGS"

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CFLAGS"
    printf '%s\n' "$CFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CXXFLAGS"
    printf '%s\n' "$CXXFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CPPFLAGS"
    printf '%s\n' "$CPPFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} LDFLAGS"
    printf '%s\n' "$LDFLAGS" | xargs printf '        %s\n'

    #########################################################################################

    step "list XDG_DATA_DIRS"

    # https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
    export XDG_DATA_DIRS

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        # https://gi.readthedocs.io/en/latest/tools/g-ir-scanner.html#environment-variables
        if [ -d "$DEPENDENT_PACKAGE_INSTALL_DIR/share/gir-1.0" ] ; then
            if [ -z "$XDG_DATA_DIRS" ] ; then
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share"
            else
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share:$XDG_DATA_DIRS"
            fi
        fi

        # https://help.gnome.org/admin//system-admin-guide/2.32/mimetypes-database.html.en
        if [ -d "$DEPENDENT_PACKAGE_INSTALL_DIR/share/mime" ] ; then
            if [ -z "$XDG_DATA_DIRS" ] ; then
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share"
            else
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share:$XDG_DATA_DIRS"
            fi
        fi
    done

    printf '%s\n' "$XDG_DATA_DIRS" | tr : '\n'

    #########################################################################################

    step "list ACLOCAL_PATH"

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        DEPENDENT_PACKAGE_ACLOCAL_PATH="$DEPENDENT_PACKAGE_INSTALL_DIR/share/aclocal"

        if [ -d "$DEPENDENT_PACKAGE_ACLOCAL_PATH" ] ; then
            if [ -z "$ACLOCAL_PATH" ] ; then
                ACLOCAL_PATH="$DEPENDENT_PACKAGE_ACLOCAL_PATH"
            else
                ACLOCAL_PATH="$DEPENDENT_PACKAGE_ACLOCAL_PATH:$ACLOCAL_PATH"
            fi
        fi
    done

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    export ACLOCAL_PATH="$PACKAGE_WORKING_DIR/share/aclocal:$ACLOCAL_PATH"

    printf '%s\n' "$ACLOCAL_PATH" | tr : '\n'

    #########################################################################################

    step "list PATH"

    PATH="$PACKAGE_INSTALLING_BIN_DIR:$PATH"

    printf '%s\n' "$PATH" | tr : '\n'

    #########################################################################################

    step "config environment variables for pkg-config"

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib/pkgconfig"

        if [ -d "$DEPENDENT_PACKAGE_PKGCONF_DIR" ] ; then
            PKG_CONFIG_PATH="$DEPENDENT_PACKAGE_PKGCONF_DIR:$PKG_CONFIG_PATH"
        else
            DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/share/pkgconfig"

            if [ -d "$DEPENDENT_PACKAGE_PKGCONF_DIR" ] ; then
                PKG_CONFIG_PATH="$DEPENDENT_PACKAGE_PKGCONF_DIR:$PKG_CONFIG_PATH"
            fi
        fi
    done

    if [ -z "$PKG_CONFIG_PATH" ] ; then
        export PKG_CONFIG_PATH="$PACKAGE_WORKING_DIR/lib/pkgconfig"
    else
        export PKG_CONFIG_PATH="$PACKAGE_WORKING_DIR/lib/pkgconfig:$PKG_CONFIG_PATH"
    fi

    # override the default search directory (usually /usr/lib/pkgconfig:/usr/share/pkgconfig)
    export PKG_CONFIG_LIBDIR="$PPKG_CORE_DIR/lib/pkgconfig"

    if [ "$LOG_LEVEL" -ge 3 ] ; then
        export PKG_CONFIG_DEBUG_SPEW='set'
    fi

    printf 'PKG_CONFIG_DEBUG_SPEW = %s\n' "$PKG_CONFIG_DEBUG_SPEW"

    printf 'PKG_CONFIG          = %s\n' "$PKG_CONFIG"

    printf 'PKG_CONFIG_LIBDIR   = %s\n' "$PKG_CONFIG_LIBDIR"

    export IFS=':'

    FIRST=1

    for item in $(printf '%s\n' "$PKG_CONFIG_PATH")
    do
        if [ "$FIRST" = 1 ] ; then
            FIRST=0
            printf 'PKG_CONFIG_PATH     = %s\n' "$item"
        else
            printf '%s\n' "                      $item"
        fi
    done

    unset IFS

    #########################################################################################

    if [ "$PACKAGE_USE_BSYSTEM_CMAKE" = 1 ] ; then
        step "config environment variables for cmake"

        # https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html#manual:cmake-env-variables(7)

        unset CMAKE_PREFIX_PATH
        unset CMAKE_APPLE_SILICON_PROCESSOR
        unset CMAKE_BUILD_PARALLEL_LEVEL
        unset CMAKE_BUILD_TYPE
        unset CMAKE_CONFIGURATION_TYPES
        unset CMAKE_CONFIG_TYPE
        unset CMAKE_EXPORT_COMPILE_COMMANDS
        unset CMAKE_GENERATOR
        unset CMAKE_GENERATOR_INSTANCE
        unset CMAKE_GENERATOR_PLATFORM
        unset CMAKE_GENERATOR_TOOLSET
        unset CMAKE_INSTALL_MODE
        unset CMAKE_C_COMPILER_LAUNCHER
        unset CMAKE_C_LINKER_LAUNCHER
        unset CMAKE_CXX_COMPILER_LAUNCHER
        unset CMAKE_CXX_LINKER_LAUNCHER
        unset CMAKE_MSVCIDE_RUN_PATH
        unset CMAKE_NO_VERBOSE
        unset CMAKE_OSX_ARCHITECTURES
        unset CMAKE_TOOLCHAIN_FILE
        unset DESTDIR
        unset CTEST_INTERACTIVE_DEBUG_MODE
        unset CTEST_OUTPUT_ON_FAILURE
        unset CTEST_PARALLEL_LEVEL
        unset CTEST_PROGRESS_OUTPUT
        unset CTEST_USE_LAUNCHERS_DEFAULT
        unset DASHBOARD_TEST_FROM_CTEST

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_BUILD_PARALLEL_LEVEL.html
        export CMAKE_BUILD_PARALLEL_LEVEL="$BUILD_NJOBS"

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_GENERATOR.html
        if [ "$PACKAGE_USE_BSYSTEM_NINJA" = 1 ] ; then
            export CMAKE_GENERATOR='Ninja'
        else
            export CMAKE_GENERATOR='Unix Makefiles'
        fi

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_EXPORT_COMPILE_COMMANDS.html
        if [ "$EXPORT_COMPILE_COMMANDS_JSON" = 1 ] ; then
            export CMAKE_EXPORT_COMPILE_COMMANDS=ON
        else
            export CMAKE_EXPORT_COMPILE_COMMANDS=OFF
        fi

        case $BUILD_TYPE in
            debug)   CMAKE_BUILD_TYPE=Debug   ;;
            release) CMAKE_BUILD_TYPE=Release ;;
        esac

        case $INSTALL_LIB in
            static)  BUILD_SHARED_LIBS=OFF ;;
            *)       BUILD_SHARED_LIBS=ON
        esac

        if [ "$LOG_LEVEL" -eq 0 ] ; then
            CMAKE_VERBOSE_MAKEFILE=OFF
            CMAKE_COLOR_MAKEFILE=OFF
        else
            CMAKE_VERBOSE_MAKEFILE=ON
            CMAKE_COLOR_MAKEFILE=ON
        fi

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
        if [ "$LOG_LEVEL" -ge 3 ] ; then
            CMAKE_FIND_DEBUG_MODE=ON
        else
            CMAKE_FIND_DEBUG_MODE=OFF
        fi

        CMAKE_TOOLCHAIN_FILE="$PACKAGE_WORKING_DIR/toolchain.cmake"

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
        unset CMAKE_FIND_ROOT_PATH

        if [ -n "$PACKAGE_DEP_PKG" ] ; then
            CMAKE_FIND_ROOT_PATH="$(printf '%s\n' "$RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS" | tr ' ' ';')"
        fi

        if [ -n "$SYSROOT" ] ; then
            if [ -z "$CMAKE_FIND_ROOT_PATH" ] ; then
                CMAKE_FIND_ROOT_PATH="$SYSROOT"
            else
                CMAKE_FIND_ROOT_PATH="$CMAKE_FIND_ROOT_PATH;$SYSROOT"
            fi
        fi

        env | sed -n '/^CMAKE_/p'

        # https://cmake.org/cmake/help/latest/variable/CMAKE_PROJECT_INCLUDE.html

        CMAKE_PROJECT_INCLUDE="$PACKAGE_WORKING_DIR/project-after.cmake"

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_LIBRARY_SUFFIXES.html

        if [ "$TARGET_PLATFORM_NAME" = macos ] ; then
            case $LINK_TYPE in
                static-full) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".a")\n'          > "$CMAKE_PROJECT_INCLUDE" ;;
                static-most) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".a" ".dylib")\n' > "$CMAKE_PROJECT_INCLUDE" ;;
                shared-full) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".dylib")\n'      > "$CMAKE_PROJECT_INCLUDE" ;;
                shared-most) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".dylib" ".a")\n' > "$CMAKE_PROJECT_INCLUDE" ;;
            esac
        else
            case $LINK_TYPE in
                static-full) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".a")\n'          > "$CMAKE_PROJECT_INCLUDE" ;;
                static-most) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".a" ".so")\n'    > "$CMAKE_PROJECT_INCLUDE" ;;
                shared-full) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".so")\n'         > "$CMAKE_PROJECT_INCLUDE" ;;
                shared-most) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".so" ".a")\n'    > "$CMAKE_PROJECT_INCLUDE" ;;
            esac
        fi

        if [ "$LOG_LEVEL" -gt 0 ] ; then
            run cat "$CMAKE_PROJECT_INCLUDE"
        fi
    fi

    #########################################################################################

    if [ "$PACKAGE_USE_BSYSTEM_CARGO" = 1 ] ; then
        step "config environment variables for cargo and rustc"

        # https://github.com/rust-lang/rust/issues/89626
        if [ "$RUST_TARGET" = 'aarch64-unknown-linux-musl' ] ; then
            CFLAGS="$CFLAGS -mno-outline-atomics"
        fi

        # https://docs.rs/backtrace/latest/backtrace/
        export RUST_BACKTRACE=1

        #########################################################

        unset RUST_TARGET

        case $TARGET_PLATFORM_NAME in
            linux)
                case $TARGET_PLATFORM_VERS in
                    glibc) RUST_TARGET="$TARGET_PLATFORM_ARCH-unknown-linux-gnu"  ;;
                    musl)  RUST_TARGET="$TARGET_PLATFORM_ARCH-unknown-linux-musl" ;;
                esac
                ;;
            macos)
                case $TARGET_PLATFORM_ARCH in
                    x86_64) RUST_TARGET='x86_64-apple-darwin'  ;;
                    arm64)  RUST_TARGET='aarch64-apple-darwin' ;;
                esac
                ;;
            *)
                case $TARGET_PLATFORM_ARCH in
                    amd64)  RUST_TARGET="x86_64-unknown-$TARGET_PLATFORM_NAME" ;;
                    *)      RUST_TARGET="$TARGET_PLATFORM_ARCH-unknown-$TARGET_PLATFORM_NAME"  ;;
                esac
        esac

        # this environment variable is not defined by Rust, but it is widely used by third-party project.
        export RUST_TARGET

        #########################################################

        RUST_TARGET_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$RUST_TARGET" | tr a-z A-Z | tr - _)

        # https://doc.rust-lang.org/cargo/reference/config.html#environment-variables
        # https://doc.rust-lang.org/cargo/reference/environment-variables.html
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_AR"="$AR"
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_LINKER"="$CC"

        export CARGO_BUILD_JOBS="$BUILD_NJOBS"

        #########################################################

        # https://doc.rust-lang.org/rustc/codegen-options/index.html#link-arg
        export RUSTFLAGS="-Clinker=$CC -Clink-arg=-L$PACKAGE_WORKING_DIR/lib"

        if [ "$LINK_TYPE" = 'static-full' ] ; then
            if [ "$TARGET_PLATFORM_NAME" = linux ] ; then
                if [ "$TARGET_PLATFORM_VERS" = 'musl' ] ; then
                    printf '%s\n' 'INPUT(-l:libgcc_eh.a)' > "$PACKAGE_WORKING_DIR/lib/libgcc_s.a"
                    RUSTFLAGS="$RUSTFLAGS -Clink-arg=-static -Clink-arg=-ffunction-sections -Clink-arg=-fdata-sections -Clink-arg=-Wl,--gc-sections -Clink-arg=-Wl,--no-dynamic-linker"
                fi
            else
                if [ "$CROSS_COMPILING" = 1 ] ; then
                    LIBCLANG_RT_BUILTINS_FILEPATH="$("$CC" -print-libgcc-file-name)"
                    RUSTFLAGS="$RUSTFLAGS -Clink-arg=$LIBCLANG_RT_BUILTINS_FILEPATH"
                fi
            fi
        fi

        for LDFLAG in $LDFLAGS
        do
            RUSTFLAGS="$RUSTFLAGS -Clink-arg=$LDFLAG"
        done

        #########################################################

        # https://libraries.io/cargo/cc
        # https://crates.io/crates/cc
        # https://docs.rs/cc/latest/cc/
        # https://github.com/alexcrichton/cc-rs
        export HOST_CC="$CC"
        export HOST_CFLAGS="$CFLAGS $CPPFLAGS"

        export HOST_CXX="$CXX"
        export HOST_CXXFLAGS="$CXXFLAGS $CPPFLAGS"

        export HOST_AR="$AR"

        export TARGET_CC="$CC"
        export TARGET_CFLAGS="$CFLAGS $CPPFLAGS"

        export TARGET_CXX="$CXX"
        export TARGET_CXXFLAGS="$CXXFLAGS $CPPFLAGS"

        export TARGET_AR="$AR"


        # https://libraries.io/cargo/pkg-config
        # https://crates.io/crates/pkg-config
        # https://docs.rs/pkg-config/latest/pkg_config/
        # https://github.com/rust-lang/pkg-config-rs
        # export TARGET_PKG_CONFIG_ALLOW_CROSS=1


        # https://libraries.io/cargo/cmake
        # https://crates.io/crates/cmake
        # https://docs.rs/cmake/latest/cmake/
        # https://github.com/alexcrichton/cmake-rs
        # this variable is not motioned in their document. you must read the source code of cmake-rs crate.
        # export TARGET_CMAKE_TOOLCHAIN_FILE="$TARGET_WORKING_DIR/toolchain.cmake"


        for item in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            case $item in
                openssl)
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_INSTALL_DIR"
                    ;;
                openssl@1.1)
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_1_1_INSTALL_DIR"
                    ;;
            esac
        done

        env | grep CARGO_
        env | grep RUST_

        printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} RUSTFLAGS"
        printf '%s\n' "$RUSTFLAGS" | xargs printf '        %s\n'
    fi

    #########################################################################################

    if [ "$PACKAGE_USE_BSYSTEM_GO" = 1 ] ; then
        step "config environment variables for go"

        # https://golang.org/doc/install/source#environment

        if [ "$CROSS_COMPILING" = 1 ] ; then
            export GOOS="$TARGET_PLATFORM_NAME"

            if [ "$TARGET_PLATFORM_ARCH" = 'x86_64' ] ; then
                export GOARCH='amd64'
            else
                export GOARCH="$TARGET_PLATFORM_ARCH"
            fi
        else
            unset GOOS
            unset GOARCH
        fi

        export GO111MODULE='auto'

        # https://pkg.go.dev/cmd/cgo
        export CGO_ENABLED=0
        export CGO_CFLAGS="$CFLAGS"
        export CGO_CXXFLAGS="$CXXFLAGS"
        export CGO_CPPFLAGS="$CPPFLAGS"
        export CGO_LDFLAGS="$LDFLAGS"
    fi

    #########################################################################################

    [ "$LOG_LEVEL" -ge 3 ] && {
        step "show export variables"
        run export -p
        echo
    }

    #########################################################################################

    step "fetch source/patches/resources from server"

    if [ "$PACKAGE_SRC_FILETYPE" = '.dir' ] ; then
        note "$PACKAGE_SRC_URL is local path, no need to fetch."
    elif [ -z "$PACKAGE_SRC_URL" ] ; then
        unset GIT_FETCH_URL

        if [ -z "$PPKG_URL_TRANSFORM" ] ; then
            GIT_FETCH_URL="$PACKAGE_GIT_URL"
        else
            GIT_FETCH_URL="$("$PPKG_URL_TRANSFORM" "$PACKAGE_GIT_URL")" || return 1
        fi

        if [ -z "$PACKAGE_GIT_SHA" ] ; then
            if [ -z "$PACKAGE_GIT_REF" ] ; then
                GIT_BRANCH_NAME=master
                GIT_REF_SPEC="+HEAD:refs/remotes/origin/master"
            else
                GIT_BRANCH_NAME="$(basename "$PACKAGE_GIT_REF")"
                GIT_REF_SPEC="+$PACKAGE_GIT_REF:refs/remotes/origin/$GIT_BRANCH_NAME"
            fi
        else
            GIT_BRANCH_NAME=master
            GIT_REF_SPEC="+$PACKAGE_GIT_SHA:refs/remotes/origin/master"
        fi

        if [ -z "$PACKAGE_GIT_NTH" ] ; then
            PACKAGE_GIT_NTH=1
        fi

        if [ "$PACKAGE_GIT_NTH" -eq 0 ] ; then
            if [ -f "$PACKAGE_SRC_FILEPATH/.git/shallow" ] ; then
                GIT_FETCH_EXTRA_OPTIONS='--unshallow'
            else
                GIT_FETCH_EXTRA_OPTIONS=
            fi
        else
            GIT_FETCH_EXTRA_OPTIONS="--depth=$PACKAGE_GIT_NTH"
        fi

        run cd "$PACKAGE_INSTALLING_SRC_DIR"
        run git -c init.defaultBranch=master init
        run git remote add origin "$GIT_FETCH_URL"
        run git -c protocol.version=2 fetch --progress $GIT_FETCH_EXTRA_OPTIONS origin "$GIT_REF_SPEC"
        run git checkout --progress --force -B "$GIT_BRANCH_NAME" "refs/remotes/origin/$GIT_BRANCH_NAME"

        GIT_SUBMODULE_PATH_LIST="$(find . -name .gitmodules)"

        if [ -n "$GIT_SUBMODULE_PATH_LIST" ] ; then
            if [ -n "$PPKG_URL_TRANSFORM" ] ; then
                for GIT_SUBMODULE_PATH in $GIT_SUBMODULE_PATH_LIST
                do
                    GIT_SUBMODULE_URLS="$(grep 'url = ' "$GIT_SUBMODULE_PATH" | sed 's|[[:space:]]||g' | cut -c5-)"

                    for GIT_SUBMODULE_URL in $GIT_SUBMODULE_URLS
                    do
                        GIT_SUBMODULE_URI="$("$PPKG_URL_TRANSFORM" "$GIT_SUBMODULE_URL")"
                        sed_in_place "s|$GIT_SUBMODULE_URL|$GIT_SUBMODULE_URI|" "$GIT_SUBMODULE_PATH"
                    done
                done
            fi

            run git submodule update --init
        fi
    else
        wfetch "$PACKAGE_SRC_URL" --uri="$PACKAGE_SRC_URI" --sha256="$PACKAGE_SRC_SHA" -o "$PACKAGE_SRC_FILEPATH"
    fi

    if [ -n    "$PACKAGE_FIX_URL" ] ; then
        wfetch "$PACKAGE_FIX_URL" --uri="$PACKAGE_FIX_URI" --sha256="$PACKAGE_FIX_SHA" -o "$PACKAGE_FIX_FILEPATH"
    fi

    if [ -n    "$PACKAGE_RES_URL" ] ; then
        wfetch "$PACKAGE_RES_URL" --uri="$PACKAGE_RES_URI" --sha256="$PACKAGE_RES_SHA" -o "$PACKAGE_RES_FILEPATH"
    fi

    #########################################################################################

    case $PACKAGE_SRC_FILETYPE in
        .dir)
            if [ "$PACKAGE_SRC_FILEPATH" = '/dev/null' ] ; then
                :
            elif [ -d "$PACKAGE_SRC_FILEPATH" ] ; then
                if [ -d "$PACKAGE_SRC_FILEPATH/.git" ] && command -v git > /dev/null ; then
                    PACKAGE_GIT_SHA=$(git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD || true)
                fi
                step "copy source files to the installing src directory"
                run cp -r "$PACKAGE_SRC_FILEPATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            else
                abort 1 "src-url point to dir does not exist."
            fi
            ;;
        .git)
            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                PACKAGE_GIT_SHA="$(git rev-parse HEAD)"
            fi
            ;;
        .zip|.txz|.tgz|.tlz|.tbz2|.crate)
            step "uncompressed source file to the installing src directory"
            run bsdtar xf "$PACKAGE_SRC_FILEPATH" -C "$PACKAGE_INSTALLING_SRC_DIR" --strip-components 1 --no-same-owner
            ;;
        *)  step "copy source files to the installing src directory"
            run cp "$PACKAGE_SRC_FILEPATH" "$PACKAGE_INSTALLING_SRC_DIR/"
    esac

    if [ -n "$PACKAGE_FIX_FILEPATH" ] ; then
        case $PACKAGE_FIX_FILETYPE in
            .zip|.txz|.tgz|.tlz|.tbz2|.crate)
                step "uncompressed patch file to the installing fix directory"
                run bsdtar xf "$PACKAGE_FIX_FILEPATH" -C "$PACKAGE_INSTALLING_FIX_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  step "copy patch file to the installing fix directory"
                run cp "$PACKAGE_FIX_FILEPATH" "$PACKAGE_INSTALLING_FIX_DIR/"
        esac
    fi

    if [ -n "$PACKAGE_RES_FILEPATH" ] ; then
        case $PACKAGE_RES_FILETYPE in
            .zip|.txz|.tgz|.tlz|.tbz2|.crate)
                step "uncompressed res file to the installing res directory"
                run bsdtar xf "$PACKAGE_RES_FILEPATH" -C "$PACKAGE_INSTALLING_RES_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  step "copy res file to the installing res directory"
                run cp "$PACKAGE_RES_FILEPATH" "$PACKAGE_INSTALLING_RES_DIR/"
        esac
    fi

    #########################################################################################

    PACKAGE_BSCRIPT_DIR="$PACKAGE_INSTALLING_SRC_DIR/$PACKAGE_BSCRIPT"
    PACKAGE_BSCRIPT_DIR="${PACKAGE_BSCRIPT_DIR%/}"

    step "tree files of the installing top directory"
    run tree --dirsfirst -L 2 "$PACKAGE_WORKING_DIR"

    step "list files of the installing src directory"
    run ls -l "$PACKAGE_INSTALLING_SRC_DIR"

    if [ -n "$PACKAGE_BSCRIPT" ] ; then
        step "list files of the installing build script directory"
        run ls -l "$PACKAGE_BSCRIPT_DIR"
    fi

    #########################################################################################

    [ "$DRYRUN" = 1 ] && {
        [ -z "$SHELL" ] || SHELL=$(command -v zsh || command -v bash || command -v sh) || abort 1 "none of zsh|bash|sh shell found in your system."
        exec "$SHELL"
    }

    #########################################################################################

    step "patching"

    if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
        run cd "$PACKAGE_BSCRIPT_DIR"
    fi

    if [ -n "$PACKAGE_ACTIONS_DOPATCH" ] ; then
        eval "
dopatch() {
$PACKAGE_ACTIONS_DOPATCH
}"
        dopatch "$1"
    else
        note "dopatch mapping was not found in formula, skipped."
    fi

    #########################################################################################

    case $PACKAGE_BSYSTEM in
        autogen)
            if [ -f configure ] ; then
                CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP="$(stat --format=%Y configure)"

                if [ -z "$CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP" ] ; then
                    run NOCONFIGURE=yes ./autogen.sh
                elif [ "$CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP" -lt "$TIMESTAMP_UNIX" ] ; then
                    run NOCONFIGURE=yes ./autogen.sh
                fi
            else
                run NOCONFIGURE=yes ./autogen.sh
            fi
            ;;
        autotools)
            if [ -f configure ] ; then
                CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP="$(stat --format=%Y configure)"

                if [ -z "$CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP" ] ; then
                    run autoreconf -ivf
                elif [ "$CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP" -lt "$TIMESTAMP_UNIX" ] ; then
                    run autoreconf -ivf
                fi
            else
                run autoreconf -ivf
            fi
            ;;
    esac

    #########################################################################################

    [ "$PACKAGE_USE_BSYSTEM_CONFIGURE" = 1 ] && {
        # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
        # https://git.savannah.gnu.org/cgit/config.git/tree/

        step "replace config.sub and config.guess with the latest version"

        for FILENAME in config.sub config.guess
        do
            FILEPATH="$SESSION_DIR/$FILENAME"

            wfetch "https://git.savannah.gnu.org/cgit/config.git/plain/$FILENAME" -o "$FILEPATH"

            run chmod a+x "$FILEPATH"

            if [ "$FILENAME" = 'config.sub' ] ; then
                sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$FILEPATH"
            fi

            find "$PACKAGE_BSCRIPT_DIR" -name "$FILENAME" -exec cp -vf "$FILEPATH" {} \;
        done
    }

    #########################################################################################

    step "building"

    if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = 1 ] ; then
        run cd "$PACKAGE_BSCRIPT_DIR"
    else
        run cd "$PACKAGE_BCACHED_DIR"
    fi

    if [ -d "$PACKAGE_INSTALL_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALL_DIR"
    fi

    eval "
dobuild() {
$PACKAGE_ACTIONS_DOBUILD
}"

    dobuild "$1"

    #########################################################################################

    [ "$PACKAGE_USE_BSYSTEM_CARGO" = 1 ] && {
        rm -f "$PACKAGE_INSTALL_DIR/.crates.toml"
        rm -f "$PACKAGE_INSTALL_DIR/.crates2.json"
    }

    #########################################################################################

    cd "$PACKAGE_INSTALL_DIR" || abort 1 "nothing is installed."

    [ -z "$(ls)" ]            && abort 1 "nothing is installed."

    #########################################################################################

    # reassigned to make sure it has the right value, becsuse it may be changed in dopatch and install block.

    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_WORKING_DIR/src"
    PACKAGE_INSTALLING_FIX_DIR="$PACKAGE_WORKING_DIR/fix"
    PACKAGE_INSTALLING_RES_DIR="$PACKAGE_WORKING_DIR/res"
    PACKAGE_INSTALLING_BIN_DIR="$PACKAGE_WORKING_DIR/bin"
    PACKAGE_INSTALLING_LIB_DIR="$PACKAGE_WORKING_DIR/lib"
    PACKAGE_INSTALLING_INC_DIR="$PACKAGE_WORKING_DIR/include"

    #########################################################################################

    PACKAGE_METAINFO_DIR="$PACKAGE_INSTALL_DIR/.ppkg"

    PACKAGE_MANIFEST_FILEPATH="$PACKAGE_METAINFO_DIR/MANIFEST.txt"
    PACKAGE_RECEIPT_FILEPATH="$PACKAGE_METAINFO_DIR/RECEIPT.yml"

    install -d "$PACKAGE_METAINFO_DIR"

    #########################################################################################

    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'FAQ*'     -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'TODO*'    -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'NEWS*'    -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'THANKS*'  -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'README*'  -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'COPYING*' -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'LICENSE*' -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'AUTHORS*' -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'CHANGES*' -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'CHANGELOG*' -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'CONTRIBUTORS*' -exec mv {} "$PACKAGE_METAINFO_DIR/" \;
    find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -iname 'CONTRIBUTING*' -exec mv {} "$PACKAGE_METAINFO_DIR/" \;

    find "$PACKAGE_WORKING_DIR"        -mindepth 1 -maxdepth 1 -name 'dependencies.*' -exec mv {} "$PACKAGE_METAINFO_DIR/" \;

    for dir in "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR"
    do
        if [ -f "$dir/config.log" ] ; then
            mv  "$dir/config.log" "$PACKAGE_METAINFO_DIR"
        fi
    done

    for dir in "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR"
    do
        if [ -f "$dir/compile_commands.json" ] ; then
            mv  "$dir/compile_commands.json" "$PACKAGE_METAINFO_DIR"
        fi
    done

    #########################################################################################

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "install dependency formulas"

        install -d "$PACKAGE_METAINFO_DIR/formula"

        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            cp "$SESSION_DIR/$DEPENDENT_PACKAGE_NAME.yml" "$PACKAGE_METAINFO_DIR/formula/"
        done
    }

    #########################################################################################

    if [ "$TARGET_PLATFORM_NAME" = macos ] ; then
        step "adjust Mach-O files for ${COLOR_GREEN}$*${COLOR_OFF}"
        __adjust_mach_o_files_for_the_given_target "$@"
    else
        step "adjust ELF files for ${COLOR_GREEN}$*${COLOR_OFF}"
        __adjust_elf_files_for_the_given_target "$@"
    fi

    if [ -d "$PACKAGE_INSTALL_DIR/lib" ] ; then
        step "adjust .la files for ${COLOR_GREEN}$*${COLOR_OFF}"
        __adjust_la_files_for_the_given_target "$@"

        step "adjust .pc files for ${COLOR_GREEN}$*${COLOR_OFF}"
        __adjust_pc_files_for_the_given_target "$@"
    fi

    #########################################################################################

    step "generate MANIFEST.txt"
    __generate_installed_manifest_of_the_given_package "$1"

    step "generate RECEIPT.yml"
    __generate_receipt_of_the_given_package "$1"

    step "generate index"
    run ln -s -r -f -T "$PACKAGE_INSTALL_DIR" "$PPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_SPEC/$PACKAGE_NAME"

    #if [ "$CROSS_COMPILING" = 0 ] && [ "$PACKAGE_SYMLINK" = 1 ] ; then
    #    step "symlink installed files to $PPKG_PACKAGE_SYMLINKED_ROOT"
    #    __symlink_installed_files_of_the_given_package "$1"
    #fi

    #########################################################################################

    [ "$CCACHE_ENABLED" = 1 ] && {
        step "show ccache statistics summary"
        note "Before Build:"
        run  cat "$PACKAGE_WORKING_DIR/ccache-s.txt"
        note "After  Build:"
        run  ccache -s
    }

    [ "$KEEP_SESSION_DIR" != 1 ] && {
        step "delete the working directory"
        run rm -rf "$PACKAGE_WORKING_DIR"
    }

    step "show installed files in tree-like format"
    run tree --dirsfirst -a "$PACKAGE_INSTALL_DIR"
}

__adjust_elf_files_for_the_given_target() {
    BASE64_ENCODED_RELATIVE_FILEPATH_LIST=
    BASE64_ENCODED_RELATIVE_FILEPATH_LIST="$(cd "$PACKAGE_INSTALL_DIR" && find -not -name . -type f -exec base64-encode '{}' \;)"

    for BASE64_ENCODED_RELATIVE_FILEPATH in $BASE64_ENCODED_RELATIVE_FILEPATH_LIST
    do
        BASE64_DECODED_RELATIVE_FILEPATH=
        BASE64_DECODED_RELATIVE_FILEPATH="$(base64-decode "$BASE64_ENCODED_RELATIVE_FILEPATH")"

        FILEPATH="$PACKAGE_INSTALL_DIR/${BASE64_DECODED_RELATIVE_FILEPATH#./}"

        [ -w "$FILEPATH" ] || continue

        FILE_HEADER_ACTUAL=
        FILE_HEADER_ACTUAL="$(head -c 18 "$FILEPATH" | base16-encode)"

        ELF_TYPE_EXECUTABLE=0
        ELF_TYPE_SHAREDABLE=0

        # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
        case $FILE_HEADER_ACTUAL in
            7F454C460[12]01010[0239C]00000000000000000100)
                continue
                ;;
            7F454C460[12]01010[0239C]00000000000000000200)
                # little-endian mode
                ELF_TYPE_EXECUTABLE=1
                ;;
            7F454C460[12]01010[0239C]00000000000000000300)
                # little-endian mode
                ELF_TYPE_SHAREDABLE=1
                ;;
            7F454C460[12]02010[0239C]00000000000000000001)
                continue
                ;;
            7F454C460[12]02010[0239C]00000000000000000002)
                # big-endian mode
                ELF_TYPE_EXECUTABLE=1
                ;;
            7F454C460[12]02010[0239C]00000000000000000003)
                # big-endian mode
                ELF_TYPE_SHAREDABLE=1
                ;;
            7F454C46*)
                abort 1 "mismatched ELF header: $FILEPATH, $FILE_HEADER_ACTUAL"
                ;;
            *)  continue
        esac

        # https://github.com/NixOS/patchelf/issues/371

        if [ "$BUILD_TYPE" = release ] ; then
            if [ "$ELF_TYPE_EXECUTABLE" = 1 ] ; then
                # freebsd's strip has problem
                if [ "$NATIVE_OS_KIND" != freebsd ] ; then
                    run "$STRIP" $STRIP_ARG "$FILEPATH" || true
                fi
            fi
        fi

        if [ "$ELF_TYPE_EXECUTABLE" = 1 ] || [ "$ELF_TYPE_SHAREDABLE" = 1 ] ; then
            DT_NEEDED=
            DT_NEEDED="$(patchelf --print-needed "$FILEPATH" 2>/dev/null || true)"

            DT_RUNPATH=
            DT_RUNPATH="$(patchelf --print-rpath "$FILEPATH" 2>/dev/null | tr ':' ' ')"

            if [ -n "$DT_RUNPATH" ] ; then
                run patchelf --remove-rpath "$FILEPATH"
            fi

            unset RUNPATH

            PACKAGE_LIBRARY_DIR="$PACKAGE_INSTALL_DIR/lib"

            if [ -d "$PACKAGE_LIBRARY_DIR" ] ; then
                for NEEDED in $DT_NEEDED
                do
                    if [ -e "$PACKAGE_LIBRARY_DIR/$NEEDED" ] ; then
                        RUNPATH="$PACKAGE_LIBRARY_DIR"
                        break
                    fi
                done
            fi

            for NEEDED in $DT_NEEDED
            do
                case $NEEDED in
                    libc.so.6) ;;
                    libm.so.6) ;;
                    libgcc_s.so.1) ;;
                    ld-linux-x86-64.so.2) ;;
                    *)  for LIBDIR in $DT_RUNPATH
                        do
                            if [ "$LIBDIR" = "$PACKAGE_LIBRARY_DIR" ] ; then
                                continue
                            fi

                            if [ "$LIBDIR" = "$PACKAGE_WORKING_DIR/lib" ] ; then
                                continue
                            fi

                            if [ -e "$LIBDIR/$NEEDED" ] ; then
                                if [ -z "$RUNPATH" ] ; then
                                    RUNPATH="$LIBDIR"
                                else
                                    RUNPATH="$RUNPATH:$LIBDIR"
                                fi
                                break
                            fi
                        done
                esac
            done

            if [ -n "$RUNPATH" ] ; then
                run patchelf --set-rpath "$RUNPATH" "$FILEPATH"
            fi
        fi
    done
}

__adjust_mach_o_files_for_the_given_target() {
    BASE64_ENCODED_RELATIVE_FILEPATH_LIST=
    BASE64_ENCODED_RELATIVE_FILEPATH_LIST="$(cd "$PACKAGE_INSTALL_DIR" && find . -not -name . -type f -exec base64-encode '{}' \;)"

    for BASE64_ENCODED_RELATIVE_FILEPATH in $BASE64_ENCODED_RELATIVE_FILEPATH_LIST
    do
        BASE64_DECODED_RELATIVE_FILEPATH=
        BASE64_DECODED_RELATIVE_FILEPATH="$(base64-decode "$BASE64_ENCODED_RELATIVE_FILEPATH")"

        FILEPATH="$PACKAGE_INSTALL_DIR/${BASE64_DECODED_RELATIVE_FILEPATH#./}"

        FILE_HEADER_ACTUAL=
        FILE_HEADER_ACTUAL="$(head -c 16 "$FILEPATH" | base16-encode)"

        # https://github.com/aidansteele/osx-abi-macho-file-format-reference
        case $FILE_HEADER_ACTUAL in
            CFFAEDFE0C000001000000000[26]000000)
                # arm64
                ;;
            CFFAEDFE07000001030000000[26]000000)
                # x86_64
                ;;
            *)  continue
        esac

        DT_SONAME=
        DT_SONAME="$( otool -l "$FILEPATH" | grep LC_ID_DYLIB   -A2 | grep name | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)"

        DT_NEEDED=
        DT_NEEDED="$( otool -l "$FILEPATH" | grep LC_LOAD_DYLIB -A2 | grep name | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)"

        DT_RUNPATH=
        DT_RUNPATH="$(otool -l "$FILEPATH" | grep LC_RPATH      -A2 | grep path | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)"

        if [ -z "$DT_NEEDED" ] ; then
            abort 1 "no dependent shared libraries found in $FILEPATH"
        fi

        echo "DT_SONAME=\n$DT_SONAME"
        echo "DT_NEEDED=\n$DT_NEEDED"
        echo "DT_RUNPATH=\n$DT_RUNPATH"

        case $DT_SONAME in
            '') ;;
            @*) ;;
            /*) ;;
            lib*.dylib) run install_name_tool -id "@rpath/$DT_SONAME" "$FILEPATH"
        esac

        for NEEDED in $DT_NEEDED
        do
            case $NEEDED in
                lib*.dylib)
                    run install_name_tool -change "$NEEDED" "@rpath/$NEEDED" "$FILEPATH"
            esac
        done

        if [ "$BUILD_TYPE" = release ] ; then
            run "$STRIP" $STRIP_ARG "$FILEPATH" || true
        fi
    done
}

__adjust_la_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib" ] || {
        note "no .la files installed, skipped"
        return 0
    }

    LA_FILES="$(find "$PACKAGE_INSTALL_DIR/lib" -name "*.la")"

    [ -z "$LA_FILES" ] && {
        note "no .la files installed, skipped"
        return 0
    }

    for lafile in $LA_FILES
    do
        sed_in_place 's|-Wl,--strip-debug||g'      "$lafile"
        sed_in_place "s|-L${PPKG_HOME}[^' ]*||g"   "$lafile"
        sed_in_place "s|-R[^' ]*||g"               "$lafile"
        #sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$lafile"
        #sed_in_place "s|--sysroot $SYSROOT||g"     "$lafile"
    done
}

__adjust_pc_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" ] || {
        note "no .pc files installed, skipped"
        return 0
    }

    PC_FILES="$(find "$PACKAGE_INSTALL_DIR/lib/pkgconfig" -name "*.pc")"

    [ -z "$PC_FILES" ] && {
        note "no .pc files installed, skipped"
        return 0
    }

    # cc: error: unrecognized command line option â€˜-Râ€™
    for pcfile in $PC_FILES
    do
        sed_in_place "s|$PACKAGE_INSTALL_DIR|\${pcfiledir}/../..|g" "$pcfile"
        sed_in_place 's|-Wl,--strip-debug||g'      "$pcfile"
        sed_in_place "s|-L${PPKG_HOME}[^' ]*||g"   "$pcfile"
        sed_in_place "s|${PPKG_HOME}/.*/lib.*\.a||g" "$pcfile"
        sed_in_place "s|-R[^' ]*||g"               "$pcfile"
        sed_in_place "s|-pthread|-lpthread|g"      "$pcfile"
        #sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$pcfile"
        #sed_in_place "s|--sysroot $SYSROOT||"      "$pcfile"

        if grep 'Libs.private:' "$pcfile" > /dev/null ; then
            if grep 'Libs:' "$pcfile" > /dev/null ; then
                LIBS_PRIVATE_CONTENT=$(sed -n '/Libs.private:/p' "$pcfile" | cut -c14-)
                sed_in_place "/Libs:/s|\$|$LIBS_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Libs.private:/d' "$pcfile"
            else
                sed_in_place 's|Libs.private:|Libs:|' "$pcfile"
            fi
        fi

        if grep 'Requires.private:' "$pcfile" > /dev/null ; then
            if grep 'Requires:' "$pcfile" > /dev/null ; then
                REQUIRES_PRIVATE_CONTENT=$(sed -n '/Requires.private:/p' "$pcfile" | cut -c18-)
                sed_in_place "/Requires:/s|\$|$REQUIRES_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Requires.private:/d' "$pcfile"
            else
                sed_in_place 's|Requires.private:|Requires:|' "$pcfile"
            fi
        fi
    done
}

# install_incs [:sub-dir] <FILE>...
install_incs() {
    unset X

    case $1 in
        :*) X="${1#:}"; shift
    esac

    while [ -n "$1" ]
    do
        install -v -d          "$PACKAGE_INSTALL_DIR/include/$X/"
        install -v -m 644 "$1" "$PACKAGE_INSTALL_DIR/include/$X/"
        shift
    done
}

install_libs() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib"
    for item in "$@"
    do
        case $item in
            *.a) install -v -m 644 "$item" "$PACKAGE_INSTALL_DIR/lib" ;;
            *)   install -v -m 755 "$item" "$PACKAGE_INSTALL_DIR/lib" ;;
        esac
    done
}

install_pcfs() {
    install -v -d          "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    install -v -m 644 "$@" "$PACKAGE_INSTALL_DIR/lib/pkgconfig"
}

install_bins() {
    install -v -d          "$PACKAGE_INSTALL_DIR/bin" &&
    install -v -m 755 "$@" "$PACKAGE_INSTALL_DIR/bin"
}

install_etcs() {
    install -v -d          "$PACKAGE_INSTALL_DIR/etc" &&
    install -v -m 644 "$@" "$PACKAGE_INSTALL_DIR/etc"
}

install_mans() {
    for item in "$@"
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    abort 1 "$item: not a manpage."
        esac
        install -v -d             "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 "$item" "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER"
    done
}

# install_completion <fish|bash|zsh> <COMMAND> <FILE-PATH>
  install_completion() {
    case $1 in
        bash)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/bash/completions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/bash/completions/$2"
            ;;
        fish)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d/$2.fish"
            ;;
        zsh)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/zsh/site-functions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/zsh/site-functions/_$2"
            ;;
        *)  abort 1 "install_completion unsupported shell: $1"
    esac
}

# __symlink_installed_files_of_the_given_package <PACKAGE-NAME>
  __symlink_installed_files_of_the_given_package() {
    # while read -r item
    # do
    #     X=$(printf '%s\n' "$item" | cut -d '|' -f1)
    #     Y=$(printf '%s\n' "$item" | cut -d '|' -f3)

    #     case $X in
    #         d)  ;;
    #         D)  ;;
    #         *)  case $Y in
    #                 share/info/dir) ;;
    #                 *)  if [ -L "$PPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] || [ -e "$PPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] ; then
    #                         abort 1 "$PPKG_PACKAGE_SYMLINKED_ROOT/$Y already exists."
    #                     # else
    #                     #     echo "$PPKG_PACKAGE_SYMLINKED_ROOT/$Y"
    #                     fi
    #             esac
    #     esac
    # done < "$PACKAGE_MANIFEST_FILEPATH"

    # ############################################################################

    if [ !      -d "$PPKG_PACKAGE_SYMLINKED_ROOT/.registry" ] ; then
        install -d "$PPKG_PACKAGE_SYMLINKED_ROOT/.registry"
    fi

    exec 7> "$PPKG_PACKAGE_SYMLINKED_ROOT/.registry/$1"

    while read -r item
    do
        X=$(printf '%s\n' "$item" | cut -d '|' -f1)
        Y=$(printf '%s\n' "$item" | cut -d '|' -f3)

        case $X in
            d|D)
                if [ !      -d "$PPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] ; then
                    install -d "$PPKG_PACKAGE_SYMLINKED_ROOT/$Y"
                fi
                ;;
            *)  case $Y in
                    share/info/dir) ;;
                    *)  run ln -sfr "\"$PPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_SPEC/$1/$Y\"" "\"$PPKG_PACKAGE_SYMLINKED_ROOT/$Y\""
                        printf '%s\n' "$Y" >&7
                esac
        esac
    done < "$PACKAGE_MANIFEST_FILEPATH"

    exec 7>&-
}

# __generate_installed_manifest_of_the_given_package <PACKAGE-NAME>
  __generate_installed_manifest_of_the_given_package() {
    # fuck, some package's filename has space
    export IFS='
'

    exec 7> "$PACKAGE_MANIFEST_FILEPATH"

    for dirname in $(find -mindepth 1 -maxdepth 1 -type d -not -name .ppkg -printf '%P\n')
    do
        for item in $(find "$dirname" -printf '%y:%p\n')
        do
            X=$(printf '%s\n' "$item" | cut -c1)
            Y=${item#"$X":}

            case $X in
                l)  if [ -d "$Y" ] ; then
                        printf 'D|0000000000000000000000000000000000000000000000000000000000000000|%s/\n' "$Y" >&7
                    else
                        printf 'l|%s|%s\n' "$(sha256sum "$Y" | cut -d ' ' -f1)"                           "$Y" >&7
                    fi
                    ;;
                d)  printf 'd|0000000000000000000000000000000000000000000000000000000000000000|%s/\n' "$Y" >&7 ;;
                *)  printf '%s|%s|%s\n' "$X" "$(sha256sum "$Y" | cut -d ' ' -f1)"                     "$Y" >&7 ;;
            esac
        done
    done

    exec 7>&-

    unset IFS
}

__check_if_build_for_specific_linux_libc() {
    BUILD_FOR_SPECIFIC_LIBC=0

    if [ "$TARGET_PLATFORM_NAME" != linux ] ; then
        return 0
    fi

    PACKAGE_INSTALLED_DIR="$1"

    PACKAGE_INSTALLED_LIBRARY_DIR="$PACKAGE_INSTALLED_DIR/lib"

    if [ -d "$PACKAGE_INSTALLED_LIBRARY_DIR" ] ; then
        for FILEPATH in $(find "$PACKAGE_INSTALLED_LIBRARY_DIR" -type f)
        do
            case $FILEPATH in
                */lib*.a)   BUILD_FOR_SPECIFIC_LIBC=1; return 0 ;;
                */lib*.so*) BUILD_FOR_SPECIFIC_LIBC=1; return 0 ;;
                */*.o)      BUILD_FOR_SPECIFIC_LIBC=1; return 0 ;;
            esac
        done
    fi

    for item in bin sbin
    do
        PACKAGE_INSTALLED_BINARY_DIR="$PACKAGE_INSTALLED_DIR/$item"

        if [ -d "$PACKAGE_INSTALLED_BINARY_DIR" ] ; then
            for FILEPATH in $(find "$PACKAGE_INSTALLED_BINARY_DIR" -type f)
            do
                FILEMAGIC=
                FILEMAGIC="$(head -c 4 "$FILEPATH" | base16-encode)"

                if [ "$FILEMAGIC" = '7F454C46' ] ; then
                    # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
                    PT_INTERP=
                    PT_INTERP="$(patchelf --print-interpreter "$FILEPATH" 2>/dev/null || true)"

                    if [ -n "$PT_INTERP" ] ; then
                        BUILD_FOR_SPECIFIC_LIBC=1
                        return 0
                    fi
                fi
            done
        fi
    done

    for FILEPATH in $(find "$PACKAGE_INSTALLED_DIR" -type f -a -name "*.a")
    do
        BUILD_FOR_SPECIFIC_LIBC=1
        return 0
    done

    for FILEPATH in $(find "$PACKAGE_INSTALLED_DIR" -type f -a -name "*.so")
    do
        BUILD_FOR_SPECIFIC_LIBC=1
        return 0
    done
}

# }}}
##############################################################################
# {{{ operation of receipt

# __generate_receipt_of_the_given_package <PACKAGE-NAME>
  __generate_receipt_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__generate_receipt_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."

    __check_if_build_for_specific_linux_libc "$PACKAGE_INSTALL_DIR"

    run cp "$PACKAGE_FORMULA_FILEPATH" "$PACKAGE_RECEIPT_FILEPATH"

    sed_in_place '/^#src-url: dir:/d' "$PACKAGE_RECEIPT_FILEPATH"

    sed_in_place "1i pkgname: $PACKAGE_NAME" "$PACKAGE_RECEIPT_FILEPATH"

    grep -q '^version: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "2i version: $PACKAGE_VERSION" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^web-url: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^git-url:/i web-url: $PACKAGE_GIT_URL" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^bsystem: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^install:/i bsystem: $PACKAGE_BSYSTEM" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^binbstd: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^bsystem:/a binbstd: $PACKAGE_BINBSTD" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^parallel: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "\$a parallel: $PACKAGE_PARALLEL" "$PACKAGE_RECEIPT_FILEPATH"
    }

    [ -n "$PACKAGE_GIT_SHA" ] && {
        grep -q '^git-sha: ' "$PACKAGE_RECEIPT_FILEPATH" || {
            sed_in_place "/^git-url:/a git-sha: $PACKAGE_GIT_SHA" "$PACKAGE_RECEIPT_FILEPATH"
        }

        grep -q '^git-sha: ' "$PACKAGE_RECEIPT_FILEPATH" || {
            sed_in_place "3i git-sha: $PACKAGE_GIT_SHA" "$PACKAGE_RECEIPT_FILEPATH"
        }
    }

    [ -n "$PACKAGE_DEP_UPP" ] && {
        if grep -q '^dep-upp: ' "$PACKAGE_RECEIPT_FILEPATH" ; then
            sed_in_place "/^dep-upp: /c dep-upp: $PACKAGE_DEP_UPP" "$PACKAGE_RECEIPT_FILEPATH"
        else
            sed_in_place "/^bsystem: /i dep-upp: $PACKAGE_DEP_UPP" "$PACKAGE_RECEIPT_FILEPATH"
        fi
    }

    cat >> "$PACKAGE_RECEIPT_FILEPATH" <<EOF
builtfor: $TARGET_PLATFORM_SPEC
builtby: ppkg-$PPKG_VERSION
builtat: $TIMESTAMP_UNIX
builton:
    os-arch: $NATIVE_OS_ARCH
    os-kind: $NATIVE_OS_KIND
    os-type: $NATIVE_OS_TYPE
    os-libc: $NATIVE_OS_LIBC
    os-code: $NATIVE_OS_CODE
    os-name: $NATIVE_OS_NAME
    os-vers: $NATIVE_OS_VERS
    os-ncpu: $NATIVE_OS_NCPU
    os-euid: $NATIVE_OS_EUID
    os-egid: $NATIVE_OS_EGID
EOF
}

# __load_receipt_of_the_given_package <PACKAGE-NAME|PACKAGE-SPEC>
  __load_receipt_of_the_given_package() {
    PACKAGE_SPEC=
    PACKAGE_SPEC="$(inspect_package_spec "$1")"

    is_package_installed "$PACKAGE_SPEC"

    [ $? -eq 0 ] || return $?

    PACKAGE_INSTALLED_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"

    PACKAGE_RECEIPT_FILEPATH="$PACKAGE_INSTALLED_DIR/.ppkg/RECEIPT.yml"

    unset RECEIPT_PACKAGE_PKGNAME
    unset RECEIPT_PACKAGE_SUMMARY
    unset RECEIPT_PACKAGE_VERSION
    unset RECEIPT_PACKAGE_LICENSE

    unset RECEIPT_PACKAGE_WEB_URL

    unset RECEIPT_PACKAGE_GIT_URL
    unset RECEIPT_PACKAGE_GIT_SHA
    unset RECEIPT_PACKAGE_GIT_REF
    unset RECEIPT_PACKAGE_GIT_NTH

    unset RECEIPT_PACKAGE_SRC_URL
    unset RECEIPT_PACKAGE_SRC_URI
    unset RECEIPT_PACKAGE_SRC_SHA

    unset RECEIPT_PACKAGE_FIX_URL
    unset RECEIPT_PACKAGE_FIX_URI
    unset RECEIPT_PACKAGE_FIX_SHA

    unset RECEIPT_PACKAGE_RES_URL
    unset RECEIPT_PACKAGE_RES_URI
    unset RECEIPT_PACKAGE_RES_SHA

    unset RECEIPT_PACKAGE_DEP_PKG
    unset RECEIPT_PACKAGE_DEP_UPP
    unset RECEIPT_PACKAGE_DEP_PYM
    unset RECEIPT_PACKAGE_DEP_PLM

    unset RECEIPT_PACKAGE_BSYSTEM
    unset RECEIPT_PACKAGE_BSCRIPT
    unset RECEIPT_PACKAGE_DOPATCH
    unset RECEIPT_PACKAGE_INSTALL
    unset RECEIPT_PACKAGE_SYMLINK

    unset RECEIPT_PACKAGE_PARALLEL

    unset RECEIPT_PACKAGE_BUILTBY
    unset RECEIPT_PACKAGE_BUILTAT

    unset RECEIPT_PACKAGE_BUILTFOR
    unset RECEIPT_PACKAGE_BUILTFOR_PLATFORM
    unset RECEIPT_PACKAGE_BUILTFOR_PLATFORM_NAME
    unset RECEIPT_PACKAGE_BUILTFOR_PLATFORM_VERS
    unset RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH


    RECEIPT_PACKAGE_PKGNAME="$(yq '.pkgname | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_SUMMARY="$(yq '.summary | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_LICENSE="$(yq '.license | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_VERSION="$(yq '.version | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_WEB_URL="$(yq '.web-url | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_GIT_URL="$(yq '.git-url | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_GIT_SHA="$(yq '.git-sha | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_GIT_REF="$(yq '.git-ref | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_GIT_NTH="$(yq '.git-nth | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_SRC_URL="$(yq '.src-url | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_SRC_URI="$(yq '.src-uri | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_SRC_SHA="$(yq '.src-sha | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_FIX_URL="$(yq '.fix-url | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_FIX_URI="$(yq '.fix-uri | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_FIX_SHA="$(yq '.fix-sha | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_RES_URL="$(yq '.res-url | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_RES_URI="$(yq '.res-uri | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_RES_SHA="$(yq '.res-sha | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_DEP_PKG="$(yq '.dep-pkg | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_DEP_UPP="$(yq '.dep-upp | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_DEP_PYM="$(yq '.dep-pym | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_DEP_PLM="$(yq '.dep-plm | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_BSYSTEM="$(yq '.bsystem | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_BSCRIPT="$(yq '.bscript | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_BINBSTD="$(yq '.binbstd | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_CCFLAGS="$(yq '.ccflags | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_XXFLAGS="$(yq '.xxflags | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_PPFLAGS="$(yq '.ppflags | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_LDFLAGS="$(yq '.ldflags | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_DOPATCH="$(yq '.dopatch | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_INSTALL="$(yq '.install | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_SYMLINK="$(yq '.symlink | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_BUILTBY="$(yq '.builtby | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"
    RECEIPT_PACKAGE_BUILTAT="$(yq '.builtat | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_BUILTFOR="$(yq '.builtfor | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_PARALLEL="$(yq '.parallel | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    RECEIPT_PACKAGE_DEVELOPER="$(yq '.developer | select(. != null)' "$PACKAGE_RECEIPT_FILEPATH")"

    if [ "${PACKAGE_SPEC##*/}" != "$RECEIPT_PACKAGE_PKGNAME" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of RECEIPT_PACKAGE_PKGNAME does not identical with your request: ${PACKAGE_SPEC##*/}"
        return 1
    fi

    if [ "${PACKAGE_SPEC%/*}" != "$RECEIPT_PACKAGE_BUILTFOR" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of RECEIPT_PACKAGE_BUILTFOR does not identical with your request: ${PACKAGE_SPEC%/*}"
        return 1
    fi

    RECEIPT_PACKAGE_BUILTFOR_PLATFORM="$RECEIPT_PACKAGE_BUILTFOR"

    RECEIPT_PACKAGE_BUILTFOR_PLATFORM_NAME="$(printf '%s' "$RECEIPT_PACKAGE_BUILTFOR_PLATFORM" | cut -d- -f1)"
    RECEIPT_PACKAGE_BUILTFOR_PLATFORM_VERS="$(printf '%s' "$RECEIPT_PACKAGE_BUILTFOR_PLATFORM" | cut -d- -f2)"
    RECEIPT_PACKAGE_BUILTFOR_PLATFORM_ARCH="$(printf '%s' "$RECEIPT_PACKAGE_BUILTFOR_PLATFORM" | cut -d- -f3)"

    [ -z "$RECEIPT_PACKAGE_BUILTBY" ] && abort 1 "receipt scheme error. builtby mapping was not found in $PACKAGE_RECEIPT_FILEPATH."
    [ -z "$RECEIPT_PACKAGE_BUILTAT" ] && abort 1 "receipt scheme error. builtat mapping was not found in $PACKAGE_RECEIPT_FILEPATH."
    [ -z "$RECEIPT_PACKAGE_VERSION" ] && abort 1 "receipt scheme error. version mapping was not found in $PACKAGE_RECEIPT_FILEPATH."
    [ -z "$RECEIPT_PACKAGE_SUMMARY" ] && abort 1 "receipt scheme error. summary mapping was not found in $PACKAGE_RECEIPT_FILEPATH."
    [ -z "$RECEIPT_PACKAGE_WEB_URL" ] && abort 1 "receipt scheme error. web-url mapping was not found in $PACKAGE_RECEIPT_FILEPATH."

    [ "${#RECEIPT_PACKAGE_BUILTAT}" -eq 10 ] || abort 1 "receipt scheme error. timestamp mapping's value length must be 10."
}

# }}}
##############################################################################
# {{{ ppkg install

__install_the_given_packages() {
    __inspect_install_arguments "$@"

    [ -z "$SPECIFIED_PACKAGE_SPEC_LIST" ] && abort 1 "$_0 install <PACKAGE-SPEC|PACKAGE-NAME>..., <|PACKAGE-SPEC|PACKAGE-NAME> is unspecified."

    #########################################################################################

    SESSION_DIR="$PPKG_HOME/run/$$"

    rm -rf     "$SESSION_DIR"
    install -d "$SESSION_DIR"

    #########################################################################################

    # 1. check if has circle
    # 2. backup formulas
    # 3. cache variables

    for SPECIFIED_PACKAGE_SPEC in $SPECIFIED_PACKAGE_SPEC_LIST
    do
        PACKAGE_NAME_STACK="${SPECIFIED_PACKAGE_SPEC##*/}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            if [ -f "$SESSION_DIR/$PACKAGE_NAME.yml" ] ; then
                continue
            fi

            __load_formula_of_the_given_package "$PACKAGE_NAME"

            cp "$PACKAGE_FORMULA_FILEPATH" "$SESSION_DIR/$PACKAGE_NAME.yml"

            eval "PACKAGE_DEP_PKG_${PACKAGE_NAME_UPPERCASE_UNDERSCORE}='$PACKAGE_DEP_PKG'"

            for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
            do
                if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                    abort 1 "package '$PACKAGE_NAME' depends itself."
                fi

                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$DEPENDENT_PACKAGE_NAME"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$DEPENDENT_PACKAGE_NAME"
                fi
            done
        done
    done

    #########################################################################################

    for SPECIFIED_PACKAGE_SPEC in $SPECIFIED_PACKAGE_SPEC_LIST
    do
        TARGET_PLATFORM_SPEC="${SPECIFIED_PACKAGE_SPEC%/*}"

        TARGET_PLATFORM_NAME=
        TARGET_PLATFORM_VERS=
        TARGET_PLATFORM_ARCH=

        TARGET_PLATFORM_NAME="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f1)"
        TARGET_PLATFORM_VERS="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f2)"
        TARGET_PLATFORM_ARCH="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f3)"

        ##################################################################

        REQUESTED_PACKAGE_NAME_LIST=

        PACKAGE_NAME_STACK="${SPECIFIED_PACKAGE_SPEC##*/}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            ##################################################################

            REQUESTED_PACKAGE_NAME_LIST2="$PACKAGE_NAME"

            for item in $REQUESTED_PACKAGE_NAME_LIST
            do
                [ "$item" = "$PACKAGE_NAME" ] && continue
                REQUESTED_PACKAGE_NAME_LIST2="$REQUESTED_PACKAGE_NAME_LIST2 $item"
            done

            REQUESTED_PACKAGE_NAME_LIST="$REQUESTED_PACKAGE_NAME_LIST2"

            ##################################################################

            PACKAGE_NAME_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')"

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${PACKAGE_NAME_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$item"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
                fi
            done
        done

        ##################################################################

        for PACKAGE_NAME in $REQUESTED_PACKAGE_NAME_LIST
        do
            PACKAGE_SPEC="$TARGET_PLATFORM_SPEC/$PACKAGE_NAME"

            if is_package_installed "$PACKAGE_SPEC" ; then
                if [ "$UPGRAGE" = 1 ] ; then
                    if is_package__outdated "$PACKAGE_SPEC" ; then
                        (__install_the_given_package "$PACKAGE_SPEC")
                    else
                        if [ "$LOG_LEVEL" -gt 0 ] ; then
                            printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed and is up-to-date.\n" "$PACKAGE_SPEC"
                        fi
                    fi
                else
                    if [ "$LOG_LEVEL" -gt 0 ] ; then
                        printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$PACKAGE_SPEC"
                    fi
                fi
            else
                (__install_the_given_package "$PACKAGE_SPEC")
            fi
        done
    done

    #########################################################################################

    if [ "$KEEP_SESSION_DIR" != 1 ] ; then
        rm -rf "$SESSION_DIR"
    fi
}

# }}}
##############################################################################
# {{{ ppkg reinstall

__reinstall_the_given_packages() {
    __inspect_install_arguments "$@"

    [ -z "$SPECIFIED_PACKAGE_SPEC_LIST" ] && abort 1 "neither package-name nor package-spec is specified."

    #########################################################################################

    SESSION_DIR="$PPKG_HOME/run/$$"

    rm -rf     "$SESSION_DIR"
    install -d "$SESSION_DIR"

    #########################################################################################

    # 1. check if has circle
    # 2. backup formulas
    # 3. cache variables

    for SPECIFIED_PACKAGE_SPEC in $SPECIFIED_PACKAGE_SPEC_LIST
    do
        PACKAGE_NAME_STACK="${SPECIFIED_PACKAGE_SPEC##*/}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            if [ -f "$SESSION_DIR/$PACKAGE_NAME.yml" ] ; then
                continue
            fi

            __load_formula_of_the_given_package "$PACKAGE_NAME"

            cp "$PACKAGE_FORMULA_FILEPATH" "$SESSION_DIR/$PACKAGE_NAME.yml"

            eval "PACKAGE_DEP_PKG_${PACKAGE_NAME_UPPERCASE_UNDERSCORE}='$PACKAGE_DEP_PKG'"

            for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
            do
                if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                    abort 1 "package '$PACKAGE_NAME' depends itself."
                fi

                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$DEPENDENT_PACKAGE_NAME"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$DEPENDENT_PACKAGE_NAME"
                fi
            done
        done
    done

    #########################################################################################

    for SPECIFIED_PACKAGE_SPEC in $SPECIFIED_PACKAGE_SPEC_LIST
    do
        TARGET_PLATFORM_SPEC="${SPECIFIED_PACKAGE_SPEC%/*}"

        TARGET_PLATFORM_NAME=
        TARGET_PLATFORM_VERS=
        TARGET_PLATFORM_ARCH=

        TARGET_PLATFORM_NAME="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f1)"
        TARGET_PLATFORM_VERS="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f2)"
        TARGET_PLATFORM_ARCH="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f3)"

        ##################################################################

        REQUESTED_PACKAGE_NAME_LIST=

        PACKAGE_NAME_STACK="${SPECIFIED_PACKAGE_SPEC##*/}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            ##################################################################

            REQUESTED_PACKAGE_NAME_LIST2="$PACKAGE_NAME"

            for item in $REQUESTED_PACKAGE_NAME_LIST
            do
                [ "$item" = "$PACKAGE_NAME" ] && continue
                REQUESTED_PACKAGE_NAME_LIST2="$REQUESTED_PACKAGE_NAME_LIST2 $item"
            done

            REQUESTED_PACKAGE_NAME_LIST="$REQUESTED_PACKAGE_NAME_LIST2"

            ##################################################################

            PACKAGE_NAME_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')"

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${PACKAGE_NAME_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$item"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
                fi
            done
        done

        ##################################################################

        for PACKAGE_NAME in $REQUESTED_PACKAGE_NAME_LIST
        do
            PACKAGE_SPEC="$TARGET_PLATFORM_SPEC/$PACKAGE_NAME"

            PACKAGE_INSTALLED_LINK_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
            PACKAGE_INSTALLED_REAL_DIR="$(readlink -f "$PACKAGE_INSTALLED_LINK_DIR")"

            (__install_the_given_package "$PACKAGE_SPEC")

            rm -rf "$PACKAGE_INSTALLED_REAL_DIR"
        done
    done

    #########################################################################################

    if [ "$KEEP_SESSION_DIR" != 1 ] ; then
        rm -rf "$SESSION_DIR"
    fi
}

# }}}
##############################################################################
# {{{ ppkg upgrade

__upgrade_packages() {
    __inspect_install_arguments "$@"

    if [ -z "$SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
        SPECIFIED_PACKAGE_SPEC_LIST=$(__list__outdated_packages)
    fi

    if [ -z "$SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
        return 0
    fi

    #########################################################################################

    SESSION_DIR="$PPKG_HOME/run/$$"

    rm -rf     "$SESSION_DIR"
    install -d "$SESSION_DIR"

    #########################################################################################

    # 1. check if has circle
    # 2. backup formulas
    # 3. cache variables

    for SPECIFIED_PACKAGE_SPEC in $SPECIFIED_PACKAGE_SPEC_LIST
    do
        PACKAGE_NAME_STACK="${SPECIFIED_PACKAGE_SPEC##*/}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            if [ -f "$SESSION_DIR/$PACKAGE_NAME.yml" ] ; then
                continue
            fi

            __load_formula_of_the_given_package "$PACKAGE_NAME"

            cp "$PACKAGE_FORMULA_FILEPATH" "$SESSION_DIR/$PACKAGE_NAME.yml"

            eval "PACKAGE_DEP_PKG_${PACKAGE_NAME_UPPERCASE_UNDERSCORE}='$PACKAGE_DEP_PKG'"

            for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
            do
                if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                    abort 1 "package '$PACKAGE_NAME' depends itself."
                fi

                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$DEPENDENT_PACKAGE_NAME"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$DEPENDENT_PACKAGE_NAME"
                fi
            done
        done
    done

    #########################################################################################

    for SPECIFIED_PACKAGE_SPEC in $SPECIFIED_PACKAGE_SPEC_LIST
    do
        TARGET_PLATFORM_SPEC="${SPECIFIED_PACKAGE_SPEC%/*}"

        TARGET_PLATFORM_NAME=
        TARGET_PLATFORM_VERS=
        TARGET_PLATFORM_ARCH=

        TARGET_PLATFORM_NAME="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f1)"
        TARGET_PLATFORM_VERS="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f2)"
        TARGET_PLATFORM_ARCH="$(printf '%s\n' "$TARGET_PLATFORM_SPEC" | cut -d- -f3)"

        ##################################################################

        REQUESTED_PACKAGE_NAME_LIST=

        PACKAGE_NAME_STACK="${SPECIFIED_PACKAGE_SPEC##*/}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            ##################################################################

            REQUESTED_PACKAGE_NAME_LIST2="$PACKAGE_NAME"

            for item in $REQUESTED_PACKAGE_NAME_LIST
            do
                [ "$item" = "$PACKAGE_NAME" ] && continue
                REQUESTED_PACKAGE_NAME_LIST2="$REQUESTED_PACKAGE_NAME_LIST2 $item"
            done

            REQUESTED_PACKAGE_NAME_LIST="$REQUESTED_PACKAGE_NAME_LIST2"

            ##################################################################

            PACKAGE_NAME_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')"

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${PACKAGE_NAME_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$item"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
                fi
            done
        done

        ##################################################################

        for PACKAGE_NAME in $REQUESTED_PACKAGE_NAME_LIST
        do
            PACKAGE_SPEC="$TARGET_PLATFORM_SPEC/$PACKAGE_NAME"

            is_package__outdated "$PACKAGE_SPEC" || {
                note 1 "$PACKAGE_SPEC is not outdated."
                continue
            }

            PACKAGE_INSTALLED_LINK_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
            PACKAGE_INSTALLED_REAL_DIR="$(readlink -f "$PACKAGE_INSTALLED_LINK_DIR")"

            (__install_the_given_package "$PACKAGE_SPEC")

            rm -rf "$PACKAGE_INSTALLED_REAL_DIR"
        done
    done

    #########################################################################################

    if [ "$KEEP_SESSION_DIR" != 1 ] ; then
        rm -rf "$SESSION_DIR"
    fi
}

# }}}
##############################################################################
# {{{ ppkg uninstall

__uninstall_the_given_packages() {
    [ -z "$1" ] && abort 1 "neither package-name nor package-spec is specified."

    unset PACKAGE_SPECS

    for item in "$@"
    do
        PACKAGE_SPECS="$PACKAGE_SPECS $(inspect_package_spec "$item")"
    done

    for PACKAGE_SPEC in $PACKAGE_SPECS
    do
        PACKAGE_INSTALLED_LINK_DIR="$PPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"

        [ -e "$PACKAGE_INSTALLED_LINK_DIR" ] || abort 10 "package '$PACKAGE_SPEC' is not installed."
        [ -L "$PACKAGE_INSTALLED_LINK_DIR" ] || abort 11 "$PACKAGE_INSTALLED_LINK_DIR was expected a symlink, but it was not."
        [ -d "$PACKAGE_INSTALLED_LINK_DIR" ] || abort 12 "$PACKAGE_INSTALLED_LINK_DIR was expected a symlink refer to a directory, but it was not."

        PACKAGE_INSTALLED_REAL_DIR="$(readlink -f "$PACKAGE_INSTALLED_LINK_DIR")"

        [ -d "$PACKAGE_INSTALLED_REAL_DIR" ] || abort 13 "directory $PACKAGE_INSTALLED_REAL_DIR was expected exists, but it was not."

        PACKAGE_MANIFEST_FILEPATH="$PACKAGE_INSTALLED_REAL_DIR/.ppkg/MANIFEST.txt"

        [ -f "$PACKAGE_MANIFEST_FILEPATH" ] || abort 13 "$PACKAGE_MANIFEST_FILEPATH file was expected exist, but it was not."

        PACKAGE_RECEIPT_FILEPATH="$PACKAGE_INSTALLED_REAL_DIR/.ppkg/RECEIPT.yml"

        [ -f "$PACKAGE_RECEIPT_FILEPATH" ] || abort 14 "$PACKAGE_RECEIPT_FILEPATH file was expected exist, but it was not."

        run rm -ff "$PACKAGE_INSTALLED_LINK_DIR"
        run rm -rf "$PACKAGE_INSTALLED_REAL_DIR"
    done
}

# }}}
##############################################################################
# {{{ ppkg upgrade-self

# __upgrade_self <URL>
  __upgrade_self() {
    [ -z "$1" ] && abort 1 "__upgrade_self <URL> , <URL> must be non-empty."

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath "$CURRENT_SCRIPT_FILEPATH")
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f "$CURRENT_SCRIPT_FILEPATH")
        else
            CURRENT_SCRIPT_REALPATH=$(realpath "$CURRENT_SCRIPT_FILEPATH")
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    SESSION_DIR="$PPKG_HOME/run/$$"

    run rm -rf     "$SESSION_DIR"
    run install -d "$SESSION_DIR"
    run cd         "$SESSION_DIR"

    wfetch "$1" -o self

    run chmod 755 self

    if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
        run      mv self "$CURRENT_SCRIPT_REALPATH"
    else
        run sudo mv self "$CURRENT_SCRIPT_REALPATH"
    fi

    run rm -rf "$SESSION_DIR"
}

# }}}
##############################################################################
# {{{ ppkg integrate zsh

# __integrate_zsh_completions <URL> [--output-dir=<DIR>]
  __integrate_zsh_completions() {
    [ -z "$1" ] && abort 1 "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <URL> must be non-empty."

    ZSH_COMPLETIONS_SCRIPT_URL="$1"

    shift

    unset OUTPUT_DIR

    for arg in "$@"
    do
        case $arg in
            --output-dir=*)
                OUTPUT_DIR="${1#*=}"

                case $OUTPUT_DIR in
                    '')   abort 1 "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <DIR> must be a non-empty string." ;;
                    \~)   OUTPUT_DIR="$HOME" ;;
                    \~/)  OUTPUT_DIR="$HOME" ;;
                    \~/.) OUTPUT_DIR="$HOME" ;;
                    \~/*) OUTPUT_DIR="$HOME/$(printf '%s\n' "$1" | cut -c3-)" ;;
                esac

                ;;
            *)  abort 1 "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , unrecognized argument: $arg"
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ -n "$OUTPUT_DIR" ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="$OUTPUT_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    elif [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        else
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        fi
    fi

    SESSION_DIR="$PPKG_HOME/run/$$"

    run rm -rf     "$SESSION_DIR"
    run install -d "$SESSION_DIR"
    run cd         "$SESSION_DIR"

    wfetch "$ZSH_COMPLETIONS_SCRIPT_URL" -o _ppkg

    run chmod 644 _ppkg

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      mv _ppkg "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo mv _ppkg "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"

        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi

        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      mv _ppkg "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo mv _ppkg "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf "$SESSION_DIR"

    printf '\n'
    note "${COLOR_YELLOW}you may need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ ppkg gen-url-transform-sample

__gen_url_transform_sample() {
    SESSION_DIR="$PPKG_HOME/run/$$"

    rm -rf     "$SESSION_DIR"
    install -d "$SESSION_DIR"
    cd         "$SESSION_DIR"

    cat > url-transform.sample <<EOF
#!/bin/sh

# https://gitmirror.com/
case \$1 in
    *githubusercontent.com/*)
        printf '%s\n' "\$1" | sed 's|githubusercontent|gitmirror|'
        ;;
    https://github.com/*)
        printf 'https://hub.gitmirror.com/%s\n' "\$1"
        ;;
    '') printf '%s\n' "\$0 <URL>, <URL> is unspecified." >&2 ; exit 1 ;;
    *)  printf '%s\n' "\$1"
esac
EOF

    chmod +x url-transform.sample

    install -d "$PPKG_HOME"

    mv url-transform.sample "$PPKG_HOME/"

    rm -rf "$SESSION_DIR"

    success "url-transform sample has been written into $PPKG_HOME/url-transform.sample"
    note "You can rename url-transform.sample to url-transform then edit it to meet your needs. To apply this, you should run 'export PPKG_URL_TRANSFORM=$PPKG_HOME/url-transform' in your terminal."
}

# }}}
##############################################################################
# {{{ ppkg cleanup

__cleanup() {
    success "Done."
}

# }}}
##############################################################################
# {{{ ppkg setup

__setup() {
    SESSION_DIR="$PPKG_HOME/run/$$/core"

    run rm -rf     "$SESSION_DIR"
    run install -d "$SESSION_DIR"
    run cd         "$SESSION_DIR"

    run install -d bin

    ##################################################################################

    NATIVE_OS_KIND="$(uname -s | tr A-Z a-z)"
    NATIVE_OS_ARCH="$(uname -m)"

    if [ "$(id -u)" -ne 0 ] ; then
        sudo=sudo
    else
        unset sudo
    fi

    #################################################################################

    if [ "$1" = '--use-system-package-manager' ] ; then
        step "install needed packages via your system's package manager"

        if [ "$NATIVE_OS_KIND" = linux ] ; then
            unset ID

            if [ -e /etc/os-release ] ; then
                .   /etc/os-release
            fi

            NATIVE_OS_NAME="$ID"
        else
            NATIVE_OS_NAME="$NATIVE_OS_KIND"
        fi

        case $NATIVE_OS_NAME in
            ubuntu)
                run $sudo apt -y update
                run $sudo apt -y install bash coreutils findutils bsdmainutils gawk sed grep tree libarchive-tools patch patchelf pkg-config golang git curl cmake ninja-build make g++ linux-headers-generic flex bison m4 jq
                ;;
            fedora)
                run $sudo dnf -y update
                run $sudo dnf -y install bash coreutils findutils gawk sed grep tree libarchive-tools patch patchelf pkg-config golang git curl cmake ninja-build make g++ flex bison m4 jq
                ;;
            alpine)
                run $sudo apk update
                run $sudo apk add bash coreutils findutils gawk sed grep tree libarchive-tools patch patchelf pkgconf go jq yq git curl cmake ninja make g++ libc-dev linux-headers flex bison m4

                run ln -s /usr/bin/make bin/gmake

                printf 'export ACLOCAL_PATH=/usr/share/aclocal' > profile
                ;;
            darwin)
                BREW="$(command -v brew || true)"

                if [ -z "$BREW" ] ; then
                    wfetch 'https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh' -o homebrew-install.sh --no-buffer
                    run "yes | bash homebrew-install.sh"

                    BREW=$(command -v brew || true)
                else
                    run "$BREW" update
                fi

                unset BREW_PACKAGE_EXEFIND_PATH

                for item in coreutils findutils gawk gsed grep libarchive jq yq git curl tree
                do
                    run "$BREW" install "$item"

                    BREW_PACKAGE_INSTALLED_DIR=
                    BREW_PACKAGE_INSTALLED_DIR="$(brew --prefix "$item")"

                    if [ -d "$BREW_PACKAGE_INSTALLED_DIR/bin" ] ; then
                        BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/bin"
                    fi

                    if [ -d "$BREW_PACKAGE_INSTALLED_DIR/sbin" ] ; then
                        BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/sbin"
                    fi

                    if [ -d "$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin" ] ; then
                        BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin"
                    fi
                done

                BREW_PACKAGE_EXEFIND_PATH="${BREW_PACKAGE_EXEFIND_PATH#':'}"

                run ln -sf /usr/local/bin/gln      bin/ln
                run ln -sf /usr/local/bin/gsed     bin/sed
                run ln -sf /usr/local/bin/gawk     bin/awk
                run ln -sf /usr/local/bin/ggrep    bin/grep
                run ln -sf /usr/local/bin/gfind    bin/find
                run ln -sf /usr/local/bin/gbase64  bin/base64
                run ln -sf /usr/local/bin/gunlink  bin/unlink
                run ln -sf /usr/local/bin/ginstall bin/install
                run ln -sf /usr/local/bin/gsha256sum bin/sha256sum

                cat > profile <<EOF
export ACLOCAL_PATH=/usr/local/share/aclocal
export PATH="$BREW_PACKAGE_EXEFIND_PATH:\$PATH"
EOF
                ;;
            freebsd|dragonfly)
                run $sudo pkg update
                run $sudo pkg install -y bash coreutils findutils gawk gsed gnugrep tree patch patchelf pkgconf go go-yq jq git curl cmake ninja gmake gcc flex bison m4

                run ln -sf /usr/local/bin/gln        bin/ln
                run ln -sf /usr/local/bin/gm4        bin/m4
                run ln -sf /usr/local/bin/gsed       bin/sed
                run ln -sf /usr/local/bin/gawk       bin/awk
                run ln -sf /usr/local/bin/ggrep      bin/grep
                run ln -sf /usr/local/bin/gfind      bin/find
                run ln -sf /usr/local/bin/gmake      bin/make
                run ln -sf /usr/local/bin/gdate      bin/date
                run ln -sf /usr/local/bin/gbase64    bin/base64
                run ln -sf /usr/local/bin/gunlink    bin/unlink
                run ln -sf /usr/local/bin/ginstall   bin/install
                run ln -sf /usr/local/bin/gsha256sum bin/sha256sum

                printf 'export ACLOCAL_PATH=/usr/local/share/aclocal' > profile
                ;;
            openbsd)
                # pkg.m4 is in metaauto package, not in pkgconf package. metaauto package is usually depended by automake-1.16.3 package
                #
                # https://man.openbsd.org/pkg_add
                case $(uname -r) in
                    6.[0-9]) run $sudo pkg_add bash coreutils findutils gawk gsed ggrep libarchive gpatch pkgconf metaauto go git curl cmake ninja gmake gcc flex bison m4 jq ;;
                    7.[0-9]) run $sudo pkg_add bash coreutils findutils gawk gsed ggrep libarchive gpatch pkgconf metaauto go git curl cmake ninja gmake gcc%11 patchelf bison m4 jq
                esac

                run ln -sf /usr/local/bin/gln        bin/ln
                run ln -sf /usr/local/bin/gm4        bin/m4
                run ln -sf /usr/local/bin/gsed       bin/sed
                run ln -sf /usr/local/bin/gawk       bin/awk
                run ln -sf /usr/local/bin/ghead      bin/head
                run ln -sf /usr/local/bin/ggrep      bin/grep
                run ln -sf /usr/local/bin/gfind      bin/find
                run ln -sf /usr/local/bin/gmake      bin/make
                run ln -sf /usr/local/bin/gbase64    bin/base64
                run ln -sf /usr/local/bin/gunlink    bin/unlink
                run ln -sf /usr/local/bin/ginstall   bin/install
                run ln -sf /usr/local/bin/gsha256sum bin/sha256sum
                run ln -sf /usr/local/bin/pkgconf    bin/pkg-config

                # tree package in system's package manager is too old
                printf '%s\n' '#!/bin/sh' > bin/tree
                chmod +x                    bin/tree

                cat > profile <<EOF
export ACLOCAL_PATH=/usr/local/share/aclocal

PPFLAGS=-I/usr/local/include
LDFLAGS=-L/usr/local/lib
EOF
                ;;
            netbsd)
                run $sudo pkgin -y update
                run $sudo pkgin -y install bash coreutils findutils gawk gsed grep tree bsdtar patch patchelf pkg-config go git curl cmake ninja-build gmake llvm flex bison m4 jq

                run ln -sf /usr/pkg/go118/bin/go   bin/go
                run ln -sf /usr/pkg/bin/gln        bin/ln
                run ln -sf /usr/pkg/bin/gm4        bin/m4
                run ln -sf /usr/pkg/bin/gsed       bin/sed
                run ln -sf /usr/pkg/bin/gawk       bin/awk
                run ln -sf /usr/pkg/bin/ggrep      bin/grep
                run ln -sf /usr/pkg/bin/gfind      bin/find
                run ln -sf /usr/pkg/bin/gmake      bin/make
                run ln -sf /usr/pkg/bin/gbase64    bin/base64
                run ln -sf /usr/pkg/bin/gunlink    bin/unlink
                run ln -sf /usr/pkg/bin/ginstall   bin/install
                run ln -sf /usr/pkg/bin/gsha256sum bin/sha256sum

                printf 'export ACLOCAL_PATH=/usr/pkg/share/aclocal' > profile

                run sudo sed -i 's/#ETCCERTSDIR=/ETCCERTSDIR=/' /usr/pkg/etc/ca-certificates-dir.conf
                run sudo update-ca-certificates

                unset ETCCERTSDIR

                ETCCERTSDIR=$(sed -n '/^ETCCERTSDIR=/p' /usr/pkg/etc/ca-certificates-dir.conf | sed 's|ETCCERTSDIR=\(.*\)|\1|')

                if [ -n "$ETCCERTSDIR" ] ; then
                    export SSL_CERT_FILE="$ETCCERTSDIR/ca-certificates.crt"
                fi
                ;;
            *)  abort 1 "$NATIVE_OS_KIND is not supported yet."
        esac

        export PATH="$PWD/bin:$PATH"

        #################################################################################

        step "install CA Certificate"

        # https://curl.se/docs/caextract.html
        wfetch 'https://curl.se/ca/cacert.pem' -o cacert.pem --no-buffer

        export SSL_CERT_FILE="$PWD/cacert.pem"

        #################################################################################

        case $NATIVE_OS_NAME in
            alpine)  SYSPM=apk ;;
            debian)  SYSPM=apt ;;
            ubuntu)  SYSPM=apt ;;
            centos)  SYSPM=dnf ;;
            fedora)  SYSPM=dnf ;;
            rhel)    SYSPM=dnf ;;
            void)    SYSPM=xbps   ;;
            gentoo)  SYSPM=emerge ;;
            manjaro) SYSPM=pacman ;;
            arch)    SYSPM=pacman ;;
            linuxmint) SYSPM=apt  ;;
            opensuse-leap) SYSPM=zypper ;;
            darwin)    SYSPM=brew    ;;
            dragonfly) SYSPM=pkg     ;;
            freebsd)   SYSPM=pkg     ;;
            openbsd)   SYSPM=pkg_add ;;
            netbsd)    SYSPM=pkgin   ;;
        esac

        #################################################################################

        step "install uppm shim"
        wfetch "https://raw.githubusercontent.com/leleliu008/ppkg/master/uppm-shim-$SYSPM" -o uppm --no-buffer
        run chmod +x uppm

        #################################################################################

        step "install yq"

        unset YQ_URL
        unset YQ_SHA

        # https://github.com/mikefarah/yq/releases
        case $NATIVE_OS_KIND in
            linux)
                YQ_URL='https://github.com/mikefarah/yq/releases/download/v4.27.5/yq_linux_amd64'
                YQ_SHA='9a54846e81720ae22814941905cd3b056ebdffb76bf09acffa30f5e90b22d615'
                ;;
            freebsd)
                YQ_URL='https://github.com/mikefarah/yq/releases/download/v4.27.5/yq_freebsd_amd64'
                YQ_SHA='81c39a58c30bd5805378c843c12cb038477c6c1c37628a49e30f0ce6e7ade732'
                ;;
            openbsd)
                YQ_URL='https://github.com/mikefarah/yq/releases/download/v4.27.5/yq_openbsd_amd64'
                YQ_SHA='2c3c42137b7bff40b7f592d13923f5d3fcd8f91e8f54131c3c4059bd6890283c'
                ;;
            netbsd)
                YQ_URL='https://github.com/mikefarah/yq/releases/download/v4.27.5/yq_netbsd_amd64'
                YQ_SHA='cad6dcd7449e11868eadb122bca6be5ec8a0918f822528e1e7c845d4ca637492'
                ;;
        esac

        if [ -n    "$YQ_URL" ] && [ -n "$YQ_SHA" ] ; then
            wfetch "$YQ_URL"  --sha256="$YQ_SHA" -o bin/yq --no-buffer
            run chmod +x bin/yq
        fi

        #################################################################################

        [ "$NATIVE_OS_KIND" != darwin ] && {
            step "install patchelf"
            wfetch 'https://github.com/NixOS/patchelf/archive/refs/tags/0.17.2.zip' -o patchelf-0.17.2.zip --no-buffer
            run bsdtar xf patchelf-0.17.2.zip --no-same-owner
            run c++ -std=c++17 -Wall -D_FILE_OFFSET_BITS=64 -static -O3 -o bin/patchelf  patchelf-0.17.2/src/patchelf.cc
        }

        step "install base16-encode and base16-decode"
        wfetch 'https://github.com/leleliu008/C-examples/archive/refs/heads/master.zip' -o C-examples-master.zip --no-buffer
        run bsdtar xf C-examples-master.zip --no-same-owner

        run cmake -S C-examples-master/algorithm/base16 -B C-examples-master/algorithm/base16/build.d -DCMAKE_INSTALL_PREFIX="$PWD" -DENABLE_TESTING=OFF -DCMAKE_VERBOSE_MAKEFILE=ON
        run cmake --build   C-examples-master/algorithm/base16/build.d
        run cmake --install C-examples-master/algorithm/base16/build.d

        step "install base64-encode and base64-decode"
        run cmake -S C-examples-master/library/mbedTLS/base64 -B C-examples-master/library/mbedTLS/base64/build.d -DCMAKE_INSTALL_PREFIX="$PWD" -DENABLE_TESTING=OFF -DCMAKE_VERBOSE_MAKEFILE=ON
        run cmake --build   C-examples-master/library/mbedTLS/base64/build.d
        run cmake --install C-examples-master/library/mbedTLS/base64/build.d

        step "install sysinfo"
        run cmake -S C-examples-master/utils/sysinfo -B C-examples-master/utils/sysinfo/build.d -DCMAKE_INSTALL_PREFIX="$PWD" -DENABLE_TESTING=OFF -DCMAKE_VERBOSE_MAKEFILE=ON
        run cmake --build   C-examples-master/utils/sysinfo/build.d
        run cmake --install C-examples-master/utils/sysinfo/build.d
    else
        __setup_uppm
    fi

    #########################################################################################

    cat > wrapper-native-cc.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char * argv[]) {
    char * const cc = getenv("PROXIED_CC_FOR_BUILD");

    if (cc == NULL) {
        fprintf(stderr, "PROXIED_CC_FOR_BUILD environment variable is not set.\n");
        return 1;
    }

    if (cc[0] == '\0') {
        fprintf(stderr, "PROXIED_CC_FOR_BUILD environment variable value should be a non-empty string.\n");
        return 2;
    }

    char* argv2[argc + 2];

    argv2[0] = cc;

    char * const sysroot = getenv("SYSROOT_FOR_BUILD");

    if (sysroot == NULL || sysroot[0] == '\0') {
        for (int i = 1; i < argc; i++) {
            argv2[i] = argv[i];
        }

        argv2[argc] = NULL;
    } else {
        argv2[1] = (char*)"-isysroot";
        argv2[2] = sysroot;

        for (int i = 1; i < argc; i++) {
            argv2[i + 2] = argv[i];
        }

        argv2[argc + 2] = NULL;
    }

    execv (cc, argv2);
    perror(cc);
    return 255;
}
EOF

    cat > wrapper-native-c++.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char * argv[]) {
    char * const cxxc = getenv("PROXIED_CXX_FOR_BUILD");

    if (cxxc == NULL) {
        fprintf(stderr, "PROXIED_CXX_FOR_BUILD environment variable is not set.\n");
        return 1;
    }

    if (cxxc[0] == '\0') {
        fprintf(stderr, "PROXIED_CXX_FOR_BUILD environment variable value should be a non-empty string.\n");
        return 2;
    }

    char* argv2[argc + 2];

    argv2[0] = cxxc;

    char * const sysroot = getenv("SYSROOT_FOR_BUILD");

    if (sysroot == NULL || sysroot[0] == '\0') {
        for (int i = 1; i < argc; i++) {
            argv2[i] = argv[i];
        }

        argv2[argc] = NULL;
    } else {
        argv2[1] = (char*)"-isysroot";
        argv2[2] = sysroot;

        for (int i = 1; i < argc; i++) {
            argv2[i + 2] = argv[i];
        }

        argv2[argc + 2] = NULL;
    }

    execv (cxxc, argv2);
    perror(cxxc);
    return 255;
}
EOF

    cat > wrapper-native-objc.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char * argv[]) {
    char * const objc = getenv("PROXIED_OBJC_FOR_BUILD");

    if (objc == NULL) {
        fprintf(stderr, "PROXIED_OBJC_FOR_BUILD environment variable is not set.\n");
        return 1;
    }

    if (objc[0] == '\0') {
        fprintf(stderr, "PROXIED_OBJC_FOR_BUILD environment variable value should be a non-empty string.\n");
        return 2;
    }

    char* argv2[argc + 2];

    argv2[0] = objc;

    char * const sysroot = getenv("SYSROOT_FOR_BUILD");

    if (sysroot == NULL || sysroot[0] == '\0') {
        for (int i = 1; i < argc; i++) {
            argv2[i] = argv[i];
        }

        argv2[argc] = NULL;
    } else {
        argv2[1] = (char*)"-isysroot";
        argv2[2] = sysroot;

        for (int i = 1; i < argc; i++) {
            argv2[i + 2] = argv[i];
        }

        argv2[argc + 2] = NULL;
    }

    execv (objc, argv2);
    perror(objc);
    return 255;
}
EOF

    cat > wrapper-target-cc.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <regex.h>

//  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//  â”‚  preprocess  â”‚
//  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//         â†“
//  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//  â”‚   compile    â”‚
//  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//         â†“
//  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//  â”‚   assemble   â”‚
//  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//         â†“
//  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//  â”‚     link     â”‚
//  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


#define ACTION_CREATE_OBJECT_FILE 1
#define ACTION_CREATE_SHARED_LIBRARY 2
#define ACTION_CREATE_STATICALLY_LINKED_EXECUTABLE 3
#define ACTION_CREATE_DYNAMICALLY_LINKED_EXECUTABLE 4

int main(int argc, char* argv[]) {
    const char * options[7] = { "-shared", "-Bshareable", "-static", "--static", "-pie", "-c", "-o" };
          int    indexes[7] = {    -1,          -1,           -1,       -1,        -1,    -1,   -1  };

    for (int i = 1; i < argc; i++) {
        for (int j = 0; j < 7; j++) {
            if (strcmp(argv[i], options[j]) == 0) {
                indexes[j] = i;
                break;
            }
        }
    }

    int action = 0;

    if (indexes[0] > 0 || indexes[1] > 0) {
        // if -shared option is specified, then remove -static , --static , -pie options if they also are specified
        action = ACTION_CREATE_SHARED_LIBRARY;
    } else if ((indexes[2] > 0) || (indexes[3] > 0)) {
        // if -shared option is not specified, but -static or --static option is specified, then remove -pie , -Wl,-Bdynamic option if it also is specified
        action = ACTION_CREATE_STATICALLY_LINKED_EXECUTABLE;
    } else if (indexes[4] > 0) {
        action = ACTION_CREATE_DYNAMICALLY_LINKED_EXECUTABLE;
    }

    /////////////////////////////////////////////////////////////////

#ifdef WRAPPER_CXX
    char * const compiler = getenv("PROXIED_CXX");

    if (compiler == NULL) {
        fprintf(stderr, "PROXIED_CXX environment variable is not set.\n");
        return 1;
    }

    if (compiler[0] == '\0') {
        fprintf(stderr, "PROXIED_CXX environment variable value should be a non-empty string.\n");
        return 2;
    }
#else
    char * const compiler = getenv("PROXIED_CC");

    if (compiler == NULL) {
        fprintf(stderr, "PROXIED_CC environment variable is not set.\n");
        return 1;
    }

    if (compiler[0] == '\0') {
        fprintf(stderr, "PROXIED_CC environment variable value should be a non-empty string.\n");
        return 2;
    }
#endif

    /////////////////////////////////////////////////////////////////

    char* argv2[argc + 2];

    argv2[0] = compiler;

    if (action == ACTION_CREATE_SHARED_LIBRARY) {
        for (int i = 1; i < argc; i++) {
            if (strcmp(argv[i], "-static") == 0) {
                argv2[i] = (char*)"--shared";
            } else if (strcmp(argv[i], "--static") == 0) {
                argv2[i] = (char*)"--shared";
            } else if (strcmp(argv[i], "-pie") == 0) {
                argv2[i] = (char*)"--shared";
            } else {
                argv2[i] = argv[i];
            }
        }
    } else if (action == ACTION_CREATE_STATICALLY_LINKED_EXECUTABLE) {
        for (int i = 1; i < argc; i++) {
            if (strcmp(argv[i], "-Wl,--export-dynamic") == 0) {
                argv2[i] = (char*)"-static";
            } else if (strcmp(argv[i], "-Wl,-Bdynamic") == 0) {
                argv2[i] = (char*)"-static";
            } else if (strcmp(argv[i], "-pie") == 0) {
                argv2[i] = (char*)"-static";
            } else {
                argv2[i] = argv[i];
            }
        }
    } else {
        for (int i = 1; i < argc; i++) {
            argv2[i] = argv[i];
        }
    }

    /////////////////////////////////////////////////////////////////

    const char * const SYSROOT = getenv("SYSROOT");

    if (SYSROOT == NULL || SYSROOT[0] == '\0') {
        argv2[argc] = NULL;

        execv (compiler, argv2);
        perror(compiler);
        return 255;
    } else {
        size_t   sysrootArgLength = strlen(SYSROOT) + 11U;
        char     sysrootArg[sysrootArgLength];
        snprintf(sysrootArg, sysrootArgLength, "--sysroot=%s", SYSROOT);

        argv2[argc]     = sysrootArg;
        argv2[argc + 1] = NULL;

        execv (compiler, argv2);
        perror(compiler);
        return 255;
    }
}
EOF

    run cc -std=c99 -o wrapper-native-cc   wrapper-native-cc.c
    run cc -std=c99 -o wrapper-native-c++  wrapper-native-c++.c
    run cc -std=c99 -o wrapper-native-objc wrapper-native-objc.c

    run cc -std=c99 -o wrapper-target-cc   wrapper-target-cc.c
    run cc -std=c99 -o wrapper-target-c++  wrapper-target-cc.c -DWRAPPER_CXX

    run cp wrapper-target-cc wrapper-target-objc

    #########################################################################################

    cat > sed-in-place.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char* argv[]) {
    char * const sed = getenv("SED");

    if (sed == NULL || sed[0] == '\0') {
        fprintf(stderr, "SED environment variable was not set.\n");
        return 1;
    }

    /////////////////////////////////////////////////////////////////

    char* argv2[argc + 2];

    argv2[0] = sed;
    argv2[1] = (char*)"-i";

    for (int i = 1; i < argc; i++) {
        argv2[i + 1] = argv[i];
    }

    argv2[argc + 1] = NULL;

    for (int i = 0; argv2[i] != NULL; i++) {
        fprintf(stderr, "%s ", argv2[i]);
    }
    fprintf(stderr, "\n");

    execv (sed, argv2);
    perror(sed);
    return 255;
}
EOF

    run cc -std=c99 -o sed-in-place sed-in-place.c

    #########################################################################################

    if [ -d        "$PPKG_CORE_DIR" ] ; then
        run rm -rf "$PPKG_CORE_DIR"
    fi

    run mv "$SESSION_DIR" "$PPKG_HOME/"

    success "ppkg have been successfully setup."
}

# use commands: uname curl|wget tar xz cut
__setup_uppm() {
    unset FETCH_TOOL

    for FETCH_TOOL in curl wget http lynx aria2c axel
    do
        if command -v "$FETCH_TOOL" > /dev/null ; then
            break
        else
            unset FETCH_TOOL
        fi
    done

    if [ -z "$FETCH_TOOL" ] ; then
        abort 1 "no any fetch tool[curl, wget, http, lynx, aria2c, axel] found."
    else
        unset FETCH_TOOL
    fi

    ##################################################################################

    wfetch 'https://raw.githubusercontent.com/leleliu008/uppm/master/latest-release' -o uppm-latest-release --no-buffer

    ##################################################################################

    UPPM_LATEST_RELEASE_TAGNAME="$(cat uppm-latest-release)"
    UPPM_LATEST_RELEASE_VERSION="$(printf '%s\n' "$UPPM_LATEST_RELEASE_TAGNAME" | cut -d+ -f1)"

    case $NATIVE_OS_KIND in
        darwin)
            case $(sw_vers -productVersion | cut -d. -f1) in
                10) X='10.15' ;;
                11) X='11.0'  ;;
                12) X='12.0'  ;;
                13) X='13.0'  ;;
                *)  X='14.0'  ;;
            esac

            UPPM_LATEST_RELEASE_ARCHIVE_FILENAME="uppm-${UPPM_LATEST_RELEASE_VERSION}-macos-${X}-${NATIVE_OS_ARCH}.tar.xz"
            ;;
        freebsd)
            case $(freebsd-version) in
                13.0) X='13.0' ;;
                13.1) X='13.1' ;;
                *)    X='13.2' ;;
            esac

            UPPM_LATEST_RELEASE_ARCHIVE_FILENAME="uppm-${UPPM_LATEST_RELEASE_VERSION}-${NATIVE_OS_KIND}-${X}-${NATIVE_OS_ARCH}.tar.xz"
            ;;
        openbsd)
            case $(uname -r) in
                7.3) X='7.3' ;;
                *)   X='7.4' ;;
            esac

            UPPM_LATEST_RELEASE_ARCHIVE_FILENAME="uppm-${UPPM_LATEST_RELEASE_VERSION}-${NATIVE_OS_KIND}-${X}-${NATIVE_OS_ARCH}.tar.xz"
            ;;
        netbsd)
            case $(uname -r) in
                9.1) X='9.1' ;;
                9.2) X='9.2' ;;
                *)   X='9.3' ;;
            esac

            UPPM_LATEST_RELEASE_ARCHIVE_FILENAME="uppm-${UPPM_LATEST_RELEASE_VERSION}-${NATIVE_OS_KIND}-${X}-${NATIVE_OS_ARCH}.tar.xz"
            ;;
        *)  UPPM_LATEST_RELEASE_ARCHIVE_FILENAME="uppm-${UPPM_LATEST_RELEASE_VERSION}-${NATIVE_OS_KIND}-${NATIVE_OS_ARCH}.tar.xz"
    esac

    wfetch "https://github.com/leleliu008/uppm/releases/download/${UPPM_LATEST_RELEASE_TAGNAME}/${UPPM_LATEST_RELEASE_ARCHIVE_FILENAME}" -o "$UPPM_LATEST_RELEASE_ARCHIVE_FILENAME" --no-buffer

    run tar xvf "$UPPM_LATEST_RELEASE_ARCHIVE_FILENAME" --strip-components=1 --no-same-owner

    run mv bin/uppm .

    ##################################################################################

    # https://curl.se/docs/caextract.html
    wfetch 'https://curl.se/ca/cacert.pem' -o cacert.pem --no-buffer

    ##################################################################################

    export SSL_CERT_FILE="$PWD/cacert.pem"

    run ./uppm env
    run ./uppm update

    unset UPPM_PACKAGE_EXEFIND_PATH
    unset UPPM_PACKAGE_ACLOCAL_PATH

    for item in bash coreutils findutils easyutils gawk gsed grep bsdtar jq yq git curl tree patchelf
    do
        run ./uppm install "$item"

        UPPM_PACKAGE_INSTALLED_DIR="$(./uppm info "$item" installed-dir)"

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/bin" ] ; then
            UPPM_PACKAGE_EXEFIND_PATH="$UPPM_PACKAGE_EXEFIND_PATH:$UPPM_PACKAGE_INSTALLED_DIR/bin"
        fi

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/sbin" ] ; then
            UPPM_PACKAGE_EXEFIND_PATH="$UPPM_PACKAGE_EXEFIND_PATH:$UPPM_PACKAGE_INSTALLED_DIR/sbin"
        fi

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
            UPPM_PACKAGE_ACLOCAL_PATH="$UPPM_PACKAGE_ACLOCAL_PATH:$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal"
        fi
    done

    UPPM_PACKAGE_EXEFIND_PATH="${UPPM_PACKAGE_EXEFIND_PATH#':'}"
    UPPM_PACKAGE_ACLOCAL_PATH="${UPPM_PACKAGE_ACLOCAL_PATH#':'}"

    cat > profile <<EOF
export ACLOCAL_PATH="$UPPM_PACKAGE_ACLOCAL_PATH:\$ACLOCAL_PATH"
export PATH="$UPPM_PACKAGE_EXEFIND_PATH:\$PATH"

# https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables
if [ -d "\$HOME/.uppm/installed/git/libexec/git-core" ] ; then
    export GIT_EXEC_PATH="\$HOME/.uppm/installed/git/libexec/git-core"
    export GIT_TEMPLATE_DIR="\$HOME/.uppm/installed/git/share/git-core/templates"
    export GIT_CONFIG_NOSYSTEM=1
fi
EOF
}

# }}}
##############################################################################
# {{{ ppkg help

__help() {
    printf '%b\n' "
${COLOR_GREEN}A portable package manager for UNIX and UNIX-like systems.${COLOR_OFF}

${COLOR_GREEN}ppkg <ACTION> [ARGUMENT...]${COLOR_OFF}

${COLOR_GREEN}ppkg help${COLOR_OFF}
${COLOR_GREEN}ppkg --help${COLOR_OFF}
${COLOR_GREEN}ppkg -h${COLOR_OFF}
    show help of this command.

${COLOR_GREEN}ppkg version${COLOR_OFF}
${COLOR_GREEN}ppkg --version${COLOR_OFF}
${COLOR_GREEN}ppkg -V${COLOR_OFF}
    show version of this command.

${COLOR_GREEN}ppkg setup${COLOR_OFF}
    install essential tools (e.g. uppm, bash, coreutils, findutils, gsed, grep, git, curl, bsdtar, tree, jq, yq, etc) used by this shell script.

${COLOR_GREEN}ppkg env${COLOR_OFF}
    show basic information about this software.

${COLOR_GREEN}ppkg sysinfo${COLOR_OFF}
    show basic information about your current running operation system.

${COLOR_GREEN}ppkg gen-url-transform-sample${COLOR_OFF}
    generate url-transform sample.

${COLOR_GREEN}ppkg integrate zsh [--output-dir=<DIR>]${COLOR_OFF}
    download a zsh-completion script file to a approprivate location.

${COLOR_GREEN}ppkg update${COLOR_OFF}
    update all the available formula repositories.

${COLOR_GREEN}ppkg upgrade-self${COLOR_OFF}
    upgrade this software.

${COLOR_GREEN}ppkg cleanup${COLOR_OFF}
    delete the unused cached files.


${COLOR_GREEN}ppkg ls-available${COLOR_OFF}
    list all the available packages.

${COLOR_GREEN}ppkg ls-installed${COLOR_OFF}
    list all the installed packages.

${COLOR_GREEN}ppkg ls-outdated${COLOR_OFF}
    list all the outdated  packages.


${COLOR_GREEN}ppkg is-available <PACKAGE-NAME>${COLOR_OFF}
    check if the given package is available

${COLOR_GREEN}ppkg is-installed <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is installed

${COLOR_GREEN}ppkg is-outdated  <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is outdated


${COLOR_GREEN}ppkg formula-repo-init <FORMULA-REPO-NAME> <FORMULA-REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    create a new empty formula repository.

${COLOR_GREEN}ppkg formula-repo-add  <FORMULA-REPO-NAME> <FORMULA-REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    create a new empty formula repository then sync with server.

${COLOR_GREEN}ppkg formula-repo-del  <FORMULA-REPO-NAME>${COLOR_OFF}
    delete the given formula repository.

${COLOR_GREEN}ppkg formula-repo-sync <FORMULA-REPO-NAME>${COLOR_OFF}
    update the given formula repository.

${COLOR_GREEN}ppkg formula-repo-info <FORMULA-REPO-NAME>${COLOR_OFF}
    show information of the given formula repository.

${COLOR_GREEN}ppkg formula-repo-conf <FORMULA-REPO-NAME> [--url=VALUE --branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    change the config of the given formula repository.

${COLOR_GREEN}ppkg formula-repo-list${COLOR_OFF}
    list all available formula repositories.


${COLOR_GREEN}ppkg search <REGULAR-EXPRESSION-PARTTEN>${COLOR_OFF}
    search all available packages whose name matches the given regular expression partten.


${COLOR_GREEN}ppkg info-available <PACKAGE-NAME> [--json | --yaml | <KEY>]${COLOR_OFF}
    show information of the given available package.

${COLOR_GREEN}ppkg info-installed <PACKAGE-SPEC> [--json | --yaml | <KEY>]${COLOR_OFF}
    show information of the given installed package.


${COLOR_GREEN}ppkg depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    show the packages that are depended by the given package.

    <OUTPUT-TYPE> must be one of dot box svg png

    <OUTPUT-PATH> can be either the filepath or directory.

    If -o <OUTPUT-PATH> option is specified, the result will be written to file, otherwise, the result will be written to stdout.

    If <OUTPUT-PATH> is . .. ./ ../ or ends with slash(/), then it will be treated as a directory, otherwise, it will be treated as a filepath.

    If <OUTPUT-PATH> is treated as a directory, then it will be expanded to <OUTPUT-PATH>/<PACKAGE-NAME>-dependencies.<OUTPUT-TYPE>

    If <OUTPUT-PATH> is treated as a filepath, and if -t <OUTPUT-TYPE> option is not given, if <OUTPUT-PATH> ends with one of .dot|.box|.svg|.png, <OUTPUT-TYPE> will be the <OUTPUT-PATH> suffix, otherwise, <OUTPUT-TYPE> will be box.

    If -t <OUTPUT-TYPE> and -o <OUTPUT-PATH> options both are not given, <OUTPU-TYPE> will be box and output to stdout.


${COLOR_GREEN}ppkg fetch <PACKAGE-NAME>${COLOR_OFF}
    download all the resources of the given package to the local cache.


${COLOR_GREEN}ppkg install <PACKAGE-SPEC>... [INSTALL-OPTIONS]${COLOR_OFF}
    install the given packages.

    ${COLOR_RED}C and C++ compiler for native build should be installed by yourself using your system's default package manager before running this command.${COLOR_OFF}

    <PACKAGE-NAME> must match the regular expression pattern ${COLOR_RED}^[A-Za-z0-9+-_.@]{1,50}$ ${COLOR_OFF}

    <PACKAGE-SPEC> is a formatted string that has form ${COLOR_RED}<TARGET>/<PACKAGE-NAME>${COLOR_OFF}

    <TARGET> indicates which platform would be built for.

    <TARGET> is a formatted string that has form ${COLOR_RED}<PLATFORM-NAME>-<PLATFORM-VERSION>-<PLATFORM-ARCH>${COLOR_OFF}

    <PLATFORM-NAME> : e.g. linux, macos, freebsd, openbsd, netbsd, dragonflybsd, etc

    <PLATFORM-VERSION> : specify the platform version to be built with. It usually matches the regular expression pattern '[0-9][0-9]?.[0-9][0-9]?', e.g. 10.15, 11.0, 12.0, 12.6, etc.

    <PLATFORM-ARCH> : e.g. x86_64, amd64, arm64, aarch64, riscv64, ppc64le, s390x, etc

    <TARGET> examples:
        linux-glibc-x86_64
        linux-glibc-aarch64
        linux-glibc-riscv64
        linux-glibc-ppc64le
        linux-glibc-s390x

        linux-musl-x86_64
        linux-musl-aarch64
        linux-musl-riscv64
        linux-musl-ppc64le
        linux-musl-s390x

        macos-13.0-x86_64
        macos-12.0-arm64

        dragonflybsd-6.4-x86_64

        freebsd-13.2-amd64
        openbsd-7.4-amd64
        netbsd-9.1-amd64

    INSTALL-OPTIONS:
        ${COLOR_BLUE}--target=<TARGET>${COLOR_OFF}
            specify the target to be built for.

            If this option is unspecified, the environment variable ${COLOR_RED}PPKG_DEFAULT_TARGET${COLOR_OFF} is honored, if the environment variable PPKG_DEFAULT_TARGET is not set, <TARGET> will be same as your current running operation system.

        ${COLOR_BLUE}--jobs=N${COLOR_OFF}
            specify the number of jobs you can run in parallel.

        ${COLOR_BLUE}-q${COLOR_OFF}
            silent mode. no any messages will be output to terminal.

        ${COLOR_BLUE}-v${COLOR_OFF}
            verbose mode. many messages will be output to terminal.

        ${COLOR_BLUE}-vv${COLOR_OFF}
            very verbose mode. many many messages will be output to terminal.

        ${COLOR_BLUE}--build-type=<debug|release>${COLOR_OFF}
            specify the build type.

        ${COLOR_BLUE}--link-type=<static-full|static-most|shared-full|shared-most>${COLOR_OFF}
            specify the link strategy.

            a fully  statically linked executable is a executable that without any additional library dependencies even the standard C library.
            a mostly statically linked executable is a executable that without any additional library dependencies except the standard C library.

            a fully  statically linked executable is easy to distribute and deploy especially on different GNU/Linux systems.
            a mostly statically linked executable is easy to distribute and deploy especially on macOS.

        ${COLOR_BLUE}--disable-ccache${COLOR_OFF}
            do not use ccache.

        ${COLOR_BLUE}--export-compile-commands-json${COLOR_OFF}
            generates compile_commands.json

        ${COLOR_BLUE}--upgrade${COLOR_OFF}
            If this package has been already installed, then it will be upgraded if it could be.

        ${COLOR_BLUE}--dry-run${COLOR_OFF}
            do not actually install the package.

        ${COLOR_BLUE}--keep-session-dir${COLOR_OFF}
            do not delete the session directory even if this package is successfully installed.

${COLOR_GREEN}ppkg reinstall <PACKAGE-SPEC>... [INSTALL-OPTIONS]${COLOR_OFF}
    reinstall the given packages.

${COLOR_GREEN}ppkg upgrade   <PACKAGE-SPEC>... [INSTALL-OPTIONS]${COLOR_OFF}
    upgrade the given packages or all outdated packages.

${COLOR_GREEN}ppkg uninstall <PACKAGE-SPEC>...${COLOR_OFF}
    uninstall the given packages.


${COLOR_GREEN}ppkg tree <PACKAGE-SPEC> [-a | --dirsfirst | -L N]${COLOR_OFF}
    list installed files of the given installed package in a tree-like format.

${COLOR_GREEN}ppkg logs <PACKAGE-SPEC>${COLOR_OFF}
    show logs of the given installed package.

${COLOR_GREEN}ppkg pack <PACKAGE-SPEC> [--keep-session-dir] [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    pack the given installed package.

    <OUTPUT-TYPE> must ends with one of tar.gz tar.xz tar.lz tar.bz2 zip

    <OUTPUT-PATH> can be either the filepath or directory which indicates where the packed archive file would be written to.

    If <OUTPUT-PATH> is . .. ./ ../ or ends with slash(/), then it would be treated as a directory, otherwise, it would be treated as a filepath.

    If <OUTPUT-PATH> is treated as a filepath, then it must ends with one of .tar.gz .tar.xz .tar.lz .tar.bz2 .tgz .txz .tlz .tbz2 .zip , in this case, -t <OUTPUT-TYPE> option would be ignored if it also is specified.

    If <OUTPUT-PATH> is treated as a directory, then it would be expanded to <OUTPUT-PATH>/<PACKAGE-NAME>-<PACKAGE-VERSION>-<TARGET-PLATFORM-NAME>-<TARGET-PLATFORM-ARCH><OUTPUT-TYPE>

    If -o <OUTPUT-PATH> option is unspecified, <OUTPUT-PATH> would be assigned to ./<PACKAGE-NAME>-<PACKAGE-VERSION>-<TARGET-PLATFORM-NAME>-<TARGET-PLATFORM-ARCH><OUTPUT-TYPE>

    If -t <OUTPUT-TYPE> option is unspecified, <OUTPUT-TYPE> would be assigned to .tar.xz

${COLOR_GREEN}ppkg export.<OUTPUT-TYPE> <PACKAGE-SPEC> [-o <OUTPUT-PATH>] [--keep-session-dir]${COLOR_OFF}
    export the given installed package as another package format.

    <OUTPUT-TYPE> can be any one of deb, rpm, pkg, apk

    <OUTPUT-PATH> can be either the filepath or directory which indicates where the final file would be written to.

    If <OUTPUT-PATH> is . .. ./ ../ or ends with slash(/), then it would be treated as a directory, otherwise, it would be treated as a filepath.

    If <OUTPUT-PATH> is treated as a directory, then it would be expanded to <OUTPUT-PATH>/<PACKAGE-NAME>-<PACKAGE-VERSION>-<TARGET-PLATFORM-NAME>-<TARGET-PLATFORM-ARCH><OUTPUT-TYPE>

    If -o <OUTPUT-PATH> option is unspecified, the final file would be written to current directory.

    export.deb command only can be run on Debian GNU Linux and it's derivatives.
    export.rpm command only can be run on RHEL/CentOS/Fedora/openSUSE Linux and their derivatives.
    export.pkg command only can be run on Arch Linux and it's derivative.
    export.apk command only can be run on Alpine Linux.
"
}

# }}}
##############################################################################
# {{{ ppkg main

main() {
    set -e

    [ -n "$PPKG_XTRACE" ] && set -x

    [ -z "$HOME" ] && abort 1 "HOME environment variable is not set."

    PPKG="$CURRENT_SCRIPT_FILEPATH"

    PPKG_VERSION=0.4.1

    PPKG_OFFICIAL_FORMULA_REPO_URL="https://github.com/leleliu008/ppkg-formula-repository-official-core.git"
    PPKG_UPGRAGE_URL='https://raw.githubusercontent.com/leleliu008/ppkg/master/ppkg'

    PPKG_HOME="$HOME/.ppkg"

    PPKG_FORMULA_REPO_ROOT="$PPKG_HOME/repos.d"
    PPKG_PACKAGE_INSTALLED_ROOT="$PPKG_HOME/installed"
    PPKG_PACKAGE_SYMLINKED_ROOT="$PPKG_HOME/symlinked"
    PPKG_DOWNLOADS_DIR="$PPKG_HOME/downloads"
    PPKG_BACKUP_DIR="$PPKG_HOME/backup.d"

    PPKG_CORE_DIR="$PPKG_HOME/core"
    PPKG_CORE_BIN_DIR="$PPKG_CORE_DIR/bin"

    PPKG_SYSROOT="$PPKG_HOME/sysroot"

    NATIVE_PACKAGE_INSTALLED_ROOT="$PPKG_HOME/native"

    UPPM="$PPKG_CORE_DIR/uppm"

    TIMESTAMP_UNIX="$(date +%s)"

    if [ -n  "$PPKG_URL_TRANSFORM" ] ; then
        export UPPM_URL_TRANSFORM="$PPKG_URL_TRANSFORM"
    fi

    # https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_default_verify_paths.html
    if [ -f "$PPKG_CORE_DIR/cacert.pem" ] ; then
        export SSL_CERT_FILE="$PPKG_CORE_DIR/cacert.pem"
    fi

    unset UPPM_HOME

    #########################################################################################

    case $1 in
        ''|help|--help|-h)
            __help
            return 0
            ;;
        version|--version|-V)
            printf '%s\n' "$PPKG_VERSION"
            return 0
            ;;
        setup)
            shift
            __setup "$@"
            return 0
            ;;
        gen-url-transform-sample)
            shift
            __gen_url_transform_sample "$@"
            return 0
            ;;
        env)
            cat <<EOF
ppkg.version : $PPKG_VERSION
ppkg.homedir : $PPKG_HOME
ppkg.exepath : $PPKG
ppkg.website : https://github.com/leleliu008/ppkg

EOF
            if [ -f "$UPPM" ] ; then
                "$UPPM" env
            fi

            return 0
            ;;
    esac

    #########################################################################################

    if [ -z "$CARGO_HOME" ] ; then
        bppend_to_PATH "$HOME/.cargo/bin"
    else
        bppend_to_PATH "$CARGO_HOME/bin"
    fi

    # pip install --user <PKG>
    bppend_to_PATH "$HOME/.local/bin"

    # cpan install to default local location
    bppend_to_PATH "$HOME/perl5/bin"

    #########################################################################################

    unset ACLOCAL_PATH

    unset CCFLAGS
    unset XXFLAGS
    unset PPFLAGS
    unset LDFLAGS

    #########################################################################################

    if [ -f "$PPKG_CORE_DIR/profile" ] ; then
        .   "$PPKG_CORE_DIR/profile"
    else
        abort 1 "please run ${COLOR_GREEN}$_0 setup${COLOR_OFF} command first, then try again."
    fi

    #########################################################################################

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    if [ -z  "$ACLOCAL_PATH" ] ; then
        export ACLOCAL_PATH="$PPKG_CORE_DIR/share/aclocal"
    else
        export ACLOCAL_PATH="$PPKG_CORE_DIR/share/aclocal:$ACLOCAL_PATH"
    fi

    bppend_to_PATH "$PPKG_CORE_BIN_DIR"

    #########################################################################################

    NATIVE_OS_KIND="$(sysinfo kind)"
    NATIVE_OS_TYPE="$(sysinfo type)"
    NATIVE_OS_CODE="$(sysinfo code)"
    NATIVE_OS_NAME="$(sysinfo name)"
    NATIVE_OS_VERS="$(sysinfo vers)"
    NATIVE_OS_ARCH="$(sysinfo arch)"
    NATIVE_OS_NCPU="$(sysinfo ncpu)"
    NATIVE_OS_LIBC="$(sysinfo libc)"
    NATIVE_OS_EUID="$(id -u)"
    NATIVE_OS_EGID="$(id -g)"

    TARGET_PLATFORM_NAME="$NATIVE_OS_TYPE"
    TARGET_PLATFORM_ARCH="$NATIVE_OS_ARCH"

    if [ "$NATIVE_OS_EUID" -ne 0 ] ; then
        sudo=sudo
    fi

    #########################################################################################

    case $1 in
        sysinfo)
            sysinfo
            return 0
            ;;

        info-available)
            shift
            __info_the_given_available_package "$@"
            ;;

        info-installed)
            shift
            __info_the_given_installed_package "$@"
            ;;

        ls-available) shift; __list_available_packages ;;
        ls-installed) shift; __list_installed_packages ;;
        ls-symlinked) shift; __list_symlinked_packages ;;
        ls-outdated)  shift; __list__outdated_packages ;;

        is-available)
            shift
            is_package_available "$1"
            ;;
        is-installed)
            shift
            PACKAGE_SPEC=
            PACKAGE_SPEC="$(inspect_package_spec "$1")"
            is_package_installed "$PACKAGE_SPEC"
            ;;
        is-symlinked)
            shift
            PACKAGE_SPEC=
            PACKAGE_SPEC="$(inspect_package_spec "$1")"
            is_package_symlinked "$PACKAGE_SPEC"
            ;;
        is-outdated)
            shift
            PACKAGE_SPEC=
            PACKAGE_SPEC="$(inspect_package_spec "$1")"
            is_package__outdated "$PACKAGE_SPEC"
            ;;

        update)            shift; __sync_available_formula_repositories "$@" ;;
        formula-repo-list) shift; __list_available_formula_repositories "$@" ;;
        formula-repo-info) shift; __info_the_given_formula_repository "$@" ;;
        formula-repo-conf) shift; __conf_the_given_formula_repository "$@" ;;
        formula-repo-sync) shift; __sync_the_given_formula_repository "$@" ;;
        formula-repo-init)
            shift

            case $1 in
                official-*) abort 1 "ppkg formula repository name that starts with 'official-' is reserved for ppkg official formula repository, please use other name."
            esac

            __create_a_formula_repository "$@"
            ;;
        formula-repo-add)
            shift

            case $1 in
                official-*) abort 1 "ppkg formula repository name that starts with 'official-' is reserved for ppkg official formula repository, please use other name."
            esac

            __create_a_formula_repository_then_sync_it "$@"
            ;;
        formula-repo-del)
            shift
            __delete_a_formula_repository "$@"
            ;;

        cleanup) shift; __cleanup "$@" ;;

        search)  shift; __search_packages "$@" ;;
 
        install) shift;   __install_the_given_packages "$@" ;;
      reinstall) shift; __reinstall_the_given_packages "$@" ;;
      uninstall) shift; __uninstall_the_given_packages "$@" ;;

        upgrade-self)
            shift
            __upgrade_self "$PPKG_UPGRAGE_URL" "$@"
            ;;
        upgrade)
            shift
            __upgrade_packages "$@"
            ;;
        integrate)
            shift
            case $1 in
                zsh) __integrate_zsh_completions 'https://raw.githubusercontent.com/leleliu008/ppkg/master/ppkg-zsh-completion' ;;
                *)   abort 1 "ppkg integrate $1: not support."
            esac
            ;;
        depends)  shift; __show_packages_depended_by_the_given_package "$@" ;;
        fetch)    shift;        __fetch_resources_of_the_given_package "$@" ;;

        logs) shift; __logs_the_given_installed_package "$@" ;;
        pack) shift; __pack_the_given_installed_package "$@" ;;
        tree) shift; __tree_the_given_installed_package "$@" ;;

        export.*)  __export_the_given_installed_package "$@" ;;

        *)  abort 1 "unrecognized argument: $1"
    esac
}

main "$@"

# }}}
##############################################################################
# {{{ vim operation

# last line mode :set foldmethod=marker
# command mode zM  fold close all
# command mode zR  fold open all
